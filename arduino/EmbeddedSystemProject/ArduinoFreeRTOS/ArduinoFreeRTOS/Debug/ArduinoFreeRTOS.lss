
ArduinoFreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000ae  00800100  00002b3e  00002bd2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002b3e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006f4  008001ae  008001ae  00002c80  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002c80  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002cb0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000458  00000000  00000000  00002cf0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006266  00000000  00000000  00003148  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001037  00000000  00000000  000093ae  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003021  00000000  00000000  0000a3e5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000db8  00000000  00000000  0000d408  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001b47  00000000  00000000  0000e1c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005aff  00000000  00000000  0000fd07  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000598  00000000  00000000  00015806  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
       4:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       8:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      2c:	0c 94 7d 02 	jmp	0x4fa	; 0x4fa <__vector_11>
      30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      34:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      40:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      48:	0c 94 43 0f 	jmp	0x1e86	; 0x1e86 <__vector_18>
      4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      50:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      68:	6c 0c       	add	r6, r12
      6a:	6c 0c       	add	r6, r12
      6c:	6c 0c       	add	r6, r12
      6e:	a7 0c       	add	r10, r7
      70:	95 0c       	add	r9, r5
      72:	a4 0c       	add	r10, r4
      74:	6c 0c       	add	r6, r12
      76:	6c 0c       	add	r6, r12
      78:	a7 0c       	add	r10, r7
      7a:	95 0c       	add	r9, r5

0000007c <__ctors_end>:
      7c:	11 24       	eor	r1, r1
      7e:	1f be       	out	0x3f, r1	; 63
      80:	cf ef       	ldi	r28, 0xFF	; 255
      82:	d8 e0       	ldi	r29, 0x08	; 8
      84:	de bf       	out	0x3e, r29	; 62
      86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
      88:	11 e0       	ldi	r17, 0x01	; 1
      8a:	a0 e0       	ldi	r26, 0x00	; 0
      8c:	b1 e0       	ldi	r27, 0x01	; 1
      8e:	ee e3       	ldi	r30, 0x3E	; 62
      90:	fb e2       	ldi	r31, 0x2B	; 43
      92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
      94:	05 90       	lpm	r0, Z+
      96:	0d 92       	st	X+, r0
      98:	ae 3a       	cpi	r26, 0xAE	; 174
      9a:	b1 07       	cpc	r27, r17
      9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
      9e:	28 e0       	ldi	r18, 0x08	; 8
      a0:	ae ea       	ldi	r26, 0xAE	; 174
      a2:	b1 e0       	ldi	r27, 0x01	; 1
      a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
      a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
      a8:	a2 3a       	cpi	r26, 0xA2	; 162
      aa:	b2 07       	cpc	r27, r18
      ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
      ae:	0e 94 22 12 	call	0x2444	; 0x2444 <main>
      b2:	0c 94 9d 15 	jmp	0x2b3a	; 0x2b3a <_exit>

000000b6 <__bad_interrupt>:
      b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
      ba:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      bc:	03 96       	adiw	r24, 0x03	; 3
      be:	92 83       	std	Z+2, r25	; 0x02
      c0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
      c2:	2f ef       	ldi	r18, 0xFF	; 255
      c4:	3f ef       	ldi	r19, 0xFF	; 255
      c6:	34 83       	std	Z+4, r19	; 0x04
      c8:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      ca:	96 83       	std	Z+6, r25	; 0x06
      cc:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      ce:	90 87       	std	Z+8, r25	; 0x08
      d0:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
      d2:	10 82       	st	Z, r1
      d4:	08 95       	ret

000000d6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
      d6:	fc 01       	movw	r30, r24
      d8:	11 86       	std	Z+9, r1	; 0x09
      da:	10 86       	std	Z+8, r1	; 0x08
      dc:	08 95       	ret

000000de <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
      de:	cf 93       	push	r28
      e0:	df 93       	push	r29
      e2:	9c 01       	movw	r18, r24
      e4:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
      e6:	dc 01       	movw	r26, r24
      e8:	11 96       	adiw	r26, 0x01	; 1
      ea:	cd 91       	ld	r28, X+
      ec:	dc 91       	ld	r29, X
      ee:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
      f0:	d3 83       	std	Z+3, r29	; 0x03
      f2:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
      f4:	8c 81       	ldd	r24, Y+4	; 0x04
      f6:	9d 81       	ldd	r25, Y+5	; 0x05
      f8:	95 83       	std	Z+5, r25	; 0x05
      fa:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
      fc:	8c 81       	ldd	r24, Y+4	; 0x04
      fe:	9d 81       	ldd	r25, Y+5	; 0x05
     100:	dc 01       	movw	r26, r24
     102:	13 96       	adiw	r26, 0x03	; 3
     104:	7c 93       	st	X, r23
     106:	6e 93       	st	-X, r22
     108:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     10a:	7d 83       	std	Y+5, r23	; 0x05
     10c:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     10e:	31 87       	std	Z+9, r19	; 0x09
     110:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     112:	f9 01       	movw	r30, r18
     114:	80 81       	ld	r24, Z
     116:	8f 5f       	subi	r24, 0xFF	; 255
     118:	80 83       	st	Z, r24
}
     11a:	df 91       	pop	r29
     11c:	cf 91       	pop	r28
     11e:	08 95       	ret

00000120 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     120:	cf 93       	push	r28
     122:	df 93       	push	r29
     124:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     126:	48 81       	ld	r20, Y
     128:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     12a:	4f 3f       	cpi	r20, 0xFF	; 255
     12c:	2f ef       	ldi	r18, 0xFF	; 255
     12e:	52 07       	cpc	r21, r18
     130:	21 f4       	brne	.+8      	; 0x13a <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     132:	fc 01       	movw	r30, r24
     134:	a7 81       	ldd	r26, Z+7	; 0x07
     136:	b0 85       	ldd	r27, Z+8	; 0x08
     138:	0d c0       	rjmp	.+26     	; 0x154 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     13a:	dc 01       	movw	r26, r24
     13c:	13 96       	adiw	r26, 0x03	; 3
     13e:	01 c0       	rjmp	.+2      	; 0x142 <vListInsert+0x22>
     140:	df 01       	movw	r26, r30
     142:	12 96       	adiw	r26, 0x02	; 2
     144:	ed 91       	ld	r30, X+
     146:	fc 91       	ld	r31, X
     148:	13 97       	sbiw	r26, 0x03	; 3
     14a:	20 81       	ld	r18, Z
     14c:	31 81       	ldd	r19, Z+1	; 0x01
     14e:	42 17       	cp	r20, r18
     150:	53 07       	cpc	r21, r19
     152:	b0 f7       	brcc	.-20     	; 0x140 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     154:	12 96       	adiw	r26, 0x02	; 2
     156:	ed 91       	ld	r30, X+
     158:	fc 91       	ld	r31, X
     15a:	13 97       	sbiw	r26, 0x03	; 3
     15c:	fb 83       	std	Y+3, r31	; 0x03
     15e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     160:	d5 83       	std	Z+5, r29	; 0x05
     162:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     164:	bd 83       	std	Y+5, r27	; 0x05
     166:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     168:	13 96       	adiw	r26, 0x03	; 3
     16a:	dc 93       	st	X, r29
     16c:	ce 93       	st	-X, r28
     16e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     170:	99 87       	std	Y+9, r25	; 0x09
     172:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     174:	fc 01       	movw	r30, r24
     176:	20 81       	ld	r18, Z
     178:	2f 5f       	subi	r18, 0xFF	; 255
     17a:	20 83       	st	Z, r18
}
     17c:	df 91       	pop	r29
     17e:	cf 91       	pop	r28
     180:	08 95       	ret

00000182 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     182:	cf 93       	push	r28
     184:	df 93       	push	r29
     186:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     188:	a0 85       	ldd	r26, Z+8	; 0x08
     18a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     18c:	c2 81       	ldd	r28, Z+2	; 0x02
     18e:	d3 81       	ldd	r29, Z+3	; 0x03
     190:	84 81       	ldd	r24, Z+4	; 0x04
     192:	95 81       	ldd	r25, Z+5	; 0x05
     194:	9d 83       	std	Y+5, r25	; 0x05
     196:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     198:	c4 81       	ldd	r28, Z+4	; 0x04
     19a:	d5 81       	ldd	r29, Z+5	; 0x05
     19c:	82 81       	ldd	r24, Z+2	; 0x02
     19e:	93 81       	ldd	r25, Z+3	; 0x03
     1a0:	9b 83       	std	Y+3, r25	; 0x03
     1a2:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     1a4:	11 96       	adiw	r26, 0x01	; 1
     1a6:	8d 91       	ld	r24, X+
     1a8:	9c 91       	ld	r25, X
     1aa:	12 97       	sbiw	r26, 0x02	; 2
     1ac:	e8 17       	cp	r30, r24
     1ae:	f9 07       	cpc	r31, r25
     1b0:	31 f4       	brne	.+12     	; 0x1be <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     1b2:	84 81       	ldd	r24, Z+4	; 0x04
     1b4:	95 81       	ldd	r25, Z+5	; 0x05
     1b6:	12 96       	adiw	r26, 0x02	; 2
     1b8:	9c 93       	st	X, r25
     1ba:	8e 93       	st	-X, r24
     1bc:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     1be:	11 86       	std	Z+9, r1	; 0x09
     1c0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     1c2:	8c 91       	ld	r24, X
     1c4:	81 50       	subi	r24, 0x01	; 1
     1c6:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     1c8:	df 91       	pop	r29
     1ca:	cf 91       	pop	r28
     1cc:	08 95       	ret

000001ce <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     1ce:	cf 93       	push	r28
     1d0:	df 93       	push	r29
     1d2:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     1d4:	0e 94 55 07 	call	0xeaa	; 0xeaa <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     1d8:	80 91 ae 01 	lds	r24, 0x01AE	; 0x8001ae <__data_end>
     1dc:	90 91 af 01 	lds	r25, 0x01AF	; 0x8001af <__data_end+0x1>
     1e0:	89 2b       	or	r24, r25
     1e2:	31 f4       	brne	.+12     	; 0x1f0 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     1e4:	83 eb       	ldi	r24, 0xB3	; 179
     1e6:	91 e0       	ldi	r25, 0x01	; 1
     1e8:	90 93 af 01 	sts	0x01AF, r25	; 0x8001af <__data_end+0x1>
     1ec:	80 93 ae 01 	sts	0x01AE, r24	; 0x8001ae <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     1f0:	20 91 b0 01 	lds	r18, 0x01B0	; 0x8001b0 <xNextFreeByte>
     1f4:	30 91 b1 01 	lds	r19, 0x01B1	; 0x8001b1 <xNextFreeByte+0x1>
     1f8:	c9 01       	movw	r24, r18
     1fa:	8c 0f       	add	r24, r28
     1fc:	9d 1f       	adc	r25, r29
     1fe:	8b 3d       	cpi	r24, 0xDB	; 219
     200:	45 e0       	ldi	r20, 0x05	; 5
     202:	94 07       	cpc	r25, r20
     204:	70 f4       	brcc	.+28     	; 0x222 <pvPortMalloc+0x54>
     206:	28 17       	cp	r18, r24
     208:	39 07       	cpc	r19, r25
     20a:	70 f4       	brcc	.+28     	; 0x228 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     20c:	c0 91 ae 01 	lds	r28, 0x01AE	; 0x8001ae <__data_end>
     210:	d0 91 af 01 	lds	r29, 0x01AF	; 0x8001af <__data_end+0x1>
     214:	c2 0f       	add	r28, r18
     216:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     218:	90 93 b1 01 	sts	0x01B1, r25	; 0x8001b1 <xNextFreeByte+0x1>
     21c:	80 93 b0 01 	sts	0x01B0, r24	; 0x8001b0 <xNextFreeByte>
     220:	05 c0       	rjmp	.+10     	; 0x22c <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     222:	c0 e0       	ldi	r28, 0x00	; 0
     224:	d0 e0       	ldi	r29, 0x00	; 0
     226:	02 c0       	rjmp	.+4      	; 0x22c <pvPortMalloc+0x5e>
     228:	c0 e0       	ldi	r28, 0x00	; 0
     22a:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     22c:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     230:	ce 01       	movw	r24, r28
     232:	df 91       	pop	r29
     234:	cf 91       	pop	r28
     236:	08 95       	ret

00000238 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     238:	08 95       	ret

0000023a <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     23a:	31 e1       	ldi	r19, 0x11	; 17
     23c:	fc 01       	movw	r30, r24
     23e:	30 83       	st	Z, r19
     240:	31 97       	sbiw	r30, 0x01	; 1
     242:	22 e2       	ldi	r18, 0x22	; 34
     244:	20 83       	st	Z, r18
     246:	31 97       	sbiw	r30, 0x01	; 1
     248:	a3 e3       	ldi	r26, 0x33	; 51
     24a:	a0 83       	st	Z, r26
     24c:	31 97       	sbiw	r30, 0x01	; 1
     24e:	60 83       	st	Z, r22
     250:	31 97       	sbiw	r30, 0x01	; 1
     252:	70 83       	st	Z, r23
     254:	31 97       	sbiw	r30, 0x01	; 1
     256:	10 82       	st	Z, r1
     258:	31 97       	sbiw	r30, 0x01	; 1
     25a:	60 e8       	ldi	r22, 0x80	; 128
     25c:	60 83       	st	Z, r22
     25e:	31 97       	sbiw	r30, 0x01	; 1
     260:	10 82       	st	Z, r1
     262:	31 97       	sbiw	r30, 0x01	; 1
     264:	62 e0       	ldi	r22, 0x02	; 2
     266:	60 83       	st	Z, r22
     268:	31 97       	sbiw	r30, 0x01	; 1
     26a:	63 e0       	ldi	r22, 0x03	; 3
     26c:	60 83       	st	Z, r22
     26e:	31 97       	sbiw	r30, 0x01	; 1
     270:	64 e0       	ldi	r22, 0x04	; 4
     272:	60 83       	st	Z, r22
     274:	31 97       	sbiw	r30, 0x01	; 1
     276:	65 e0       	ldi	r22, 0x05	; 5
     278:	60 83       	st	Z, r22
     27a:	31 97       	sbiw	r30, 0x01	; 1
     27c:	66 e0       	ldi	r22, 0x06	; 6
     27e:	60 83       	st	Z, r22
     280:	31 97       	sbiw	r30, 0x01	; 1
     282:	67 e0       	ldi	r22, 0x07	; 7
     284:	60 83       	st	Z, r22
     286:	31 97       	sbiw	r30, 0x01	; 1
     288:	68 e0       	ldi	r22, 0x08	; 8
     28a:	60 83       	st	Z, r22
     28c:	31 97       	sbiw	r30, 0x01	; 1
     28e:	69 e0       	ldi	r22, 0x09	; 9
     290:	60 83       	st	Z, r22
     292:	31 97       	sbiw	r30, 0x01	; 1
     294:	60 e1       	ldi	r22, 0x10	; 16
     296:	60 83       	st	Z, r22
     298:	31 97       	sbiw	r30, 0x01	; 1
     29a:	30 83       	st	Z, r19
     29c:	31 97       	sbiw	r30, 0x01	; 1
     29e:	32 e1       	ldi	r19, 0x12	; 18
     2a0:	30 83       	st	Z, r19
     2a2:	31 97       	sbiw	r30, 0x01	; 1
     2a4:	33 e1       	ldi	r19, 0x13	; 19
     2a6:	30 83       	st	Z, r19
     2a8:	31 97       	sbiw	r30, 0x01	; 1
     2aa:	34 e1       	ldi	r19, 0x14	; 20
     2ac:	30 83       	st	Z, r19
     2ae:	31 97       	sbiw	r30, 0x01	; 1
     2b0:	35 e1       	ldi	r19, 0x15	; 21
     2b2:	30 83       	st	Z, r19
     2b4:	31 97       	sbiw	r30, 0x01	; 1
     2b6:	36 e1       	ldi	r19, 0x16	; 22
     2b8:	30 83       	st	Z, r19
     2ba:	31 97       	sbiw	r30, 0x01	; 1
     2bc:	37 e1       	ldi	r19, 0x17	; 23
     2be:	30 83       	st	Z, r19
     2c0:	31 97       	sbiw	r30, 0x01	; 1
     2c2:	38 e1       	ldi	r19, 0x18	; 24
     2c4:	30 83       	st	Z, r19
     2c6:	31 97       	sbiw	r30, 0x01	; 1
     2c8:	39 e1       	ldi	r19, 0x19	; 25
     2ca:	30 83       	st	Z, r19
     2cc:	31 97       	sbiw	r30, 0x01	; 1
     2ce:	30 e2       	ldi	r19, 0x20	; 32
     2d0:	30 83       	st	Z, r19
     2d2:	31 97       	sbiw	r30, 0x01	; 1
     2d4:	31 e2       	ldi	r19, 0x21	; 33
     2d6:	30 83       	st	Z, r19
     2d8:	31 97       	sbiw	r30, 0x01	; 1
     2da:	20 83       	st	Z, r18
     2dc:	31 97       	sbiw	r30, 0x01	; 1
     2de:	23 e2       	ldi	r18, 0x23	; 35
     2e0:	20 83       	st	Z, r18
     2e2:	31 97       	sbiw	r30, 0x01	; 1
     2e4:	40 83       	st	Z, r20
     2e6:	31 97       	sbiw	r30, 0x01	; 1
     2e8:	50 83       	st	Z, r21
     2ea:	31 97       	sbiw	r30, 0x01	; 1
     2ec:	26 e2       	ldi	r18, 0x26	; 38
     2ee:	20 83       	st	Z, r18
     2f0:	31 97       	sbiw	r30, 0x01	; 1
     2f2:	27 e2       	ldi	r18, 0x27	; 39
     2f4:	20 83       	st	Z, r18
     2f6:	31 97       	sbiw	r30, 0x01	; 1
     2f8:	28 e2       	ldi	r18, 0x28	; 40
     2fa:	20 83       	st	Z, r18
     2fc:	31 97       	sbiw	r30, 0x01	; 1
     2fe:	29 e2       	ldi	r18, 0x29	; 41
     300:	20 83       	st	Z, r18
     302:	31 97       	sbiw	r30, 0x01	; 1
     304:	20 e3       	ldi	r18, 0x30	; 48
     306:	20 83       	st	Z, r18
     308:	31 97       	sbiw	r30, 0x01	; 1
     30a:	21 e3       	ldi	r18, 0x31	; 49
     30c:	20 83       	st	Z, r18
     30e:	86 97       	sbiw	r24, 0x26	; 38
     310:	08 95       	ret

00000312 <xPortStartScheduler>:
     312:	89 ef       	ldi	r24, 0xF9	; 249
     314:	90 e0       	ldi	r25, 0x00	; 0
     316:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
     31a:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
     31e:	e0 e8       	ldi	r30, 0x80	; 128
     320:	f0 e0       	ldi	r31, 0x00	; 0
     322:	80 81       	ld	r24, Z
     324:	8c 7f       	andi	r24, 0xFC	; 252
     326:	80 83       	st	Z, r24
     328:	8b e0       	ldi	r24, 0x0B	; 11
     32a:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
     32e:	ef e6       	ldi	r30, 0x6F	; 111
     330:	f0 e0       	ldi	r31, 0x00	; 0
     332:	80 81       	ld	r24, Z
     334:	82 60       	ori	r24, 0x02	; 2
     336:	80 83       	st	Z, r24
     338:	a0 91 f2 07 	lds	r26, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     33c:	b0 91 f3 07 	lds	r27, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     340:	cd 91       	ld	r28, X+
     342:	cd bf       	out	0x3d, r28	; 61
     344:	dd 91       	ld	r29, X+
     346:	de bf       	out	0x3e, r29	; 62
     348:	ff 91       	pop	r31
     34a:	ef 91       	pop	r30
     34c:	df 91       	pop	r29
     34e:	cf 91       	pop	r28
     350:	bf 91       	pop	r27
     352:	af 91       	pop	r26
     354:	9f 91       	pop	r25
     356:	8f 91       	pop	r24
     358:	7f 91       	pop	r23
     35a:	6f 91       	pop	r22
     35c:	5f 91       	pop	r21
     35e:	4f 91       	pop	r20
     360:	3f 91       	pop	r19
     362:	2f 91       	pop	r18
     364:	1f 91       	pop	r17
     366:	0f 91       	pop	r16
     368:	ff 90       	pop	r15
     36a:	ef 90       	pop	r14
     36c:	df 90       	pop	r13
     36e:	cf 90       	pop	r12
     370:	bf 90       	pop	r11
     372:	af 90       	pop	r10
     374:	9f 90       	pop	r9
     376:	8f 90       	pop	r8
     378:	7f 90       	pop	r7
     37a:	6f 90       	pop	r6
     37c:	5f 90       	pop	r5
     37e:	4f 90       	pop	r4
     380:	3f 90       	pop	r3
     382:	2f 90       	pop	r2
     384:	1f 90       	pop	r1
     386:	0f 90       	pop	r0
     388:	0f be       	out	0x3f, r0	; 63
     38a:	0f 90       	pop	r0
     38c:	08 95       	ret
     38e:	81 e0       	ldi	r24, 0x01	; 1
     390:	08 95       	ret

00000392 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     392:	0f 92       	push	r0
     394:	0f b6       	in	r0, 0x3f	; 63
     396:	f8 94       	cli
     398:	0f 92       	push	r0
     39a:	1f 92       	push	r1
     39c:	11 24       	eor	r1, r1
     39e:	2f 92       	push	r2
     3a0:	3f 92       	push	r3
     3a2:	4f 92       	push	r4
     3a4:	5f 92       	push	r5
     3a6:	6f 92       	push	r6
     3a8:	7f 92       	push	r7
     3aa:	8f 92       	push	r8
     3ac:	9f 92       	push	r9
     3ae:	af 92       	push	r10
     3b0:	bf 92       	push	r11
     3b2:	cf 92       	push	r12
     3b4:	df 92       	push	r13
     3b6:	ef 92       	push	r14
     3b8:	ff 92       	push	r15
     3ba:	0f 93       	push	r16
     3bc:	1f 93       	push	r17
     3be:	2f 93       	push	r18
     3c0:	3f 93       	push	r19
     3c2:	4f 93       	push	r20
     3c4:	5f 93       	push	r21
     3c6:	6f 93       	push	r22
     3c8:	7f 93       	push	r23
     3ca:	8f 93       	push	r24
     3cc:	9f 93       	push	r25
     3ce:	af 93       	push	r26
     3d0:	bf 93       	push	r27
     3d2:	cf 93       	push	r28
     3d4:	df 93       	push	r29
     3d6:	ef 93       	push	r30
     3d8:	ff 93       	push	r31
     3da:	a0 91 f2 07 	lds	r26, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     3de:	b0 91 f3 07 	lds	r27, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     3e2:	0d b6       	in	r0, 0x3d	; 61
     3e4:	0d 92       	st	X+, r0
     3e6:	0e b6       	in	r0, 0x3e	; 62
     3e8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     3ea:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     3ee:	a0 91 f2 07 	lds	r26, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     3f2:	b0 91 f3 07 	lds	r27, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     3f6:	cd 91       	ld	r28, X+
     3f8:	cd bf       	out	0x3d, r28	; 61
     3fa:	dd 91       	ld	r29, X+
     3fc:	de bf       	out	0x3e, r29	; 62
     3fe:	ff 91       	pop	r31
     400:	ef 91       	pop	r30
     402:	df 91       	pop	r29
     404:	cf 91       	pop	r28
     406:	bf 91       	pop	r27
     408:	af 91       	pop	r26
     40a:	9f 91       	pop	r25
     40c:	8f 91       	pop	r24
     40e:	7f 91       	pop	r23
     410:	6f 91       	pop	r22
     412:	5f 91       	pop	r21
     414:	4f 91       	pop	r20
     416:	3f 91       	pop	r19
     418:	2f 91       	pop	r18
     41a:	1f 91       	pop	r17
     41c:	0f 91       	pop	r16
     41e:	ff 90       	pop	r15
     420:	ef 90       	pop	r14
     422:	df 90       	pop	r13
     424:	cf 90       	pop	r12
     426:	bf 90       	pop	r11
     428:	af 90       	pop	r10
     42a:	9f 90       	pop	r9
     42c:	8f 90       	pop	r8
     42e:	7f 90       	pop	r7
     430:	6f 90       	pop	r6
     432:	5f 90       	pop	r5
     434:	4f 90       	pop	r4
     436:	3f 90       	pop	r3
     438:	2f 90       	pop	r2
     43a:	1f 90       	pop	r1
     43c:	0f 90       	pop	r0
     43e:	0f be       	out	0x3f, r0	; 63
     440:	0f 90       	pop	r0

	asm volatile ( "ret" );
     442:	08 95       	ret

00000444 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     444:	0f 92       	push	r0
     446:	0f b6       	in	r0, 0x3f	; 63
     448:	f8 94       	cli
     44a:	0f 92       	push	r0
     44c:	1f 92       	push	r1
     44e:	11 24       	eor	r1, r1
     450:	2f 92       	push	r2
     452:	3f 92       	push	r3
     454:	4f 92       	push	r4
     456:	5f 92       	push	r5
     458:	6f 92       	push	r6
     45a:	7f 92       	push	r7
     45c:	8f 92       	push	r8
     45e:	9f 92       	push	r9
     460:	af 92       	push	r10
     462:	bf 92       	push	r11
     464:	cf 92       	push	r12
     466:	df 92       	push	r13
     468:	ef 92       	push	r14
     46a:	ff 92       	push	r15
     46c:	0f 93       	push	r16
     46e:	1f 93       	push	r17
     470:	2f 93       	push	r18
     472:	3f 93       	push	r19
     474:	4f 93       	push	r20
     476:	5f 93       	push	r21
     478:	6f 93       	push	r22
     47a:	7f 93       	push	r23
     47c:	8f 93       	push	r24
     47e:	9f 93       	push	r25
     480:	af 93       	push	r26
     482:	bf 93       	push	r27
     484:	cf 93       	push	r28
     486:	df 93       	push	r29
     488:	ef 93       	push	r30
     48a:	ff 93       	push	r31
     48c:	a0 91 f2 07 	lds	r26, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     490:	b0 91 f3 07 	lds	r27, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     494:	0d b6       	in	r0, 0x3d	; 61
     496:	0d 92       	st	X+, r0
     498:	0e b6       	in	r0, 0x3e	; 62
     49a:	0d 92       	st	X+, r0
	xTaskIncrementTick();
     49c:	0e 94 65 07 	call	0xeca	; 0xeca <xTaskIncrementTick>
	vTaskSwitchContext();
     4a0:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     4a4:	a0 91 f2 07 	lds	r26, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     4a8:	b0 91 f3 07 	lds	r27, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     4ac:	cd 91       	ld	r28, X+
     4ae:	cd bf       	out	0x3d, r28	; 61
     4b0:	dd 91       	ld	r29, X+
     4b2:	de bf       	out	0x3e, r29	; 62
     4b4:	ff 91       	pop	r31
     4b6:	ef 91       	pop	r30
     4b8:	df 91       	pop	r29
     4ba:	cf 91       	pop	r28
     4bc:	bf 91       	pop	r27
     4be:	af 91       	pop	r26
     4c0:	9f 91       	pop	r25
     4c2:	8f 91       	pop	r24
     4c4:	7f 91       	pop	r23
     4c6:	6f 91       	pop	r22
     4c8:	5f 91       	pop	r21
     4ca:	4f 91       	pop	r20
     4cc:	3f 91       	pop	r19
     4ce:	2f 91       	pop	r18
     4d0:	1f 91       	pop	r17
     4d2:	0f 91       	pop	r16
     4d4:	ff 90       	pop	r15
     4d6:	ef 90       	pop	r14
     4d8:	df 90       	pop	r13
     4da:	cf 90       	pop	r12
     4dc:	bf 90       	pop	r11
     4de:	af 90       	pop	r10
     4e0:	9f 90       	pop	r9
     4e2:	8f 90       	pop	r8
     4e4:	7f 90       	pop	r7
     4e6:	6f 90       	pop	r6
     4e8:	5f 90       	pop	r5
     4ea:	4f 90       	pop	r4
     4ec:	3f 90       	pop	r3
     4ee:	2f 90       	pop	r2
     4f0:	1f 90       	pop	r1
     4f2:	0f 90       	pop	r0
     4f4:	0f be       	out	0x3f, r0	; 63
     4f6:	0f 90       	pop	r0

	asm volatile ( "ret" );
     4f8:	08 95       	ret

000004fa <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     4fa:	0e 94 22 02 	call	0x444	; 0x444 <vPortYieldFromTick>
		asm volatile ( "reti" );
     4fe:	18 95       	reti

00000500 <prvCopyDataToQueue>:
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
     500:	0f 93       	push	r16
     502:	1f 93       	push	r17
     504:	cf 93       	push	r28
     506:	df 93       	push	r29
     508:	ec 01       	movw	r28, r24
     50a:	04 2f       	mov	r16, r20
     50c:	1a 8d       	ldd	r17, Y+26	; 0x1a
     50e:	4c 8d       	ldd	r20, Y+28	; 0x1c
     510:	44 23       	and	r20, r20
     512:	b9 f1       	breq	.+110    	; 0x582 <prvCopyDataToQueue+0x82>
     514:	01 11       	cpse	r16, r1
     516:	16 c0       	rjmp	.+44     	; 0x544 <prvCopyDataToQueue+0x44>
     518:	50 e0       	ldi	r21, 0x00	; 0
     51a:	8c 81       	ldd	r24, Y+4	; 0x04
     51c:	9d 81       	ldd	r25, Y+5	; 0x05
     51e:	0e 94 94 15 	call	0x2b28	; 0x2b28 <memcpy>
     522:	2c 8d       	ldd	r18, Y+28	; 0x1c
     524:	8c 81       	ldd	r24, Y+4	; 0x04
     526:	9d 81       	ldd	r25, Y+5	; 0x05
     528:	82 0f       	add	r24, r18
     52a:	91 1d       	adc	r25, r1
     52c:	9d 83       	std	Y+5, r25	; 0x05
     52e:	8c 83       	std	Y+4, r24	; 0x04
     530:	2a 81       	ldd	r18, Y+2	; 0x02
     532:	3b 81       	ldd	r19, Y+3	; 0x03
     534:	82 17       	cp	r24, r18
     536:	93 07       	cpc	r25, r19
     538:	20 f1       	brcs	.+72     	; 0x582 <prvCopyDataToQueue+0x82>
     53a:	88 81       	ld	r24, Y
     53c:	99 81       	ldd	r25, Y+1	; 0x01
     53e:	9d 83       	std	Y+5, r25	; 0x05
     540:	8c 83       	std	Y+4, r24	; 0x04
     542:	1f c0       	rjmp	.+62     	; 0x582 <prvCopyDataToQueue+0x82>
     544:	50 e0       	ldi	r21, 0x00	; 0
     546:	8e 81       	ldd	r24, Y+6	; 0x06
     548:	9f 81       	ldd	r25, Y+7	; 0x07
     54a:	0e 94 94 15 	call	0x2b28	; 0x2b28 <memcpy>
     54e:	8c 8d       	ldd	r24, Y+28	; 0x1c
     550:	90 e0       	ldi	r25, 0x00	; 0
     552:	91 95       	neg	r25
     554:	81 95       	neg	r24
     556:	91 09       	sbc	r25, r1
     558:	2e 81       	ldd	r18, Y+6	; 0x06
     55a:	3f 81       	ldd	r19, Y+7	; 0x07
     55c:	28 0f       	add	r18, r24
     55e:	39 1f       	adc	r19, r25
     560:	3f 83       	std	Y+7, r19	; 0x07
     562:	2e 83       	std	Y+6, r18	; 0x06
     564:	48 81       	ld	r20, Y
     566:	59 81       	ldd	r21, Y+1	; 0x01
     568:	24 17       	cp	r18, r20
     56a:	35 07       	cpc	r19, r21
     56c:	30 f4       	brcc	.+12     	; 0x57a <prvCopyDataToQueue+0x7a>
     56e:	2a 81       	ldd	r18, Y+2	; 0x02
     570:	3b 81       	ldd	r19, Y+3	; 0x03
     572:	82 0f       	add	r24, r18
     574:	93 1f       	adc	r25, r19
     576:	9f 83       	std	Y+7, r25	; 0x07
     578:	8e 83       	std	Y+6, r24	; 0x06
     57a:	02 30       	cpi	r16, 0x02	; 2
     57c:	11 f4       	brne	.+4      	; 0x582 <prvCopyDataToQueue+0x82>
     57e:	11 11       	cpse	r17, r1
     580:	11 50       	subi	r17, 0x01	; 1
     582:	1f 5f       	subi	r17, 0xFF	; 255
     584:	1a 8f       	std	Y+26, r17	; 0x1a
     586:	80 e0       	ldi	r24, 0x00	; 0
     588:	df 91       	pop	r29
     58a:	cf 91       	pop	r28
     58c:	1f 91       	pop	r17
     58e:	0f 91       	pop	r16
     590:	08 95       	ret

00000592 <prvCopyDataFromQueue>:
     592:	fc 01       	movw	r30, r24
     594:	44 8d       	ldd	r20, Z+28	; 0x1c
     596:	44 23       	and	r20, r20
     598:	a9 f0       	breq	.+42     	; 0x5c4 <prvCopyDataFromQueue+0x32>
     59a:	50 e0       	ldi	r21, 0x00	; 0
     59c:	26 81       	ldd	r18, Z+6	; 0x06
     59e:	37 81       	ldd	r19, Z+7	; 0x07
     5a0:	24 0f       	add	r18, r20
     5a2:	35 1f       	adc	r19, r21
     5a4:	37 83       	std	Z+7, r19	; 0x07
     5a6:	26 83       	std	Z+6, r18	; 0x06
     5a8:	82 81       	ldd	r24, Z+2	; 0x02
     5aa:	93 81       	ldd	r25, Z+3	; 0x03
     5ac:	28 17       	cp	r18, r24
     5ae:	39 07       	cpc	r19, r25
     5b0:	20 f0       	brcs	.+8      	; 0x5ba <prvCopyDataFromQueue+0x28>
     5b2:	80 81       	ld	r24, Z
     5b4:	91 81       	ldd	r25, Z+1	; 0x01
     5b6:	97 83       	std	Z+7, r25	; 0x07
     5b8:	86 83       	std	Z+6, r24	; 0x06
     5ba:	cb 01       	movw	r24, r22
     5bc:	66 81       	ldd	r22, Z+6	; 0x06
     5be:	77 81       	ldd	r23, Z+7	; 0x07
     5c0:	0e 94 94 15 	call	0x2b28	; 0x2b28 <memcpy>
     5c4:	08 95       	ret

000005c6 <prvUnlockQueue>:
     5c6:	ef 92       	push	r14
     5c8:	ff 92       	push	r15
     5ca:	0f 93       	push	r16
     5cc:	1f 93       	push	r17
     5ce:	cf 93       	push	r28
     5d0:	8c 01       	movw	r16, r24
     5d2:	0f b6       	in	r0, 0x3f	; 63
     5d4:	f8 94       	cli
     5d6:	0f 92       	push	r0
     5d8:	fc 01       	movw	r30, r24
     5da:	c6 8d       	ldd	r28, Z+30	; 0x1e
     5dc:	1c 16       	cp	r1, r28
     5de:	ac f4       	brge	.+42     	; 0x60a <prvUnlockQueue+0x44>
     5e0:	81 89       	ldd	r24, Z+17	; 0x11
     5e2:	81 11       	cpse	r24, r1
     5e4:	06 c0       	rjmp	.+12     	; 0x5f2 <prvUnlockQueue+0x2c>
     5e6:	11 c0       	rjmp	.+34     	; 0x60a <prvUnlockQueue+0x44>
     5e8:	f8 01       	movw	r30, r16
     5ea:	81 89       	ldd	r24, Z+17	; 0x11
     5ec:	81 11       	cpse	r24, r1
     5ee:	05 c0       	rjmp	.+10     	; 0x5fa <prvUnlockQueue+0x34>
     5f0:	0c c0       	rjmp	.+24     	; 0x60a <prvUnlockQueue+0x44>
     5f2:	78 01       	movw	r14, r16
     5f4:	f1 e1       	ldi	r31, 0x11	; 17
     5f6:	ef 0e       	add	r14, r31
     5f8:	f1 1c       	adc	r15, r1
     5fa:	c7 01       	movw	r24, r14
     5fc:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <xTaskRemoveFromEventList>
     600:	81 11       	cpse	r24, r1
     602:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <vTaskMissedYield>
     606:	c1 50       	subi	r28, 0x01	; 1
     608:	79 f7       	brne	.-34     	; 0x5e8 <prvUnlockQueue+0x22>
     60a:	8f ef       	ldi	r24, 0xFF	; 255
     60c:	f8 01       	movw	r30, r16
     60e:	86 8f       	std	Z+30, r24	; 0x1e
     610:	0f 90       	pop	r0
     612:	0f be       	out	0x3f, r0	; 63
     614:	0f b6       	in	r0, 0x3f	; 63
     616:	f8 94       	cli
     618:	0f 92       	push	r0
     61a:	c5 8d       	ldd	r28, Z+29	; 0x1d
     61c:	1c 16       	cp	r1, r28
     61e:	ac f4       	brge	.+42     	; 0x64a <prvUnlockQueue+0x84>
     620:	80 85       	ldd	r24, Z+8	; 0x08
     622:	81 11       	cpse	r24, r1
     624:	06 c0       	rjmp	.+12     	; 0x632 <prvUnlockQueue+0x6c>
     626:	11 c0       	rjmp	.+34     	; 0x64a <prvUnlockQueue+0x84>
     628:	f8 01       	movw	r30, r16
     62a:	80 85       	ldd	r24, Z+8	; 0x08
     62c:	81 11       	cpse	r24, r1
     62e:	05 c0       	rjmp	.+10     	; 0x63a <prvUnlockQueue+0x74>
     630:	0c c0       	rjmp	.+24     	; 0x64a <prvUnlockQueue+0x84>
     632:	78 01       	movw	r14, r16
     634:	f8 e0       	ldi	r31, 0x08	; 8
     636:	ef 0e       	add	r14, r31
     638:	f1 1c       	adc	r15, r1
     63a:	c7 01       	movw	r24, r14
     63c:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <xTaskRemoveFromEventList>
     640:	81 11       	cpse	r24, r1
     642:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <vTaskMissedYield>
     646:	c1 50       	subi	r28, 0x01	; 1
     648:	79 f7       	brne	.-34     	; 0x628 <prvUnlockQueue+0x62>
     64a:	8f ef       	ldi	r24, 0xFF	; 255
     64c:	f8 01       	movw	r30, r16
     64e:	85 8f       	std	Z+29, r24	; 0x1d
     650:	0f 90       	pop	r0
     652:	0f be       	out	0x3f, r0	; 63
     654:	cf 91       	pop	r28
     656:	1f 91       	pop	r17
     658:	0f 91       	pop	r16
     65a:	ff 90       	pop	r15
     65c:	ef 90       	pop	r14
     65e:	08 95       	ret

00000660 <xQueueGenericReset>:
     660:	cf 93       	push	r28
     662:	df 93       	push	r29
     664:	ec 01       	movw	r28, r24
     666:	0f b6       	in	r0, 0x3f	; 63
     668:	f8 94       	cli
     66a:	0f 92       	push	r0
     66c:	48 81       	ld	r20, Y
     66e:	59 81       	ldd	r21, Y+1	; 0x01
     670:	2c 8d       	ldd	r18, Y+28	; 0x1c
     672:	30 e0       	ldi	r19, 0x00	; 0
     674:	7b 8d       	ldd	r23, Y+27	; 0x1b
     676:	72 9f       	mul	r23, r18
     678:	c0 01       	movw	r24, r0
     67a:	73 9f       	mul	r23, r19
     67c:	90 0d       	add	r25, r0
     67e:	11 24       	eor	r1, r1
     680:	fa 01       	movw	r30, r20
     682:	e8 0f       	add	r30, r24
     684:	f9 1f       	adc	r31, r25
     686:	fb 83       	std	Y+3, r31	; 0x03
     688:	ea 83       	std	Y+2, r30	; 0x02
     68a:	1a 8e       	std	Y+26, r1	; 0x1a
     68c:	5d 83       	std	Y+5, r21	; 0x05
     68e:	4c 83       	std	Y+4, r20	; 0x04
     690:	82 1b       	sub	r24, r18
     692:	93 0b       	sbc	r25, r19
     694:	84 0f       	add	r24, r20
     696:	95 1f       	adc	r25, r21
     698:	9f 83       	std	Y+7, r25	; 0x07
     69a:	8e 83       	std	Y+6, r24	; 0x06
     69c:	8f ef       	ldi	r24, 0xFF	; 255
     69e:	8d 8f       	std	Y+29, r24	; 0x1d
     6a0:	8e 8f       	std	Y+30, r24	; 0x1e
     6a2:	61 11       	cpse	r22, r1
     6a4:	0c c0       	rjmp	.+24     	; 0x6be <xQueueGenericReset+0x5e>
     6a6:	88 85       	ldd	r24, Y+8	; 0x08
     6a8:	88 23       	and	r24, r24
     6aa:	89 f0       	breq	.+34     	; 0x6ce <xQueueGenericReset+0x6e>
     6ac:	ce 01       	movw	r24, r28
     6ae:	08 96       	adiw	r24, 0x08	; 8
     6b0:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <xTaskRemoveFromEventList>
     6b4:	88 23       	and	r24, r24
     6b6:	59 f0       	breq	.+22     	; 0x6ce <xQueueGenericReset+0x6e>
     6b8:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     6bc:	08 c0       	rjmp	.+16     	; 0x6ce <xQueueGenericReset+0x6e>
     6be:	ce 01       	movw	r24, r28
     6c0:	08 96       	adiw	r24, 0x08	; 8
     6c2:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     6c6:	ce 01       	movw	r24, r28
     6c8:	41 96       	adiw	r24, 0x11	; 17
     6ca:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     6ce:	0f 90       	pop	r0
     6d0:	0f be       	out	0x3f, r0	; 63
     6d2:	81 e0       	ldi	r24, 0x01	; 1
     6d4:	df 91       	pop	r29
     6d6:	cf 91       	pop	r28
     6d8:	08 95       	ret

000006da <xQueueGenericCreate>:
     6da:	0f 93       	push	r16
     6dc:	1f 93       	push	r17
     6de:	cf 93       	push	r28
     6e0:	df 93       	push	r29
     6e2:	08 2f       	mov	r16, r24
     6e4:	16 2f       	mov	r17, r22
     6e6:	66 23       	and	r22, r22
     6e8:	c1 f0       	breq	.+48     	; 0x71a <xQueueGenericCreate+0x40>
     6ea:	86 9f       	mul	r24, r22
     6ec:	c0 01       	movw	r24, r0
     6ee:	11 24       	eor	r1, r1
     6f0:	4f 96       	adiw	r24, 0x1f	; 31
     6f2:	0e 94 e7 00 	call	0x1ce	; 0x1ce <pvPortMalloc>
     6f6:	ec 01       	movw	r28, r24
     6f8:	00 97       	sbiw	r24, 0x00	; 0
     6fa:	41 f4       	brne	.+16     	; 0x70c <xQueueGenericCreate+0x32>
     6fc:	15 c0       	rjmp	.+42     	; 0x728 <xQueueGenericCreate+0x4e>
     6fe:	0b 8f       	std	Y+27, r16	; 0x1b
     700:	1c 8f       	std	Y+28, r17	; 0x1c
     702:	61 e0       	ldi	r22, 0x01	; 1
     704:	ce 01       	movw	r24, r28
     706:	0e 94 30 03 	call	0x660	; 0x660 <xQueueGenericReset>
     70a:	0e c0       	rjmp	.+28     	; 0x728 <xQueueGenericCreate+0x4e>
     70c:	4f 96       	adiw	r24, 0x1f	; 31
     70e:	99 83       	std	Y+1, r25	; 0x01
     710:	88 83       	st	Y, r24
     712:	f5 cf       	rjmp	.-22     	; 0x6fe <xQueueGenericCreate+0x24>
     714:	d9 83       	std	Y+1, r29	; 0x01
     716:	c8 83       	st	Y, r28
     718:	f2 cf       	rjmp	.-28     	; 0x6fe <xQueueGenericCreate+0x24>
     71a:	8f e1       	ldi	r24, 0x1F	; 31
     71c:	90 e0       	ldi	r25, 0x00	; 0
     71e:	0e 94 e7 00 	call	0x1ce	; 0x1ce <pvPortMalloc>
     722:	ec 01       	movw	r28, r24
     724:	89 2b       	or	r24, r25
     726:	b1 f7       	brne	.-20     	; 0x714 <xQueueGenericCreate+0x3a>
     728:	ce 01       	movw	r24, r28
     72a:	df 91       	pop	r29
     72c:	cf 91       	pop	r28
     72e:	1f 91       	pop	r17
     730:	0f 91       	pop	r16
     732:	08 95       	ret

00000734 <xQueueGenericSend>:
     734:	9f 92       	push	r9
     736:	af 92       	push	r10
     738:	bf 92       	push	r11
     73a:	cf 92       	push	r12
     73c:	df 92       	push	r13
     73e:	ef 92       	push	r14
     740:	ff 92       	push	r15
     742:	0f 93       	push	r16
     744:	1f 93       	push	r17
     746:	cf 93       	push	r28
     748:	df 93       	push	r29
     74a:	00 d0       	rcall	.+0      	; 0x74c <xQueueGenericSend+0x18>
     74c:	00 d0       	rcall	.+0      	; 0x74e <xQueueGenericSend+0x1a>
     74e:	1f 92       	push	r1
     750:	cd b7       	in	r28, 0x3d	; 61
     752:	de b7       	in	r29, 0x3e	; 62
     754:	8c 01       	movw	r16, r24
     756:	6b 01       	movw	r12, r22
     758:	5d 83       	std	Y+5, r21	; 0x05
     75a:	4c 83       	std	Y+4, r20	; 0x04
     75c:	a2 2e       	mov	r10, r18
     75e:	b1 2c       	mov	r11, r1
     760:	99 24       	eor	r9, r9
     762:	93 94       	inc	r9
     764:	7c 01       	movw	r14, r24
     766:	88 e0       	ldi	r24, 0x08	; 8
     768:	e8 0e       	add	r14, r24
     76a:	f1 1c       	adc	r15, r1
     76c:	0f b6       	in	r0, 0x3f	; 63
     76e:	f8 94       	cli
     770:	0f 92       	push	r0
     772:	f8 01       	movw	r30, r16
     774:	92 8d       	ldd	r25, Z+26	; 0x1a
     776:	83 8d       	ldd	r24, Z+27	; 0x1b
     778:	98 17       	cp	r25, r24
     77a:	18 f0       	brcs	.+6      	; 0x782 <xQueueGenericSend+0x4e>
     77c:	f2 e0       	ldi	r31, 0x02	; 2
     77e:	af 12       	cpse	r10, r31
     780:	19 c0       	rjmp	.+50     	; 0x7b4 <xQueueGenericSend+0x80>
     782:	4a 2d       	mov	r20, r10
     784:	b6 01       	movw	r22, r12
     786:	c8 01       	movw	r24, r16
     788:	0e 94 80 02 	call	0x500	; 0x500 <prvCopyDataToQueue>
     78c:	f8 01       	movw	r30, r16
     78e:	91 89       	ldd	r25, Z+17	; 0x11
     790:	99 23       	and	r25, r25
     792:	49 f0       	breq	.+18     	; 0x7a6 <xQueueGenericSend+0x72>
     794:	c8 01       	movw	r24, r16
     796:	41 96       	adiw	r24, 0x11	; 17
     798:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <xTaskRemoveFromEventList>
     79c:	88 23       	and	r24, r24
     79e:	31 f0       	breq	.+12     	; 0x7ac <xQueueGenericSend+0x78>
     7a0:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     7a4:	03 c0       	rjmp	.+6      	; 0x7ac <xQueueGenericSend+0x78>
     7a6:	81 11       	cpse	r24, r1
     7a8:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     7ac:	0f 90       	pop	r0
     7ae:	0f be       	out	0x3f, r0	; 63
     7b0:	81 e0       	ldi	r24, 0x01	; 1
     7b2:	50 c0       	rjmp	.+160    	; 0x854 <xQueueGenericSend+0x120>
     7b4:	8c 81       	ldd	r24, Y+4	; 0x04
     7b6:	9d 81       	ldd	r25, Y+5	; 0x05
     7b8:	89 2b       	or	r24, r25
     7ba:	21 f4       	brne	.+8      	; 0x7c4 <xQueueGenericSend+0x90>
     7bc:	0f 90       	pop	r0
     7be:	0f be       	out	0x3f, r0	; 63
     7c0:	80 e0       	ldi	r24, 0x00	; 0
     7c2:	48 c0       	rjmp	.+144    	; 0x854 <xQueueGenericSend+0x120>
     7c4:	b1 10       	cpse	r11, r1
     7c6:	05 c0       	rjmp	.+10     	; 0x7d2 <xQueueGenericSend+0x9e>
     7c8:	ce 01       	movw	r24, r28
     7ca:	01 96       	adiw	r24, 0x01	; 1
     7cc:	0e 94 19 0a 	call	0x1432	; 0x1432 <vTaskSetTimeOutState>
     7d0:	b9 2c       	mov	r11, r9
     7d2:	0f 90       	pop	r0
     7d4:	0f be       	out	0x3f, r0	; 63
     7d6:	0e 94 55 07 	call	0xeaa	; 0xeaa <vTaskSuspendAll>
     7da:	0f b6       	in	r0, 0x3f	; 63
     7dc:	f8 94       	cli
     7de:	0f 92       	push	r0
     7e0:	f8 01       	movw	r30, r16
     7e2:	85 8d       	ldd	r24, Z+29	; 0x1d
     7e4:	8f 3f       	cpi	r24, 0xFF	; 255
     7e6:	09 f4       	brne	.+2      	; 0x7ea <xQueueGenericSend+0xb6>
     7e8:	15 8e       	std	Z+29, r1	; 0x1d
     7ea:	f8 01       	movw	r30, r16
     7ec:	86 8d       	ldd	r24, Z+30	; 0x1e
     7ee:	8f 3f       	cpi	r24, 0xFF	; 255
     7f0:	09 f4       	brne	.+2      	; 0x7f4 <xQueueGenericSend+0xc0>
     7f2:	16 8e       	std	Z+30, r1	; 0x1e
     7f4:	0f 90       	pop	r0
     7f6:	0f be       	out	0x3f, r0	; 63
     7f8:	be 01       	movw	r22, r28
     7fa:	6c 5f       	subi	r22, 0xFC	; 252
     7fc:	7f 4f       	sbci	r23, 0xFF	; 255
     7fe:	ce 01       	movw	r24, r28
     800:	01 96       	adiw	r24, 0x01	; 1
     802:	0e 94 24 0a 	call	0x1448	; 0x1448 <xTaskCheckForTimeOut>
     806:	81 11       	cpse	r24, r1
     808:	1f c0       	rjmp	.+62     	; 0x848 <xQueueGenericSend+0x114>
     80a:	0f b6       	in	r0, 0x3f	; 63
     80c:	f8 94       	cli
     80e:	0f 92       	push	r0
     810:	f8 01       	movw	r30, r16
     812:	92 8d       	ldd	r25, Z+26	; 0x1a
     814:	0f 90       	pop	r0
     816:	0f be       	out	0x3f, r0	; 63
     818:	83 8d       	ldd	r24, Z+27	; 0x1b
     81a:	98 13       	cpse	r25, r24
     81c:	0f c0       	rjmp	.+30     	; 0x83c <xQueueGenericSend+0x108>
     81e:	6c 81       	ldd	r22, Y+4	; 0x04
     820:	7d 81       	ldd	r23, Y+5	; 0x05
     822:	c7 01       	movw	r24, r14
     824:	0e 94 a6 09 	call	0x134c	; 0x134c <vTaskPlaceOnEventList>
     828:	c8 01       	movw	r24, r16
     82a:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <prvUnlockQueue>
     82e:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
     832:	81 11       	cpse	r24, r1
     834:	9b cf       	rjmp	.-202    	; 0x76c <xQueueGenericSend+0x38>
     836:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     83a:	98 cf       	rjmp	.-208    	; 0x76c <xQueueGenericSend+0x38>
     83c:	c8 01       	movw	r24, r16
     83e:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <prvUnlockQueue>
     842:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
     846:	92 cf       	rjmp	.-220    	; 0x76c <xQueueGenericSend+0x38>
     848:	c8 01       	movw	r24, r16
     84a:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <prvUnlockQueue>
     84e:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
     852:	80 e0       	ldi	r24, 0x00	; 0
     854:	0f 90       	pop	r0
     856:	0f 90       	pop	r0
     858:	0f 90       	pop	r0
     85a:	0f 90       	pop	r0
     85c:	0f 90       	pop	r0
     85e:	df 91       	pop	r29
     860:	cf 91       	pop	r28
     862:	1f 91       	pop	r17
     864:	0f 91       	pop	r16
     866:	ff 90       	pop	r15
     868:	ef 90       	pop	r14
     86a:	df 90       	pop	r13
     86c:	cf 90       	pop	r12
     86e:	bf 90       	pop	r11
     870:	af 90       	pop	r10
     872:	9f 90       	pop	r9
     874:	08 95       	ret

00000876 <xQueueGenericSendFromISR>:
     876:	ef 92       	push	r14
     878:	ff 92       	push	r15
     87a:	0f 93       	push	r16
     87c:	1f 93       	push	r17
     87e:	cf 93       	push	r28
     880:	df 93       	push	r29
     882:	8a 01       	movw	r16, r20
     884:	fc 01       	movw	r30, r24
     886:	52 8d       	ldd	r21, Z+26	; 0x1a
     888:	33 8d       	ldd	r19, Z+27	; 0x1b
     88a:	53 17       	cp	r21, r19
     88c:	10 f0       	brcs	.+4      	; 0x892 <xQueueGenericSendFromISR+0x1c>
     88e:	22 30       	cpi	r18, 0x02	; 2
     890:	f1 f4       	brne	.+60     	; 0x8ce <xQueueGenericSendFromISR+0x58>
     892:	42 2f       	mov	r20, r18
     894:	78 01       	movw	r14, r16
     896:	ec 01       	movw	r28, r24
     898:	1e 8d       	ldd	r17, Y+30	; 0x1e
     89a:	0e 94 80 02 	call	0x500	; 0x500 <prvCopyDataToQueue>
     89e:	1f 3f       	cpi	r17, 0xFF	; 255
     8a0:	81 f4       	brne	.+32     	; 0x8c2 <xQueueGenericSendFromISR+0x4c>
     8a2:	89 89       	ldd	r24, Y+17	; 0x11
     8a4:	88 23       	and	r24, r24
     8a6:	a9 f0       	breq	.+42     	; 0x8d2 <xQueueGenericSendFromISR+0x5c>
     8a8:	ce 01       	movw	r24, r28
     8aa:	41 96       	adiw	r24, 0x11	; 17
     8ac:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <xTaskRemoveFromEventList>
     8b0:	88 23       	and	r24, r24
     8b2:	89 f0       	breq	.+34     	; 0x8d6 <xQueueGenericSendFromISR+0x60>
     8b4:	e1 14       	cp	r14, r1
     8b6:	f1 04       	cpc	r15, r1
     8b8:	81 f0       	breq	.+32     	; 0x8da <xQueueGenericSendFromISR+0x64>
     8ba:	81 e0       	ldi	r24, 0x01	; 1
     8bc:	f7 01       	movw	r30, r14
     8be:	80 83       	st	Z, r24
     8c0:	0d c0       	rjmp	.+26     	; 0x8dc <xQueueGenericSendFromISR+0x66>
     8c2:	ff 24       	eor	r15, r15
     8c4:	f3 94       	inc	r15
     8c6:	f1 0e       	add	r15, r17
     8c8:	fe 8e       	std	Y+30, r15	; 0x1e
     8ca:	81 e0       	ldi	r24, 0x01	; 1
     8cc:	07 c0       	rjmp	.+14     	; 0x8dc <xQueueGenericSendFromISR+0x66>
     8ce:	80 e0       	ldi	r24, 0x00	; 0
     8d0:	05 c0       	rjmp	.+10     	; 0x8dc <xQueueGenericSendFromISR+0x66>
     8d2:	81 e0       	ldi	r24, 0x01	; 1
     8d4:	03 c0       	rjmp	.+6      	; 0x8dc <xQueueGenericSendFromISR+0x66>
     8d6:	81 e0       	ldi	r24, 0x01	; 1
     8d8:	01 c0       	rjmp	.+2      	; 0x8dc <xQueueGenericSendFromISR+0x66>
     8da:	81 e0       	ldi	r24, 0x01	; 1
     8dc:	df 91       	pop	r29
     8de:	cf 91       	pop	r28
     8e0:	1f 91       	pop	r17
     8e2:	0f 91       	pop	r16
     8e4:	ff 90       	pop	r15
     8e6:	ef 90       	pop	r14
     8e8:	08 95       	ret

000008ea <xQueueGenericReceive>:
     8ea:	8f 92       	push	r8
     8ec:	9f 92       	push	r9
     8ee:	af 92       	push	r10
     8f0:	bf 92       	push	r11
     8f2:	cf 92       	push	r12
     8f4:	df 92       	push	r13
     8f6:	ef 92       	push	r14
     8f8:	ff 92       	push	r15
     8fa:	0f 93       	push	r16
     8fc:	1f 93       	push	r17
     8fe:	cf 93       	push	r28
     900:	df 93       	push	r29
     902:	00 d0       	rcall	.+0      	; 0x904 <__stack+0x5>
     904:	00 d0       	rcall	.+0      	; 0x906 <__stack+0x7>
     906:	1f 92       	push	r1
     908:	cd b7       	in	r28, 0x3d	; 61
     90a:	de b7       	in	r29, 0x3e	; 62
     90c:	8c 01       	movw	r16, r24
     90e:	5b 01       	movw	r10, r22
     910:	5d 83       	std	Y+5, r21	; 0x05
     912:	4c 83       	std	Y+4, r20	; 0x04
     914:	82 2e       	mov	r8, r18
     916:	e1 2c       	mov	r14, r1
     918:	99 24       	eor	r9, r9
     91a:	93 94       	inc	r9
     91c:	6c 01       	movw	r12, r24
     91e:	81 e1       	ldi	r24, 0x11	; 17
     920:	c8 0e       	add	r12, r24
     922:	d1 1c       	adc	r13, r1
     924:	0f b6       	in	r0, 0x3f	; 63
     926:	f8 94       	cli
     928:	0f 92       	push	r0
     92a:	f8 01       	movw	r30, r16
     92c:	f2 8c       	ldd	r15, Z+26	; 0x1a
     92e:	ff 20       	and	r15, r15
     930:	41 f1       	breq	.+80     	; 0x982 <__stack+0x83>
     932:	c6 80       	ldd	r12, Z+6	; 0x06
     934:	d7 80       	ldd	r13, Z+7	; 0x07
     936:	b5 01       	movw	r22, r10
     938:	c8 01       	movw	r24, r16
     93a:	0e 94 c9 02 	call	0x592	; 0x592 <prvCopyDataFromQueue>
     93e:	81 10       	cpse	r8, r1
     940:	0f c0       	rjmp	.+30     	; 0x960 <__stack+0x61>
     942:	fa 94       	dec	r15
     944:	f8 01       	movw	r30, r16
     946:	f2 8e       	std	Z+26, r15	; 0x1a
     948:	80 85       	ldd	r24, Z+8	; 0x08
     94a:	88 23       	and	r24, r24
     94c:	b1 f0       	breq	.+44     	; 0x97a <__stack+0x7b>
     94e:	c8 01       	movw	r24, r16
     950:	08 96       	adiw	r24, 0x08	; 8
     952:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <xTaskRemoveFromEventList>
     956:	88 23       	and	r24, r24
     958:	81 f0       	breq	.+32     	; 0x97a <__stack+0x7b>
     95a:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     95e:	0d c0       	rjmp	.+26     	; 0x97a <__stack+0x7b>
     960:	f8 01       	movw	r30, r16
     962:	d7 82       	std	Z+7, r13	; 0x07
     964:	c6 82       	std	Z+6, r12	; 0x06
     966:	81 89       	ldd	r24, Z+17	; 0x11
     968:	88 23       	and	r24, r24
     96a:	39 f0       	breq	.+14     	; 0x97a <__stack+0x7b>
     96c:	c8 01       	movw	r24, r16
     96e:	41 96       	adiw	r24, 0x11	; 17
     970:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <xTaskRemoveFromEventList>
     974:	81 11       	cpse	r24, r1
     976:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     97a:	0f 90       	pop	r0
     97c:	0f be       	out	0x3f, r0	; 63
     97e:	81 e0       	ldi	r24, 0x01	; 1
     980:	57 c0       	rjmp	.+174    	; 0xa30 <__stack+0x131>
     982:	8c 81       	ldd	r24, Y+4	; 0x04
     984:	9d 81       	ldd	r25, Y+5	; 0x05
     986:	89 2b       	or	r24, r25
     988:	21 f4       	brne	.+8      	; 0x992 <__stack+0x93>
     98a:	0f 90       	pop	r0
     98c:	0f be       	out	0x3f, r0	; 63
     98e:	80 e0       	ldi	r24, 0x00	; 0
     990:	4f c0       	rjmp	.+158    	; 0xa30 <__stack+0x131>
     992:	e1 10       	cpse	r14, r1
     994:	05 c0       	rjmp	.+10     	; 0x9a0 <__stack+0xa1>
     996:	ce 01       	movw	r24, r28
     998:	01 96       	adiw	r24, 0x01	; 1
     99a:	0e 94 19 0a 	call	0x1432	; 0x1432 <vTaskSetTimeOutState>
     99e:	e9 2c       	mov	r14, r9
     9a0:	0f 90       	pop	r0
     9a2:	0f be       	out	0x3f, r0	; 63
     9a4:	0e 94 55 07 	call	0xeaa	; 0xeaa <vTaskSuspendAll>
     9a8:	0f b6       	in	r0, 0x3f	; 63
     9aa:	f8 94       	cli
     9ac:	0f 92       	push	r0
     9ae:	f8 01       	movw	r30, r16
     9b0:	85 8d       	ldd	r24, Z+29	; 0x1d
     9b2:	8f 3f       	cpi	r24, 0xFF	; 255
     9b4:	09 f4       	brne	.+2      	; 0x9b8 <__stack+0xb9>
     9b6:	15 8e       	std	Z+29, r1	; 0x1d
     9b8:	f8 01       	movw	r30, r16
     9ba:	86 8d       	ldd	r24, Z+30	; 0x1e
     9bc:	8f 3f       	cpi	r24, 0xFF	; 255
     9be:	09 f4       	brne	.+2      	; 0x9c2 <__stack+0xc3>
     9c0:	16 8e       	std	Z+30, r1	; 0x1e
     9c2:	0f 90       	pop	r0
     9c4:	0f be       	out	0x3f, r0	; 63
     9c6:	be 01       	movw	r22, r28
     9c8:	6c 5f       	subi	r22, 0xFC	; 252
     9ca:	7f 4f       	sbci	r23, 0xFF	; 255
     9cc:	ce 01       	movw	r24, r28
     9ce:	01 96       	adiw	r24, 0x01	; 1
     9d0:	0e 94 24 0a 	call	0x1448	; 0x1448 <xTaskCheckForTimeOut>
     9d4:	81 11       	cpse	r24, r1
     9d6:	1e c0       	rjmp	.+60     	; 0xa14 <__stack+0x115>
     9d8:	0f b6       	in	r0, 0x3f	; 63
     9da:	f8 94       	cli
     9dc:	0f 92       	push	r0
     9de:	f8 01       	movw	r30, r16
     9e0:	82 8d       	ldd	r24, Z+26	; 0x1a
     9e2:	0f 90       	pop	r0
     9e4:	0f be       	out	0x3f, r0	; 63
     9e6:	81 11       	cpse	r24, r1
     9e8:	0f c0       	rjmp	.+30     	; 0xa08 <__stack+0x109>
     9ea:	6c 81       	ldd	r22, Y+4	; 0x04
     9ec:	7d 81       	ldd	r23, Y+5	; 0x05
     9ee:	c6 01       	movw	r24, r12
     9f0:	0e 94 a6 09 	call	0x134c	; 0x134c <vTaskPlaceOnEventList>
     9f4:	c8 01       	movw	r24, r16
     9f6:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <prvUnlockQueue>
     9fa:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
     9fe:	81 11       	cpse	r24, r1
     a00:	91 cf       	rjmp	.-222    	; 0x924 <__stack+0x25>
     a02:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     a06:	8e cf       	rjmp	.-228    	; 0x924 <__stack+0x25>
     a08:	c8 01       	movw	r24, r16
     a0a:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <prvUnlockQueue>
     a0e:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
     a12:	88 cf       	rjmp	.-240    	; 0x924 <__stack+0x25>
     a14:	c8 01       	movw	r24, r16
     a16:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <prvUnlockQueue>
     a1a:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
     a1e:	0f b6       	in	r0, 0x3f	; 63
     a20:	f8 94       	cli
     a22:	0f 92       	push	r0
     a24:	f8 01       	movw	r30, r16
     a26:	82 8d       	ldd	r24, Z+26	; 0x1a
     a28:	0f 90       	pop	r0
     a2a:	0f be       	out	0x3f, r0	; 63
     a2c:	81 11       	cpse	r24, r1
     a2e:	7a cf       	rjmp	.-268    	; 0x924 <__stack+0x25>
     a30:	0f 90       	pop	r0
     a32:	0f 90       	pop	r0
     a34:	0f 90       	pop	r0
     a36:	0f 90       	pop	r0
     a38:	0f 90       	pop	r0
     a3a:	df 91       	pop	r29
     a3c:	cf 91       	pop	r28
     a3e:	1f 91       	pop	r17
     a40:	0f 91       	pop	r16
     a42:	ff 90       	pop	r15
     a44:	ef 90       	pop	r14
     a46:	df 90       	pop	r13
     a48:	cf 90       	pop	r12
     a4a:	bf 90       	pop	r11
     a4c:	af 90       	pop	r10
     a4e:	9f 90       	pop	r9
     a50:	8f 90       	pop	r8
     a52:	08 95       	ret

00000a54 <vQueueAddToRegistry>:
     a54:	20 91 7b 08 	lds	r18, 0x087B	; 0x80087b <xQueueRegistry>
     a58:	30 91 7c 08 	lds	r19, 0x087C	; 0x80087c <xQueueRegistry+0x1>
     a5c:	23 2b       	or	r18, r19
     a5e:	31 f4       	brne	.+12     	; 0xa6c <vQueueAddToRegistry+0x18>
     a60:	eb e7       	ldi	r30, 0x7B	; 123
     a62:	f8 e0       	ldi	r31, 0x08	; 8
     a64:	71 83       	std	Z+1, r23	; 0x01
     a66:	60 83       	st	Z, r22
     a68:	93 83       	std	Z+3, r25	; 0x03
     a6a:	82 83       	std	Z+2, r24	; 0x02
     a6c:	08 95       	ret

00000a6e <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
     a6e:	cf 93       	push	r28
     a70:	df 93       	push	r29
     a72:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
     a74:	0f b6       	in	r0, 0x3f	; 63
     a76:	f8 94       	cli
     a78:	0f 92       	push	r0
     a7a:	8d 8d       	ldd	r24, Y+29	; 0x1d
     a7c:	8f 3f       	cpi	r24, 0xFF	; 255
     a7e:	09 f4       	brne	.+2      	; 0xa82 <vQueueWaitForMessageRestricted+0x14>
     a80:	1d 8e       	std	Y+29, r1	; 0x1d
     a82:	8e 8d       	ldd	r24, Y+30	; 0x1e
     a84:	8f 3f       	cpi	r24, 0xFF	; 255
     a86:	09 f4       	brne	.+2      	; 0xa8a <vQueueWaitForMessageRestricted+0x1c>
     a88:	1e 8e       	std	Y+30, r1	; 0x1e
     a8a:	0f 90       	pop	r0
     a8c:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
     a8e:	8a 8d       	ldd	r24, Y+26	; 0x1a
     a90:	81 11       	cpse	r24, r1
     a92:	04 c0       	rjmp	.+8      	; 0xa9c <vQueueWaitForMessageRestricted+0x2e>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
     a94:	ce 01       	movw	r24, r28
     a96:	41 96       	adiw	r24, 0x11	; 17
     a98:	0e 94 b8 09 	call	0x1370	; 0x1370 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
     a9c:	ce 01       	movw	r24, r28
     a9e:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <prvUnlockQueue>
	}
     aa2:	df 91       	pop	r29
     aa4:	cf 91       	pop	r28
     aa6:	08 95       	ret

00000aa8 <prvResetNextTaskUnblockTime>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     aa8:	e0 91 ba 07 	lds	r30, 0x07BA	; 0x8007ba <pxDelayedTaskList>
     aac:	f0 91 bb 07 	lds	r31, 0x07BB	; 0x8007bb <pxDelayedTaskList+0x1>
     ab0:	80 81       	ld	r24, Z
     ab2:	81 11       	cpse	r24, r1
     ab4:	07 c0       	rjmp	.+14     	; 0xac4 <prvResetNextTaskUnblockTime+0x1c>
     ab6:	8f ef       	ldi	r24, 0xFF	; 255
     ab8:	9f ef       	ldi	r25, 0xFF	; 255
     aba:	90 93 92 07 	sts	0x0792, r25	; 0x800792 <xNextTaskUnblockTime+0x1>
     abe:	80 93 91 07 	sts	0x0791, r24	; 0x800791 <xNextTaskUnblockTime>
     ac2:	08 95       	ret
     ac4:	e0 91 ba 07 	lds	r30, 0x07BA	; 0x8007ba <pxDelayedTaskList>
     ac8:	f0 91 bb 07 	lds	r31, 0x07BB	; 0x8007bb <pxDelayedTaskList+0x1>
     acc:	05 80       	ldd	r0, Z+5	; 0x05
     ace:	f6 81       	ldd	r31, Z+6	; 0x06
     ad0:	e0 2d       	mov	r30, r0
     ad2:	06 80       	ldd	r0, Z+6	; 0x06
     ad4:	f7 81       	ldd	r31, Z+7	; 0x07
     ad6:	e0 2d       	mov	r30, r0
     ad8:	82 81       	ldd	r24, Z+2	; 0x02
     ada:	93 81       	ldd	r25, Z+3	; 0x03
     adc:	90 93 92 07 	sts	0x0792, r25	; 0x800792 <xNextTaskUnblockTime+0x1>
     ae0:	80 93 91 07 	sts	0x0791, r24	; 0x800791 <xNextTaskUnblockTime>
     ae4:	08 95       	ret

00000ae6 <prvAddCurrentTaskToDelayedList>:
     ae6:	ff 92       	push	r15
     ae8:	0f 93       	push	r16
     aea:	1f 93       	push	r17
     aec:	cf 93       	push	r28
     aee:	df 93       	push	r29
     af0:	ec 01       	movw	r28, r24
     af2:	f6 2e       	mov	r15, r22
     af4:	00 91 99 07 	lds	r16, 0x0799	; 0x800799 <xTickCount>
     af8:	10 91 9a 07 	lds	r17, 0x079A	; 0x80079a <xTickCount+0x1>
     afc:	80 91 f2 07 	lds	r24, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     b00:	90 91 f3 07 	lds	r25, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     b04:	02 96       	adiw	r24, 0x02	; 2
     b06:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
     b0a:	cf 3f       	cpi	r28, 0xFF	; 255
     b0c:	8f ef       	ldi	r24, 0xFF	; 255
     b0e:	d8 07       	cpc	r29, r24
     b10:	69 f4       	brne	.+26     	; 0xb2c <prvAddCurrentTaskToDelayedList+0x46>
     b12:	ff 20       	and	r15, r15
     b14:	59 f0       	breq	.+22     	; 0xb2c <prvAddCurrentTaskToDelayedList+0x46>
     b16:	60 91 f2 07 	lds	r22, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     b1a:	70 91 f3 07 	lds	r23, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     b1e:	6e 5f       	subi	r22, 0xFE	; 254
     b20:	7f 4f       	sbci	r23, 0xFF	; 255
     b22:	8c e9       	ldi	r24, 0x9C	; 156
     b24:	97 e0       	ldi	r25, 0x07	; 7
     b26:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
     b2a:	2f c0       	rjmp	.+94     	; 0xb8a <prvAddCurrentTaskToDelayedList+0xa4>
     b2c:	c0 0f       	add	r28, r16
     b2e:	d1 1f       	adc	r29, r17
     b30:	e0 91 f2 07 	lds	r30, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     b34:	f0 91 f3 07 	lds	r31, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     b38:	d3 83       	std	Z+3, r29	; 0x03
     b3a:	c2 83       	std	Z+2, r28	; 0x02
     b3c:	c0 17       	cp	r28, r16
     b3e:	d1 07       	cpc	r29, r17
     b40:	68 f4       	brcc	.+26     	; 0xb5c <prvAddCurrentTaskToDelayedList+0x76>
     b42:	60 91 f2 07 	lds	r22, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     b46:	70 91 f3 07 	lds	r23, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     b4a:	80 91 b8 07 	lds	r24, 0x07B8	; 0x8007b8 <pxOverflowDelayedTaskList>
     b4e:	90 91 b9 07 	lds	r25, 0x07B9	; 0x8007b9 <pxOverflowDelayedTaskList+0x1>
     b52:	6e 5f       	subi	r22, 0xFE	; 254
     b54:	7f 4f       	sbci	r23, 0xFF	; 255
     b56:	0e 94 90 00 	call	0x120	; 0x120 <vListInsert>
     b5a:	17 c0       	rjmp	.+46     	; 0xb8a <prvAddCurrentTaskToDelayedList+0xa4>
     b5c:	60 91 f2 07 	lds	r22, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     b60:	70 91 f3 07 	lds	r23, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     b64:	80 91 ba 07 	lds	r24, 0x07BA	; 0x8007ba <pxDelayedTaskList>
     b68:	90 91 bb 07 	lds	r25, 0x07BB	; 0x8007bb <pxDelayedTaskList+0x1>
     b6c:	6e 5f       	subi	r22, 0xFE	; 254
     b6e:	7f 4f       	sbci	r23, 0xFF	; 255
     b70:	0e 94 90 00 	call	0x120	; 0x120 <vListInsert>
     b74:	80 91 91 07 	lds	r24, 0x0791	; 0x800791 <xNextTaskUnblockTime>
     b78:	90 91 92 07 	lds	r25, 0x0792	; 0x800792 <xNextTaskUnblockTime+0x1>
     b7c:	c8 17       	cp	r28, r24
     b7e:	d9 07       	cpc	r29, r25
     b80:	20 f4       	brcc	.+8      	; 0xb8a <prvAddCurrentTaskToDelayedList+0xa4>
     b82:	d0 93 92 07 	sts	0x0792, r29	; 0x800792 <xNextTaskUnblockTime+0x1>
     b86:	c0 93 91 07 	sts	0x0791, r28	; 0x800791 <xNextTaskUnblockTime>
     b8a:	df 91       	pop	r29
     b8c:	cf 91       	pop	r28
     b8e:	1f 91       	pop	r17
     b90:	0f 91       	pop	r16
     b92:	ff 90       	pop	r15
     b94:	08 95       	ret

00000b96 <xTaskCreate>:
     b96:	4f 92       	push	r4
     b98:	5f 92       	push	r5
     b9a:	6f 92       	push	r6
     b9c:	7f 92       	push	r7
     b9e:	8f 92       	push	r8
     ba0:	9f 92       	push	r9
     ba2:	af 92       	push	r10
     ba4:	bf 92       	push	r11
     ba6:	cf 92       	push	r12
     ba8:	df 92       	push	r13
     baa:	ef 92       	push	r14
     bac:	ff 92       	push	r15
     bae:	0f 93       	push	r16
     bb0:	cf 93       	push	r28
     bb2:	df 93       	push	r29
     bb4:	4c 01       	movw	r8, r24
     bb6:	6b 01       	movw	r12, r22
     bb8:	5a 01       	movw	r10, r20
     bba:	29 01       	movw	r4, r18
     bbc:	ca 01       	movw	r24, r20
     bbe:	0e 94 e7 00 	call	0x1ce	; 0x1ce <pvPortMalloc>
     bc2:	3c 01       	movw	r6, r24
     bc4:	89 2b       	or	r24, r25
     bc6:	09 f4       	brne	.+2      	; 0xbca <xTaskCreate+0x34>
     bc8:	e2 c0       	rjmp	.+452    	; 0xd8e <xTaskCreate+0x1f8>
     bca:	86 e2       	ldi	r24, 0x26	; 38
     bcc:	90 e0       	ldi	r25, 0x00	; 0
     bce:	0e 94 e7 00 	call	0x1ce	; 0x1ce <pvPortMalloc>
     bd2:	ec 01       	movw	r28, r24
     bd4:	89 2b       	or	r24, r25
     bd6:	71 f0       	breq	.+28     	; 0xbf4 <xTaskCreate+0x5e>
     bd8:	78 8e       	std	Y+24, r7	; 0x18
     bda:	6f 8a       	std	Y+23, r6	; 0x17
     bdc:	81 e0       	ldi	r24, 0x01	; 1
     bde:	a8 1a       	sub	r10, r24
     be0:	b1 08       	sbc	r11, r1
     be2:	a6 0c       	add	r10, r6
     be4:	b7 1c       	adc	r11, r7
     be6:	d6 01       	movw	r26, r12
     be8:	8c 91       	ld	r24, X
     bea:	89 8f       	std	Y+25, r24	; 0x19
     bec:	8c 91       	ld	r24, X
     bee:	81 11       	cpse	r24, r1
     bf0:	05 c0       	rjmp	.+10     	; 0xbfc <xTaskCreate+0x66>
     bf2:	18 c0       	rjmp	.+48     	; 0xc24 <xTaskCreate+0x8e>
     bf4:	c3 01       	movw	r24, r6
     bf6:	0e 94 1c 01 	call	0x238	; 0x238 <vPortFree>
     bfa:	c9 c0       	rjmp	.+402    	; 0xd8e <xTaskCreate+0x1f8>
     bfc:	ae 01       	movw	r20, r28
     bfe:	46 5e       	subi	r20, 0xE6	; 230
     c00:	5f 4f       	sbci	r21, 0xFF	; 255
     c02:	f6 01       	movw	r30, r12
     c04:	31 96       	adiw	r30, 0x01	; 1
     c06:	b8 e0       	ldi	r27, 0x08	; 8
     c08:	cb 0e       	add	r12, r27
     c0a:	d1 1c       	adc	r13, r1
     c0c:	cf 01       	movw	r24, r30
     c0e:	21 91       	ld	r18, Z+
     c10:	da 01       	movw	r26, r20
     c12:	2d 93       	st	X+, r18
     c14:	ad 01       	movw	r20, r26
     c16:	dc 01       	movw	r26, r24
     c18:	8c 91       	ld	r24, X
     c1a:	88 23       	and	r24, r24
     c1c:	19 f0       	breq	.+6      	; 0xc24 <xTaskCreate+0x8e>
     c1e:	ec 15       	cp	r30, r12
     c20:	fd 05       	cpc	r31, r13
     c22:	a1 f7       	brne	.-24     	; 0xc0c <xTaskCreate+0x76>
     c24:	18 a2       	std	Y+32, r1	; 0x20
     c26:	04 30       	cpi	r16, 0x04	; 4
     c28:	08 f0       	brcs	.+2      	; 0xc2c <xTaskCreate+0x96>
     c2a:	03 e0       	ldi	r16, 0x03	; 3
     c2c:	0e 8b       	std	Y+22, r16	; 0x16
     c2e:	6e 01       	movw	r12, r28
     c30:	b2 e0       	ldi	r27, 0x02	; 2
     c32:	cb 0e       	add	r12, r27
     c34:	d1 1c       	adc	r13, r1
     c36:	c6 01       	movw	r24, r12
     c38:	0e 94 6b 00 	call	0xd6	; 0xd6 <vListInitialiseItem>
     c3c:	ce 01       	movw	r24, r28
     c3e:	0c 96       	adiw	r24, 0x0c	; 12
     c40:	0e 94 6b 00 	call	0xd6	; 0xd6 <vListInitialiseItem>
     c44:	d9 87       	std	Y+9, r29	; 0x09
     c46:	c8 87       	std	Y+8, r28	; 0x08
     c48:	84 e0       	ldi	r24, 0x04	; 4
     c4a:	90 e0       	ldi	r25, 0x00	; 0
     c4c:	80 1b       	sub	r24, r16
     c4e:	91 09       	sbc	r25, r1
     c50:	9d 87       	std	Y+13, r25	; 0x0d
     c52:	8c 87       	std	Y+12, r24	; 0x0c
     c54:	db 8b       	std	Y+19, r29	; 0x13
     c56:	ca 8b       	std	Y+18, r28	; 0x12
     c58:	19 a2       	std	Y+33, r1	; 0x21
     c5a:	1a a2       	std	Y+34, r1	; 0x22
     c5c:	1b a2       	std	Y+35, r1	; 0x23
     c5e:	1c a2       	std	Y+36, r1	; 0x24
     c60:	1d a2       	std	Y+37, r1	; 0x25
     c62:	a2 01       	movw	r20, r4
     c64:	b4 01       	movw	r22, r8
     c66:	c5 01       	movw	r24, r10
     c68:	0e 94 1d 01 	call	0x23a	; 0x23a <pxPortInitialiseStack>
     c6c:	99 83       	std	Y+1, r25	; 0x01
     c6e:	88 83       	st	Y, r24
     c70:	e1 14       	cp	r14, r1
     c72:	f1 04       	cpc	r15, r1
     c74:	19 f0       	breq	.+6      	; 0xc7c <xTaskCreate+0xe6>
     c76:	f7 01       	movw	r30, r14
     c78:	d1 83       	std	Z+1, r29	; 0x01
     c7a:	c0 83       	st	Z, r28
     c7c:	0f b6       	in	r0, 0x3f	; 63
     c7e:	f8 94       	cli
     c80:	0f 92       	push	r0
     c82:	80 91 9b 07 	lds	r24, 0x079B	; 0x80079b <uxCurrentNumberOfTasks>
     c86:	8f 5f       	subi	r24, 0xFF	; 255
     c88:	80 93 9b 07 	sts	0x079B, r24	; 0x80079b <uxCurrentNumberOfTasks>
     c8c:	80 91 f2 07 	lds	r24, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     c90:	90 91 f3 07 	lds	r25, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     c94:	89 2b       	or	r24, r25
     c96:	d1 f5       	brne	.+116    	; 0xd0c <xTaskCreate+0x176>
     c98:	d0 93 f3 07 	sts	0x07F3, r29	; 0x8007f3 <pxCurrentTCB+0x1>
     c9c:	c0 93 f2 07 	sts	0x07F2, r28	; 0x8007f2 <pxCurrentTCB>
     ca0:	80 91 9b 07 	lds	r24, 0x079B	; 0x80079b <uxCurrentNumberOfTasks>
     ca4:	81 30       	cpi	r24, 0x01	; 1
     ca6:	09 f0       	breq	.+2      	; 0xcaa <xTaskCreate+0x114>
     ca8:	41 c0       	rjmp	.+130    	; 0xd2c <xTaskCreate+0x196>
     caa:	8e ec       	ldi	r24, 0xCE	; 206
     cac:	97 e0       	ldi	r25, 0x07	; 7
     cae:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     cb2:	87 ed       	ldi	r24, 0xD7	; 215
     cb4:	97 e0       	ldi	r25, 0x07	; 7
     cb6:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     cba:	80 ee       	ldi	r24, 0xE0	; 224
     cbc:	97 e0       	ldi	r25, 0x07	; 7
     cbe:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     cc2:	89 ee       	ldi	r24, 0xE9	; 233
     cc4:	97 e0       	ldi	r25, 0x07	; 7
     cc6:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     cca:	85 ec       	ldi	r24, 0xC5	; 197
     ccc:	97 e0       	ldi	r25, 0x07	; 7
     cce:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     cd2:	8c eb       	ldi	r24, 0xBC	; 188
     cd4:	97 e0       	ldi	r25, 0x07	; 7
     cd6:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     cda:	8f ea       	ldi	r24, 0xAF	; 175
     cdc:	97 e0       	ldi	r25, 0x07	; 7
     cde:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     ce2:	86 ea       	ldi	r24, 0xA6	; 166
     ce4:	97 e0       	ldi	r25, 0x07	; 7
     ce6:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     cea:	8c e9       	ldi	r24, 0x9C	; 156
     cec:	97 e0       	ldi	r25, 0x07	; 7
     cee:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     cf2:	85 ec       	ldi	r24, 0xC5	; 197
     cf4:	97 e0       	ldi	r25, 0x07	; 7
     cf6:	90 93 bb 07 	sts	0x07BB, r25	; 0x8007bb <pxDelayedTaskList+0x1>
     cfa:	80 93 ba 07 	sts	0x07BA, r24	; 0x8007ba <pxDelayedTaskList>
     cfe:	8c eb       	ldi	r24, 0xBC	; 188
     d00:	97 e0       	ldi	r25, 0x07	; 7
     d02:	90 93 b9 07 	sts	0x07B9, r25	; 0x8007b9 <pxOverflowDelayedTaskList+0x1>
     d06:	80 93 b8 07 	sts	0x07B8, r24	; 0x8007b8 <pxOverflowDelayedTaskList>
     d0a:	10 c0       	rjmp	.+32     	; 0xd2c <xTaskCreate+0x196>
     d0c:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <xSchedulerRunning>
     d10:	81 11       	cpse	r24, r1
     d12:	0c c0       	rjmp	.+24     	; 0xd2c <xTaskCreate+0x196>
     d14:	e0 91 f2 07 	lds	r30, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     d18:	f0 91 f3 07 	lds	r31, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     d1c:	96 89       	ldd	r25, Z+22	; 0x16
     d1e:	8e 89       	ldd	r24, Y+22	; 0x16
     d20:	89 17       	cp	r24, r25
     d22:	20 f0       	brcs	.+8      	; 0xd2c <xTaskCreate+0x196>
     d24:	d0 93 f3 07 	sts	0x07F3, r29	; 0x8007f3 <pxCurrentTCB+0x1>
     d28:	c0 93 f2 07 	sts	0x07F2, r28	; 0x8007f2 <pxCurrentTCB>
     d2c:	80 91 93 07 	lds	r24, 0x0793	; 0x800793 <uxTaskNumber>
     d30:	8f 5f       	subi	r24, 0xFF	; 255
     d32:	80 93 93 07 	sts	0x0793, r24	; 0x800793 <uxTaskNumber>
     d36:	8e 89       	ldd	r24, Y+22	; 0x16
     d38:	90 91 98 07 	lds	r25, 0x0798	; 0x800798 <uxTopReadyPriority>
     d3c:	98 17       	cp	r25, r24
     d3e:	10 f4       	brcc	.+4      	; 0xd44 <xTaskCreate+0x1ae>
     d40:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <uxTopReadyPriority>
     d44:	90 e0       	ldi	r25, 0x00	; 0
     d46:	9c 01       	movw	r18, r24
     d48:	22 0f       	add	r18, r18
     d4a:	33 1f       	adc	r19, r19
     d4c:	22 0f       	add	r18, r18
     d4e:	33 1f       	adc	r19, r19
     d50:	22 0f       	add	r18, r18
     d52:	33 1f       	adc	r19, r19
     d54:	82 0f       	add	r24, r18
     d56:	93 1f       	adc	r25, r19
     d58:	b6 01       	movw	r22, r12
     d5a:	82 53       	subi	r24, 0x32	; 50
     d5c:	98 4f       	sbci	r25, 0xF8	; 248
     d5e:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
     d62:	0f 90       	pop	r0
     d64:	0f be       	out	0x3f, r0	; 63
     d66:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <xSchedulerRunning>
     d6a:	88 23       	and	r24, r24
     d6c:	61 f0       	breq	.+24     	; 0xd86 <xTaskCreate+0x1f0>
     d6e:	e0 91 f2 07 	lds	r30, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     d72:	f0 91 f3 07 	lds	r31, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     d76:	96 89       	ldd	r25, Z+22	; 0x16
     d78:	8e 89       	ldd	r24, Y+22	; 0x16
     d7a:	98 17       	cp	r25, r24
     d7c:	30 f4       	brcc	.+12     	; 0xd8a <xTaskCreate+0x1f4>
     d7e:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     d82:	81 e0       	ldi	r24, 0x01	; 1
     d84:	05 c0       	rjmp	.+10     	; 0xd90 <xTaskCreate+0x1fa>
     d86:	81 e0       	ldi	r24, 0x01	; 1
     d88:	03 c0       	rjmp	.+6      	; 0xd90 <xTaskCreate+0x1fa>
     d8a:	81 e0       	ldi	r24, 0x01	; 1
     d8c:	01 c0       	rjmp	.+2      	; 0xd90 <xTaskCreate+0x1fa>
     d8e:	8f ef       	ldi	r24, 0xFF	; 255
     d90:	df 91       	pop	r29
     d92:	cf 91       	pop	r28
     d94:	0f 91       	pop	r16
     d96:	ff 90       	pop	r15
     d98:	ef 90       	pop	r14
     d9a:	df 90       	pop	r13
     d9c:	cf 90       	pop	r12
     d9e:	bf 90       	pop	r11
     da0:	af 90       	pop	r10
     da2:	9f 90       	pop	r9
     da4:	8f 90       	pop	r8
     da6:	7f 90       	pop	r7
     da8:	6f 90       	pop	r6
     daa:	5f 90       	pop	r5
     dac:	4f 90       	pop	r4
     dae:	08 95       	ret

00000db0 <vTaskResume>:
     db0:	0f 93       	push	r16
     db2:	1f 93       	push	r17
     db4:	cf 93       	push	r28
     db6:	df 93       	push	r29
     db8:	00 97       	sbiw	r24, 0x00	; 0
     dba:	09 f4       	brne	.+2      	; 0xdbe <vTaskResume+0xe>
     dbc:	43 c0       	rjmp	.+134    	; 0xe44 <vTaskResume+0x94>
     dbe:	20 91 f2 07 	lds	r18, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     dc2:	30 91 f3 07 	lds	r19, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     dc6:	82 17       	cp	r24, r18
     dc8:	93 07       	cpc	r25, r19
     dca:	09 f4       	brne	.+2      	; 0xdce <vTaskResume+0x1e>
     dcc:	3b c0       	rjmp	.+118    	; 0xe44 <vTaskResume+0x94>
     dce:	0f b6       	in	r0, 0x3f	; 63
     dd0:	f8 94       	cli
     dd2:	0f 92       	push	r0
     dd4:	fc 01       	movw	r30, r24
     dd6:	22 85       	ldd	r18, Z+10	; 0x0a
     dd8:	33 85       	ldd	r19, Z+11	; 0x0b
     dda:	2c 59       	subi	r18, 0x9C	; 156
     ddc:	37 40       	sbci	r19, 0x07	; 7
     dde:	81 f5       	brne	.+96     	; 0xe40 <vTaskResume+0x90>
     de0:	fc 01       	movw	r30, r24
     de2:	24 89       	ldd	r18, Z+20	; 0x14
     de4:	35 89       	ldd	r19, Z+21	; 0x15
     de6:	f7 e0       	ldi	r31, 0x07	; 7
     de8:	2f 3a       	cpi	r18, 0xAF	; 175
     dea:	3f 07       	cpc	r19, r31
     dec:	49 f1       	breq	.+82     	; 0xe40 <vTaskResume+0x90>
     dee:	23 2b       	or	r18, r19
     df0:	39 f5       	brne	.+78     	; 0xe40 <vTaskResume+0x90>
     df2:	ec 01       	movw	r28, r24
     df4:	8c 01       	movw	r16, r24
     df6:	0e 5f       	subi	r16, 0xFE	; 254
     df8:	1f 4f       	sbci	r17, 0xFF	; 255
     dfa:	c8 01       	movw	r24, r16
     dfc:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
     e00:	8e 89       	ldd	r24, Y+22	; 0x16
     e02:	90 91 98 07 	lds	r25, 0x0798	; 0x800798 <uxTopReadyPriority>
     e06:	98 17       	cp	r25, r24
     e08:	10 f4       	brcc	.+4      	; 0xe0e <vTaskResume+0x5e>
     e0a:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <uxTopReadyPriority>
     e0e:	90 e0       	ldi	r25, 0x00	; 0
     e10:	9c 01       	movw	r18, r24
     e12:	22 0f       	add	r18, r18
     e14:	33 1f       	adc	r19, r19
     e16:	22 0f       	add	r18, r18
     e18:	33 1f       	adc	r19, r19
     e1a:	22 0f       	add	r18, r18
     e1c:	33 1f       	adc	r19, r19
     e1e:	82 0f       	add	r24, r18
     e20:	93 1f       	adc	r25, r19
     e22:	b8 01       	movw	r22, r16
     e24:	82 53       	subi	r24, 0x32	; 50
     e26:	98 4f       	sbci	r25, 0xF8	; 248
     e28:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
     e2c:	e0 91 f2 07 	lds	r30, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     e30:	f0 91 f3 07 	lds	r31, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     e34:	9e 89       	ldd	r25, Y+22	; 0x16
     e36:	86 89       	ldd	r24, Z+22	; 0x16
     e38:	98 17       	cp	r25, r24
     e3a:	10 f0       	brcs	.+4      	; 0xe40 <vTaskResume+0x90>
     e3c:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     e40:	0f 90       	pop	r0
     e42:	0f be       	out	0x3f, r0	; 63
     e44:	df 91       	pop	r29
     e46:	cf 91       	pop	r28
     e48:	1f 91       	pop	r17
     e4a:	0f 91       	pop	r16
     e4c:	08 95       	ret

00000e4e <vTaskStartScheduler>:
     e4e:	ef 92       	push	r14
     e50:	ff 92       	push	r15
     e52:	0f 93       	push	r16
     e54:	0f 2e       	mov	r0, r31
     e56:	ff e8       	ldi	r31, 0x8F	; 143
     e58:	ef 2e       	mov	r14, r31
     e5a:	f7 e0       	ldi	r31, 0x07	; 7
     e5c:	ff 2e       	mov	r15, r31
     e5e:	f0 2d       	mov	r31, r0
     e60:	00 e0       	ldi	r16, 0x00	; 0
     e62:	20 e0       	ldi	r18, 0x00	; 0
     e64:	30 e0       	ldi	r19, 0x00	; 0
     e66:	45 e5       	ldi	r20, 0x55	; 85
     e68:	50 e0       	ldi	r21, 0x00	; 0
     e6a:	60 e0       	ldi	r22, 0x00	; 0
     e6c:	71 e0       	ldi	r23, 0x01	; 1
     e6e:	83 eb       	ldi	r24, 0xB3	; 179
     e70:	98 e0       	ldi	r25, 0x08	; 8
     e72:	0e 94 cb 05 	call	0xb96	; 0xb96 <xTaskCreate>
     e76:	81 30       	cpi	r24, 0x01	; 1
     e78:	a1 f4       	brne	.+40     	; 0xea2 <vTaskStartScheduler+0x54>
     e7a:	0e 94 cd 0a 	call	0x159a	; 0x159a <xTimerCreateTimerTask>
     e7e:	81 30       	cpi	r24, 0x01	; 1
     e80:	81 f4       	brne	.+32     	; 0xea2 <vTaskStartScheduler+0x54>
     e82:	f8 94       	cli
     e84:	8f ef       	ldi	r24, 0xFF	; 255
     e86:	9f ef       	ldi	r25, 0xFF	; 255
     e88:	90 93 92 07 	sts	0x0792, r25	; 0x800792 <xNextTaskUnblockTime+0x1>
     e8c:	80 93 91 07 	sts	0x0791, r24	; 0x800791 <xNextTaskUnblockTime>
     e90:	81 e0       	ldi	r24, 0x01	; 1
     e92:	80 93 97 07 	sts	0x0797, r24	; 0x800797 <xSchedulerRunning>
     e96:	10 92 9a 07 	sts	0x079A, r1	; 0x80079a <xTickCount+0x1>
     e9a:	10 92 99 07 	sts	0x0799, r1	; 0x800799 <xTickCount>
     e9e:	0e 94 89 01 	call	0x312	; 0x312 <xPortStartScheduler>
     ea2:	0f 91       	pop	r16
     ea4:	ff 90       	pop	r15
     ea6:	ef 90       	pop	r14
     ea8:	08 95       	ret

00000eaa <vTaskSuspendAll>:
     eaa:	80 91 8e 07 	lds	r24, 0x078E	; 0x80078e <uxSchedulerSuspended>
     eae:	8f 5f       	subi	r24, 0xFF	; 255
     eb0:	80 93 8e 07 	sts	0x078E, r24	; 0x80078e <uxSchedulerSuspended>
     eb4:	08 95       	ret

00000eb6 <xTaskGetTickCount>:
     eb6:	0f b6       	in	r0, 0x3f	; 63
     eb8:	f8 94       	cli
     eba:	0f 92       	push	r0
     ebc:	80 91 99 07 	lds	r24, 0x0799	; 0x800799 <xTickCount>
     ec0:	90 91 9a 07 	lds	r25, 0x079A	; 0x80079a <xTickCount+0x1>
     ec4:	0f 90       	pop	r0
     ec6:	0f be       	out	0x3f, r0	; 63
     ec8:	08 95       	ret

00000eca <xTaskIncrementTick>:
     eca:	cf 92       	push	r12
     ecc:	df 92       	push	r13
     ece:	ef 92       	push	r14
     ed0:	ff 92       	push	r15
     ed2:	0f 93       	push	r16
     ed4:	1f 93       	push	r17
     ed6:	cf 93       	push	r28
     ed8:	df 93       	push	r29
     eda:	80 91 8e 07 	lds	r24, 0x078E	; 0x80078e <uxSchedulerSuspended>
     ede:	81 11       	cpse	r24, r1
     ee0:	99 c0       	rjmp	.+306    	; 0x1014 <xTaskIncrementTick+0x14a>
     ee2:	e0 90 99 07 	lds	r14, 0x0799	; 0x800799 <xTickCount>
     ee6:	f0 90 9a 07 	lds	r15, 0x079A	; 0x80079a <xTickCount+0x1>
     eea:	8f ef       	ldi	r24, 0xFF	; 255
     eec:	e8 1a       	sub	r14, r24
     eee:	f8 0a       	sbc	r15, r24
     ef0:	f0 92 9a 07 	sts	0x079A, r15	; 0x80079a <xTickCount+0x1>
     ef4:	e0 92 99 07 	sts	0x0799, r14	; 0x800799 <xTickCount>
     ef8:	e1 14       	cp	r14, r1
     efa:	f1 04       	cpc	r15, r1
     efc:	b9 f4       	brne	.+46     	; 0xf2c <xTaskIncrementTick+0x62>
     efe:	80 91 ba 07 	lds	r24, 0x07BA	; 0x8007ba <pxDelayedTaskList>
     f02:	90 91 bb 07 	lds	r25, 0x07BB	; 0x8007bb <pxDelayedTaskList+0x1>
     f06:	20 91 b8 07 	lds	r18, 0x07B8	; 0x8007b8 <pxOverflowDelayedTaskList>
     f0a:	30 91 b9 07 	lds	r19, 0x07B9	; 0x8007b9 <pxOverflowDelayedTaskList+0x1>
     f0e:	30 93 bb 07 	sts	0x07BB, r19	; 0x8007bb <pxDelayedTaskList+0x1>
     f12:	20 93 ba 07 	sts	0x07BA, r18	; 0x8007ba <pxDelayedTaskList>
     f16:	90 93 b9 07 	sts	0x07B9, r25	; 0x8007b9 <pxOverflowDelayedTaskList+0x1>
     f1a:	80 93 b8 07 	sts	0x07B8, r24	; 0x8007b8 <pxOverflowDelayedTaskList>
     f1e:	80 91 94 07 	lds	r24, 0x0794	; 0x800794 <xNumOfOverflows>
     f22:	8f 5f       	subi	r24, 0xFF	; 255
     f24:	80 93 94 07 	sts	0x0794, r24	; 0x800794 <xNumOfOverflows>
     f28:	0e 94 54 05 	call	0xaa8	; 0xaa8 <prvResetNextTaskUnblockTime>
     f2c:	80 91 91 07 	lds	r24, 0x0791	; 0x800791 <xNextTaskUnblockTime>
     f30:	90 91 92 07 	lds	r25, 0x0792	; 0x800792 <xNextTaskUnblockTime+0x1>
     f34:	e8 16       	cp	r14, r24
     f36:	f9 06       	cpc	r15, r25
     f38:	10 f4       	brcc	.+4      	; 0xf3e <xTaskIncrementTick+0x74>
     f3a:	d1 2c       	mov	r13, r1
     f3c:	53 c0       	rjmp	.+166    	; 0xfe4 <xTaskIncrementTick+0x11a>
     f3e:	d1 2c       	mov	r13, r1
     f40:	cc 24       	eor	r12, r12
     f42:	c3 94       	inc	r12
     f44:	e0 91 ba 07 	lds	r30, 0x07BA	; 0x8007ba <pxDelayedTaskList>
     f48:	f0 91 bb 07 	lds	r31, 0x07BB	; 0x8007bb <pxDelayedTaskList+0x1>
     f4c:	80 81       	ld	r24, Z
     f4e:	81 11       	cpse	r24, r1
     f50:	07 c0       	rjmp	.+14     	; 0xf60 <xTaskIncrementTick+0x96>
     f52:	8f ef       	ldi	r24, 0xFF	; 255
     f54:	9f ef       	ldi	r25, 0xFF	; 255
     f56:	90 93 92 07 	sts	0x0792, r25	; 0x800792 <xNextTaskUnblockTime+0x1>
     f5a:	80 93 91 07 	sts	0x0791, r24	; 0x800791 <xNextTaskUnblockTime>
     f5e:	42 c0       	rjmp	.+132    	; 0xfe4 <xTaskIncrementTick+0x11a>
     f60:	e0 91 ba 07 	lds	r30, 0x07BA	; 0x8007ba <pxDelayedTaskList>
     f64:	f0 91 bb 07 	lds	r31, 0x07BB	; 0x8007bb <pxDelayedTaskList+0x1>
     f68:	05 80       	ldd	r0, Z+5	; 0x05
     f6a:	f6 81       	ldd	r31, Z+6	; 0x06
     f6c:	e0 2d       	mov	r30, r0
     f6e:	c6 81       	ldd	r28, Z+6	; 0x06
     f70:	d7 81       	ldd	r29, Z+7	; 0x07
     f72:	8a 81       	ldd	r24, Y+2	; 0x02
     f74:	9b 81       	ldd	r25, Y+3	; 0x03
     f76:	e8 16       	cp	r14, r24
     f78:	f9 06       	cpc	r15, r25
     f7a:	28 f4       	brcc	.+10     	; 0xf86 <xTaskIncrementTick+0xbc>
     f7c:	90 93 92 07 	sts	0x0792, r25	; 0x800792 <xNextTaskUnblockTime+0x1>
     f80:	80 93 91 07 	sts	0x0791, r24	; 0x800791 <xNextTaskUnblockTime>
     f84:	2f c0       	rjmp	.+94     	; 0xfe4 <xTaskIncrementTick+0x11a>
     f86:	8e 01       	movw	r16, r28
     f88:	0e 5f       	subi	r16, 0xFE	; 254
     f8a:	1f 4f       	sbci	r17, 0xFF	; 255
     f8c:	c8 01       	movw	r24, r16
     f8e:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
     f92:	8c 89       	ldd	r24, Y+20	; 0x14
     f94:	9d 89       	ldd	r25, Y+21	; 0x15
     f96:	89 2b       	or	r24, r25
     f98:	21 f0       	breq	.+8      	; 0xfa2 <xTaskIncrementTick+0xd8>
     f9a:	ce 01       	movw	r24, r28
     f9c:	0c 96       	adiw	r24, 0x0c	; 12
     f9e:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
     fa2:	8e 89       	ldd	r24, Y+22	; 0x16
     fa4:	90 91 98 07 	lds	r25, 0x0798	; 0x800798 <uxTopReadyPriority>
     fa8:	98 17       	cp	r25, r24
     faa:	10 f4       	brcc	.+4      	; 0xfb0 <xTaskIncrementTick+0xe6>
     fac:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <uxTopReadyPriority>
     fb0:	90 e0       	ldi	r25, 0x00	; 0
     fb2:	9c 01       	movw	r18, r24
     fb4:	22 0f       	add	r18, r18
     fb6:	33 1f       	adc	r19, r19
     fb8:	22 0f       	add	r18, r18
     fba:	33 1f       	adc	r19, r19
     fbc:	22 0f       	add	r18, r18
     fbe:	33 1f       	adc	r19, r19
     fc0:	82 0f       	add	r24, r18
     fc2:	93 1f       	adc	r25, r19
     fc4:	b8 01       	movw	r22, r16
     fc6:	82 53       	subi	r24, 0x32	; 50
     fc8:	98 4f       	sbci	r25, 0xF8	; 248
     fca:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
     fce:	e0 91 f2 07 	lds	r30, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     fd2:	f0 91 f3 07 	lds	r31, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     fd6:	9e 89       	ldd	r25, Y+22	; 0x16
     fd8:	86 89       	ldd	r24, Z+22	; 0x16
     fda:	98 17       	cp	r25, r24
     fdc:	08 f4       	brcc	.+2      	; 0xfe0 <xTaskIncrementTick+0x116>
     fde:	b2 cf       	rjmp	.-156    	; 0xf44 <xTaskIncrementTick+0x7a>
     fe0:	dc 2c       	mov	r13, r12
     fe2:	b0 cf       	rjmp	.-160    	; 0xf44 <xTaskIncrementTick+0x7a>
     fe4:	e0 91 f2 07 	lds	r30, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     fe8:	f0 91 f3 07 	lds	r31, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     fec:	86 89       	ldd	r24, Z+22	; 0x16
     fee:	90 e0       	ldi	r25, 0x00	; 0
     ff0:	fc 01       	movw	r30, r24
     ff2:	ee 0f       	add	r30, r30
     ff4:	ff 1f       	adc	r31, r31
     ff6:	ee 0f       	add	r30, r30
     ff8:	ff 1f       	adc	r31, r31
     ffa:	ee 0f       	add	r30, r30
     ffc:	ff 1f       	adc	r31, r31
     ffe:	8e 0f       	add	r24, r30
    1000:	9f 1f       	adc	r25, r31
    1002:	fc 01       	movw	r30, r24
    1004:	e2 53       	subi	r30, 0x32	; 50
    1006:	f8 4f       	sbci	r31, 0xF8	; 248
    1008:	80 81       	ld	r24, Z
    100a:	82 30       	cpi	r24, 0x02	; 2
    100c:	48 f0       	brcs	.+18     	; 0x1020 <xTaskIncrementTick+0x156>
    100e:	dd 24       	eor	r13, r13
    1010:	d3 94       	inc	r13
    1012:	06 c0       	rjmp	.+12     	; 0x1020 <xTaskIncrementTick+0x156>
    1014:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <uxPendedTicks>
    1018:	8f 5f       	subi	r24, 0xFF	; 255
    101a:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <uxPendedTicks>
    101e:	d1 2c       	mov	r13, r1
    1020:	80 91 95 07 	lds	r24, 0x0795	; 0x800795 <xYieldPending>
    1024:	88 23       	and	r24, r24
    1026:	11 f0       	breq	.+4      	; 0x102c <xTaskIncrementTick+0x162>
    1028:	dd 24       	eor	r13, r13
    102a:	d3 94       	inc	r13
    102c:	8d 2d       	mov	r24, r13
    102e:	df 91       	pop	r29
    1030:	cf 91       	pop	r28
    1032:	1f 91       	pop	r17
    1034:	0f 91       	pop	r16
    1036:	ff 90       	pop	r15
    1038:	ef 90       	pop	r14
    103a:	df 90       	pop	r13
    103c:	cf 90       	pop	r12
    103e:	08 95       	ret

00001040 <xTaskResumeAll>:
    1040:	df 92       	push	r13
    1042:	ef 92       	push	r14
    1044:	ff 92       	push	r15
    1046:	0f 93       	push	r16
    1048:	1f 93       	push	r17
    104a:	cf 93       	push	r28
    104c:	df 93       	push	r29
    104e:	0f b6       	in	r0, 0x3f	; 63
    1050:	f8 94       	cli
    1052:	0f 92       	push	r0
    1054:	80 91 8e 07 	lds	r24, 0x078E	; 0x80078e <uxSchedulerSuspended>
    1058:	81 50       	subi	r24, 0x01	; 1
    105a:	80 93 8e 07 	sts	0x078E, r24	; 0x80078e <uxSchedulerSuspended>
    105e:	80 91 8e 07 	lds	r24, 0x078E	; 0x80078e <uxSchedulerSuspended>
    1062:	81 11       	cpse	r24, r1
    1064:	5f c0       	rjmp	.+190    	; 0x1124 <xTaskResumeAll+0xe4>
    1066:	80 91 9b 07 	lds	r24, 0x079B	; 0x80079b <uxCurrentNumberOfTasks>
    106a:	81 11       	cpse	r24, r1
    106c:	33 c0       	rjmp	.+102    	; 0x10d4 <xTaskResumeAll+0x94>
    106e:	5d c0       	rjmp	.+186    	; 0x112a <xTaskResumeAll+0xea>
    1070:	d7 01       	movw	r26, r14
    1072:	15 96       	adiw	r26, 0x05	; 5
    1074:	ed 91       	ld	r30, X+
    1076:	fc 91       	ld	r31, X
    1078:	16 97       	sbiw	r26, 0x06	; 6
    107a:	c6 81       	ldd	r28, Z+6	; 0x06
    107c:	d7 81       	ldd	r29, Z+7	; 0x07
    107e:	ce 01       	movw	r24, r28
    1080:	0c 96       	adiw	r24, 0x0c	; 12
    1082:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
    1086:	8e 01       	movw	r16, r28
    1088:	0e 5f       	subi	r16, 0xFE	; 254
    108a:	1f 4f       	sbci	r17, 0xFF	; 255
    108c:	c8 01       	movw	r24, r16
    108e:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
    1092:	8e 89       	ldd	r24, Y+22	; 0x16
    1094:	90 91 98 07 	lds	r25, 0x0798	; 0x800798 <uxTopReadyPriority>
    1098:	98 17       	cp	r25, r24
    109a:	10 f4       	brcc	.+4      	; 0x10a0 <xTaskResumeAll+0x60>
    109c:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <uxTopReadyPriority>
    10a0:	90 e0       	ldi	r25, 0x00	; 0
    10a2:	9c 01       	movw	r18, r24
    10a4:	22 0f       	add	r18, r18
    10a6:	33 1f       	adc	r19, r19
    10a8:	22 0f       	add	r18, r18
    10aa:	33 1f       	adc	r19, r19
    10ac:	22 0f       	add	r18, r18
    10ae:	33 1f       	adc	r19, r19
    10b0:	82 0f       	add	r24, r18
    10b2:	93 1f       	adc	r25, r19
    10b4:	b8 01       	movw	r22, r16
    10b6:	82 53       	subi	r24, 0x32	; 50
    10b8:	98 4f       	sbci	r25, 0xF8	; 248
    10ba:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
    10be:	e0 91 f2 07 	lds	r30, 0x07F2	; 0x8007f2 <pxCurrentTCB>
    10c2:	f0 91 f3 07 	lds	r31, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
    10c6:	9e 89       	ldd	r25, Y+22	; 0x16
    10c8:	86 89       	ldd	r24, Z+22	; 0x16
    10ca:	98 17       	cp	r25, r24
    10cc:	68 f0       	brcs	.+26     	; 0x10e8 <xTaskResumeAll+0xa8>
    10ce:	d0 92 95 07 	sts	0x0795, r13	; 0x800795 <xYieldPending>
    10d2:	0a c0       	rjmp	.+20     	; 0x10e8 <xTaskResumeAll+0xa8>
    10d4:	c0 e0       	ldi	r28, 0x00	; 0
    10d6:	d0 e0       	ldi	r29, 0x00	; 0
    10d8:	0f 2e       	mov	r0, r31
    10da:	ff ea       	ldi	r31, 0xAF	; 175
    10dc:	ef 2e       	mov	r14, r31
    10de:	f7 e0       	ldi	r31, 0x07	; 7
    10e0:	ff 2e       	mov	r15, r31
    10e2:	f0 2d       	mov	r31, r0
    10e4:	dd 24       	eor	r13, r13
    10e6:	d3 94       	inc	r13
    10e8:	f7 01       	movw	r30, r14
    10ea:	80 81       	ld	r24, Z
    10ec:	81 11       	cpse	r24, r1
    10ee:	c0 cf       	rjmp	.-128    	; 0x1070 <xTaskResumeAll+0x30>
    10f0:	cd 2b       	or	r28, r29
    10f2:	11 f0       	breq	.+4      	; 0x10f8 <xTaskResumeAll+0xb8>
    10f4:	0e 94 54 05 	call	0xaa8	; 0xaa8 <prvResetNextTaskUnblockTime>
    10f8:	c0 91 96 07 	lds	r28, 0x0796	; 0x800796 <uxPendedTicks>
    10fc:	cc 23       	and	r28, r28
    10fe:	51 f0       	breq	.+20     	; 0x1114 <xTaskResumeAll+0xd4>
    1100:	d1 e0       	ldi	r29, 0x01	; 1
    1102:	0e 94 65 07 	call	0xeca	; 0xeca <xTaskIncrementTick>
    1106:	81 11       	cpse	r24, r1
    1108:	d0 93 95 07 	sts	0x0795, r29	; 0x800795 <xYieldPending>
    110c:	c1 50       	subi	r28, 0x01	; 1
    110e:	c9 f7       	brne	.-14     	; 0x1102 <xTaskResumeAll+0xc2>
    1110:	10 92 96 07 	sts	0x0796, r1	; 0x800796 <uxPendedTicks>
    1114:	80 91 95 07 	lds	r24, 0x0795	; 0x800795 <xYieldPending>
    1118:	88 23       	and	r24, r24
    111a:	31 f0       	breq	.+12     	; 0x1128 <xTaskResumeAll+0xe8>
    111c:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
    1120:	81 e0       	ldi	r24, 0x01	; 1
    1122:	03 c0       	rjmp	.+6      	; 0x112a <xTaskResumeAll+0xea>
    1124:	80 e0       	ldi	r24, 0x00	; 0
    1126:	01 c0       	rjmp	.+2      	; 0x112a <xTaskResumeAll+0xea>
    1128:	80 e0       	ldi	r24, 0x00	; 0
    112a:	0f 90       	pop	r0
    112c:	0f be       	out	0x3f, r0	; 63
    112e:	df 91       	pop	r29
    1130:	cf 91       	pop	r28
    1132:	1f 91       	pop	r17
    1134:	0f 91       	pop	r16
    1136:	ff 90       	pop	r15
    1138:	ef 90       	pop	r14
    113a:	df 90       	pop	r13
    113c:	08 95       	ret

0000113e <vTaskDelay>:
    113e:	cf 93       	push	r28
    1140:	df 93       	push	r29
    1142:	ec 01       	movw	r28, r24
    1144:	89 2b       	or	r24, r25
    1146:	51 f0       	breq	.+20     	; 0x115c <vTaskDelay+0x1e>
    1148:	0e 94 55 07 	call	0xeaa	; 0xeaa <vTaskSuspendAll>
    114c:	60 e0       	ldi	r22, 0x00	; 0
    114e:	ce 01       	movw	r24, r28
    1150:	0e 94 73 05 	call	0xae6	; 0xae6 <prvAddCurrentTaskToDelayedList>
    1154:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
    1158:	81 11       	cpse	r24, r1
    115a:	02 c0       	rjmp	.+4      	; 0x1160 <vTaskDelay+0x22>
    115c:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
    1160:	df 91       	pop	r29
    1162:	cf 91       	pop	r28
    1164:	08 95       	ret

00001166 <prvIdleTask>:
    1166:	06 ea       	ldi	r16, 0xA6	; 166
    1168:	17 e0       	ldi	r17, 0x07	; 7
    116a:	0f 2e       	mov	r0, r31
    116c:	fe ec       	ldi	r31, 0xCE	; 206
    116e:	ef 2e       	mov	r14, r31
    1170:	f7 e0       	ldi	r31, 0x07	; 7
    1172:	ff 2e       	mov	r15, r31
    1174:	f0 2d       	mov	r31, r0
    1176:	29 c0       	rjmp	.+82     	; 0x11ca <prvIdleTask+0x64>
    1178:	0e 94 55 07 	call	0xeaa	; 0xeaa <vTaskSuspendAll>
    117c:	d8 01       	movw	r26, r16
    117e:	cc 91       	ld	r28, X
    1180:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
    1184:	cc 23       	and	r28, r28
    1186:	09 f1       	breq	.+66     	; 0x11ca <prvIdleTask+0x64>
    1188:	0f b6       	in	r0, 0x3f	; 63
    118a:	f8 94       	cli
    118c:	0f 92       	push	r0
    118e:	d8 01       	movw	r26, r16
    1190:	15 96       	adiw	r26, 0x05	; 5
    1192:	ed 91       	ld	r30, X+
    1194:	fc 91       	ld	r31, X
    1196:	16 97       	sbiw	r26, 0x06	; 6
    1198:	c6 81       	ldd	r28, Z+6	; 0x06
    119a:	d7 81       	ldd	r29, Z+7	; 0x07
    119c:	ce 01       	movw	r24, r28
    119e:	02 96       	adiw	r24, 0x02	; 2
    11a0:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
    11a4:	80 91 9b 07 	lds	r24, 0x079B	; 0x80079b <uxCurrentNumberOfTasks>
    11a8:	81 50       	subi	r24, 0x01	; 1
    11aa:	80 93 9b 07 	sts	0x079B, r24	; 0x80079b <uxCurrentNumberOfTasks>
    11ae:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <uxDeletedTasksWaitingCleanUp>
    11b2:	81 50       	subi	r24, 0x01	; 1
    11b4:	80 93 a5 07 	sts	0x07A5, r24	; 0x8007a5 <uxDeletedTasksWaitingCleanUp>
    11b8:	0f 90       	pop	r0
    11ba:	0f be       	out	0x3f, r0	; 63
    11bc:	8f 89       	ldd	r24, Y+23	; 0x17
    11be:	98 8d       	ldd	r25, Y+24	; 0x18
    11c0:	0e 94 1c 01 	call	0x238	; 0x238 <vPortFree>
    11c4:	ce 01       	movw	r24, r28
    11c6:	0e 94 1c 01 	call	0x238	; 0x238 <vPortFree>
    11ca:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <uxDeletedTasksWaitingCleanUp>
    11ce:	81 11       	cpse	r24, r1
    11d0:	d3 cf       	rjmp	.-90     	; 0x1178 <prvIdleTask+0x12>
    11d2:	f7 01       	movw	r30, r14
    11d4:	80 81       	ld	r24, Z
    11d6:	82 30       	cpi	r24, 0x02	; 2
    11d8:	10 f0       	brcs	.+4      	; 0x11de <prvIdleTask+0x78>
    11da:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
    11de:	0e 94 4c 13 	call	0x2698	; 0x2698 <vApplicationIdleHook>
    11e2:	f3 cf       	rjmp	.-26     	; 0x11ca <prvIdleTask+0x64>

000011e4 <vTaskSwitchContext>:
    11e4:	80 91 8e 07 	lds	r24, 0x078E	; 0x80078e <uxSchedulerSuspended>
    11e8:	88 23       	and	r24, r24
    11ea:	21 f0       	breq	.+8      	; 0x11f4 <vTaskSwitchContext+0x10>
    11ec:	81 e0       	ldi	r24, 0x01	; 1
    11ee:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <xYieldPending>
    11f2:	08 95       	ret
    11f4:	10 92 95 07 	sts	0x0795, r1	; 0x800795 <xYieldPending>
    11f8:	20 91 98 07 	lds	r18, 0x0798	; 0x800798 <uxTopReadyPriority>
    11fc:	82 2f       	mov	r24, r18
    11fe:	90 e0       	ldi	r25, 0x00	; 0
    1200:	fc 01       	movw	r30, r24
    1202:	ee 0f       	add	r30, r30
    1204:	ff 1f       	adc	r31, r31
    1206:	ee 0f       	add	r30, r30
    1208:	ff 1f       	adc	r31, r31
    120a:	ee 0f       	add	r30, r30
    120c:	ff 1f       	adc	r31, r31
    120e:	e8 0f       	add	r30, r24
    1210:	f9 1f       	adc	r31, r25
    1212:	e2 53       	subi	r30, 0x32	; 50
    1214:	f8 4f       	sbci	r31, 0xF8	; 248
    1216:	30 81       	ld	r19, Z
    1218:	31 11       	cpse	r19, r1
    121a:	11 c0       	rjmp	.+34     	; 0x123e <vTaskSwitchContext+0x5a>
    121c:	21 50       	subi	r18, 0x01	; 1
    121e:	82 2f       	mov	r24, r18
    1220:	90 e0       	ldi	r25, 0x00	; 0
    1222:	fc 01       	movw	r30, r24
    1224:	ee 0f       	add	r30, r30
    1226:	ff 1f       	adc	r31, r31
    1228:	ee 0f       	add	r30, r30
    122a:	ff 1f       	adc	r31, r31
    122c:	ee 0f       	add	r30, r30
    122e:	ff 1f       	adc	r31, r31
    1230:	e8 0f       	add	r30, r24
    1232:	f9 1f       	adc	r31, r25
    1234:	e2 53       	subi	r30, 0x32	; 50
    1236:	f8 4f       	sbci	r31, 0xF8	; 248
    1238:	30 81       	ld	r19, Z
    123a:	33 23       	and	r19, r19
    123c:	79 f3       	breq	.-34     	; 0x121c <vTaskSwitchContext+0x38>
    123e:	ac 01       	movw	r20, r24
    1240:	44 0f       	add	r20, r20
    1242:	55 1f       	adc	r21, r21
    1244:	44 0f       	add	r20, r20
    1246:	55 1f       	adc	r21, r21
    1248:	44 0f       	add	r20, r20
    124a:	55 1f       	adc	r21, r21
    124c:	48 0f       	add	r20, r24
    124e:	59 1f       	adc	r21, r25
    1250:	da 01       	movw	r26, r20
    1252:	a2 53       	subi	r26, 0x32	; 50
    1254:	b8 4f       	sbci	r27, 0xF8	; 248
    1256:	11 96       	adiw	r26, 0x01	; 1
    1258:	ed 91       	ld	r30, X+
    125a:	fc 91       	ld	r31, X
    125c:	12 97       	sbiw	r26, 0x02	; 2
    125e:	02 80       	ldd	r0, Z+2	; 0x02
    1260:	f3 81       	ldd	r31, Z+3	; 0x03
    1262:	e0 2d       	mov	r30, r0
    1264:	12 96       	adiw	r26, 0x02	; 2
    1266:	fc 93       	st	X, r31
    1268:	ee 93       	st	-X, r30
    126a:	11 97       	sbiw	r26, 0x01	; 1
    126c:	4f 52       	subi	r20, 0x2F	; 47
    126e:	58 4f       	sbci	r21, 0xF8	; 248
    1270:	e4 17       	cp	r30, r20
    1272:	f5 07       	cpc	r31, r21
    1274:	29 f4       	brne	.+10     	; 0x1280 <vTaskSwitchContext+0x9c>
    1276:	42 81       	ldd	r20, Z+2	; 0x02
    1278:	53 81       	ldd	r21, Z+3	; 0x03
    127a:	fd 01       	movw	r30, r26
    127c:	52 83       	std	Z+2, r21	; 0x02
    127e:	41 83       	std	Z+1, r20	; 0x01
    1280:	fc 01       	movw	r30, r24
    1282:	ee 0f       	add	r30, r30
    1284:	ff 1f       	adc	r31, r31
    1286:	ee 0f       	add	r30, r30
    1288:	ff 1f       	adc	r31, r31
    128a:	ee 0f       	add	r30, r30
    128c:	ff 1f       	adc	r31, r31
    128e:	8e 0f       	add	r24, r30
    1290:	9f 1f       	adc	r25, r31
    1292:	fc 01       	movw	r30, r24
    1294:	e2 53       	subi	r30, 0x32	; 50
    1296:	f8 4f       	sbci	r31, 0xF8	; 248
    1298:	01 80       	ldd	r0, Z+1	; 0x01
    129a:	f2 81       	ldd	r31, Z+2	; 0x02
    129c:	e0 2d       	mov	r30, r0
    129e:	86 81       	ldd	r24, Z+6	; 0x06
    12a0:	97 81       	ldd	r25, Z+7	; 0x07
    12a2:	90 93 f3 07 	sts	0x07F3, r25	; 0x8007f3 <pxCurrentTCB+0x1>
    12a6:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <pxCurrentTCB>
    12aa:	20 93 98 07 	sts	0x0798, r18	; 0x800798 <uxTopReadyPriority>
    12ae:	08 95       	ret

000012b0 <vTaskSuspend>:
    12b0:	0f 93       	push	r16
    12b2:	1f 93       	push	r17
    12b4:	cf 93       	push	r28
    12b6:	df 93       	push	r29
    12b8:	ec 01       	movw	r28, r24
    12ba:	0f b6       	in	r0, 0x3f	; 63
    12bc:	f8 94       	cli
    12be:	0f 92       	push	r0
    12c0:	89 2b       	or	r24, r25
    12c2:	21 f4       	brne	.+8      	; 0x12cc <vTaskSuspend+0x1c>
    12c4:	c0 91 f2 07 	lds	r28, 0x07F2	; 0x8007f2 <pxCurrentTCB>
    12c8:	d0 91 f3 07 	lds	r29, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
    12cc:	8e 01       	movw	r16, r28
    12ce:	0e 5f       	subi	r16, 0xFE	; 254
    12d0:	1f 4f       	sbci	r17, 0xFF	; 255
    12d2:	c8 01       	movw	r24, r16
    12d4:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
    12d8:	8c 89       	ldd	r24, Y+20	; 0x14
    12da:	9d 89       	ldd	r25, Y+21	; 0x15
    12dc:	89 2b       	or	r24, r25
    12de:	21 f0       	breq	.+8      	; 0x12e8 <vTaskSuspend+0x38>
    12e0:	ce 01       	movw	r24, r28
    12e2:	0c 96       	adiw	r24, 0x0c	; 12
    12e4:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
    12e8:	b8 01       	movw	r22, r16
    12ea:	8c e9       	ldi	r24, 0x9C	; 156
    12ec:	97 e0       	ldi	r25, 0x07	; 7
    12ee:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
    12f2:	0f 90       	pop	r0
    12f4:	0f be       	out	0x3f, r0	; 63
    12f6:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <xSchedulerRunning>
    12fa:	88 23       	and	r24, r24
    12fc:	39 f0       	breq	.+14     	; 0x130c <vTaskSuspend+0x5c>
    12fe:	0f b6       	in	r0, 0x3f	; 63
    1300:	f8 94       	cli
    1302:	0f 92       	push	r0
    1304:	0e 94 54 05 	call	0xaa8	; 0xaa8 <prvResetNextTaskUnblockTime>
    1308:	0f 90       	pop	r0
    130a:	0f be       	out	0x3f, r0	; 63
    130c:	80 91 f2 07 	lds	r24, 0x07F2	; 0x8007f2 <pxCurrentTCB>
    1310:	90 91 f3 07 	lds	r25, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
    1314:	c8 17       	cp	r28, r24
    1316:	d9 07       	cpc	r29, r25
    1318:	a1 f4       	brne	.+40     	; 0x1342 <vTaskSuspend+0x92>
    131a:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <xSchedulerRunning>
    131e:	88 23       	and	r24, r24
    1320:	19 f0       	breq	.+6      	; 0x1328 <vTaskSuspend+0x78>
    1322:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
    1326:	0d c0       	rjmp	.+26     	; 0x1342 <vTaskSuspend+0x92>
    1328:	80 91 9b 07 	lds	r24, 0x079B	; 0x80079b <uxCurrentNumberOfTasks>
    132c:	90 91 9c 07 	lds	r25, 0x079C	; 0x80079c <xSuspendedTaskList>
    1330:	98 13       	cpse	r25, r24
    1332:	05 c0       	rjmp	.+10     	; 0x133e <vTaskSuspend+0x8e>
    1334:	10 92 f3 07 	sts	0x07F3, r1	; 0x8007f3 <pxCurrentTCB+0x1>
    1338:	10 92 f2 07 	sts	0x07F2, r1	; 0x8007f2 <pxCurrentTCB>
    133c:	02 c0       	rjmp	.+4      	; 0x1342 <vTaskSuspend+0x92>
    133e:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <vTaskSwitchContext>
    1342:	df 91       	pop	r29
    1344:	cf 91       	pop	r28
    1346:	1f 91       	pop	r17
    1348:	0f 91       	pop	r16
    134a:	08 95       	ret

0000134c <vTaskPlaceOnEventList>:
    134c:	cf 93       	push	r28
    134e:	df 93       	push	r29
    1350:	eb 01       	movw	r28, r22
    1352:	60 91 f2 07 	lds	r22, 0x07F2	; 0x8007f2 <pxCurrentTCB>
    1356:	70 91 f3 07 	lds	r23, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
    135a:	64 5f       	subi	r22, 0xF4	; 244
    135c:	7f 4f       	sbci	r23, 0xFF	; 255
    135e:	0e 94 90 00 	call	0x120	; 0x120 <vListInsert>
    1362:	61 e0       	ldi	r22, 0x01	; 1
    1364:	ce 01       	movw	r24, r28
    1366:	0e 94 73 05 	call	0xae6	; 0xae6 <prvAddCurrentTaskToDelayedList>
    136a:	df 91       	pop	r29
    136c:	cf 91       	pop	r28
    136e:	08 95       	ret

00001370 <vTaskPlaceOnEventListRestricted>:
    1370:	0f 93       	push	r16
    1372:	1f 93       	push	r17
    1374:	cf 93       	push	r28
    1376:	8b 01       	movw	r16, r22
    1378:	c4 2f       	mov	r28, r20
    137a:	60 91 f2 07 	lds	r22, 0x07F2	; 0x8007f2 <pxCurrentTCB>
    137e:	70 91 f3 07 	lds	r23, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
    1382:	64 5f       	subi	r22, 0xF4	; 244
    1384:	7f 4f       	sbci	r23, 0xFF	; 255
    1386:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
    138a:	cc 23       	and	r28, r28
    138c:	11 f0       	breq	.+4      	; 0x1392 <vTaskPlaceOnEventListRestricted+0x22>
    138e:	0f ef       	ldi	r16, 0xFF	; 255
    1390:	1f ef       	ldi	r17, 0xFF	; 255
    1392:	6c 2f       	mov	r22, r28
    1394:	c8 01       	movw	r24, r16
    1396:	0e 94 73 05 	call	0xae6	; 0xae6 <prvAddCurrentTaskToDelayedList>
    139a:	cf 91       	pop	r28
    139c:	1f 91       	pop	r17
    139e:	0f 91       	pop	r16
    13a0:	08 95       	ret

000013a2 <xTaskRemoveFromEventList>:
    13a2:	0f 93       	push	r16
    13a4:	1f 93       	push	r17
    13a6:	cf 93       	push	r28
    13a8:	df 93       	push	r29
    13aa:	dc 01       	movw	r26, r24
    13ac:	15 96       	adiw	r26, 0x05	; 5
    13ae:	ed 91       	ld	r30, X+
    13b0:	fc 91       	ld	r31, X
    13b2:	16 97       	sbiw	r26, 0x06	; 6
    13b4:	c6 81       	ldd	r28, Z+6	; 0x06
    13b6:	d7 81       	ldd	r29, Z+7	; 0x07
    13b8:	8e 01       	movw	r16, r28
    13ba:	04 5f       	subi	r16, 0xF4	; 244
    13bc:	1f 4f       	sbci	r17, 0xFF	; 255
    13be:	c8 01       	movw	r24, r16
    13c0:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
    13c4:	80 91 8e 07 	lds	r24, 0x078E	; 0x80078e <uxSchedulerSuspended>
    13c8:	81 11       	cpse	r24, r1
    13ca:	1c c0       	rjmp	.+56     	; 0x1404 <xTaskRemoveFromEventList+0x62>
    13cc:	0a 50       	subi	r16, 0x0A	; 10
    13ce:	11 09       	sbc	r17, r1
    13d0:	c8 01       	movw	r24, r16
    13d2:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
    13d6:	8e 89       	ldd	r24, Y+22	; 0x16
    13d8:	90 91 98 07 	lds	r25, 0x0798	; 0x800798 <uxTopReadyPriority>
    13dc:	98 17       	cp	r25, r24
    13de:	10 f4       	brcc	.+4      	; 0x13e4 <xTaskRemoveFromEventList+0x42>
    13e0:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <uxTopReadyPriority>
    13e4:	90 e0       	ldi	r25, 0x00	; 0
    13e6:	9c 01       	movw	r18, r24
    13e8:	22 0f       	add	r18, r18
    13ea:	33 1f       	adc	r19, r19
    13ec:	22 0f       	add	r18, r18
    13ee:	33 1f       	adc	r19, r19
    13f0:	22 0f       	add	r18, r18
    13f2:	33 1f       	adc	r19, r19
    13f4:	82 0f       	add	r24, r18
    13f6:	93 1f       	adc	r25, r19
    13f8:	b8 01       	movw	r22, r16
    13fa:	82 53       	subi	r24, 0x32	; 50
    13fc:	98 4f       	sbci	r25, 0xF8	; 248
    13fe:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
    1402:	05 c0       	rjmp	.+10     	; 0x140e <xTaskRemoveFromEventList+0x6c>
    1404:	b8 01       	movw	r22, r16
    1406:	8f ea       	ldi	r24, 0xAF	; 175
    1408:	97 e0       	ldi	r25, 0x07	; 7
    140a:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
    140e:	e0 91 f2 07 	lds	r30, 0x07F2	; 0x8007f2 <pxCurrentTCB>
    1412:	f0 91 f3 07 	lds	r31, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
    1416:	9e 89       	ldd	r25, Y+22	; 0x16
    1418:	86 89       	ldd	r24, Z+22	; 0x16
    141a:	89 17       	cp	r24, r25
    141c:	20 f4       	brcc	.+8      	; 0x1426 <xTaskRemoveFromEventList+0x84>
    141e:	81 e0       	ldi	r24, 0x01	; 1
    1420:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <xYieldPending>
    1424:	01 c0       	rjmp	.+2      	; 0x1428 <xTaskRemoveFromEventList+0x86>
    1426:	80 e0       	ldi	r24, 0x00	; 0
    1428:	df 91       	pop	r29
    142a:	cf 91       	pop	r28
    142c:	1f 91       	pop	r17
    142e:	0f 91       	pop	r16
    1430:	08 95       	ret

00001432 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1432:	20 91 94 07 	lds	r18, 0x0794	; 0x800794 <xNumOfOverflows>
    1436:	fc 01       	movw	r30, r24
    1438:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    143a:	20 91 99 07 	lds	r18, 0x0799	; 0x800799 <xTickCount>
    143e:	30 91 9a 07 	lds	r19, 0x079A	; 0x80079a <xTickCount+0x1>
    1442:	32 83       	std	Z+2, r19	; 0x02
    1444:	21 83       	std	Z+1, r18	; 0x01
    1446:	08 95       	ret

00001448 <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1448:	0f b6       	in	r0, 0x3f	; 63
    144a:	f8 94       	cli
    144c:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    144e:	40 91 99 07 	lds	r20, 0x0799	; 0x800799 <xTickCount>
    1452:	50 91 9a 07 	lds	r21, 0x079A	; 0x80079a <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    1456:	db 01       	movw	r26, r22
    1458:	2d 91       	ld	r18, X+
    145a:	3c 91       	ld	r19, X
    145c:	2f 3f       	cpi	r18, 0xFF	; 255
    145e:	bf ef       	ldi	r27, 0xFF	; 255
    1460:	3b 07       	cpc	r19, r27
    1462:	19 f1       	breq	.+70     	; 0x14aa <xTaskCheckForTimeOut+0x62>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1464:	e0 91 94 07 	lds	r30, 0x0794	; 0x800794 <xNumOfOverflows>
    1468:	dc 01       	movw	r26, r24
    146a:	fc 91       	ld	r31, X
    146c:	fe 17       	cp	r31, r30
    146e:	39 f0       	breq	.+14     	; 0x147e <xTaskCheckForTimeOut+0x36>
    1470:	11 96       	adiw	r26, 0x01	; 1
    1472:	ed 91       	ld	r30, X+
    1474:	fc 91       	ld	r31, X
    1476:	12 97       	sbiw	r26, 0x02	; 2
    1478:	4e 17       	cp	r20, r30
    147a:	5f 07       	cpc	r21, r31
    147c:	c0 f4       	brcc	.+48     	; 0x14ae <xTaskCheckForTimeOut+0x66>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    147e:	dc 01       	movw	r26, r24
    1480:	11 96       	adiw	r26, 0x01	; 1
    1482:	ed 91       	ld	r30, X+
    1484:	fc 91       	ld	r31, X
    1486:	12 97       	sbiw	r26, 0x02	; 2
    1488:	da 01       	movw	r26, r20
    148a:	ae 1b       	sub	r26, r30
    148c:	bf 0b       	sbc	r27, r31
    148e:	a2 17       	cp	r26, r18
    1490:	b3 07       	cpc	r27, r19
    1492:	78 f4       	brcc	.+30     	; 0x14b2 <xTaskCheckForTimeOut+0x6a>
    1494:	db 01       	movw	r26, r22
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    1496:	e4 1b       	sub	r30, r20
    1498:	f5 0b       	sbc	r31, r21
    149a:	2e 0f       	add	r18, r30
    149c:	3f 1f       	adc	r19, r31
    149e:	2d 93       	st	X+, r18
    14a0:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    14a2:	0e 94 19 0a 	call	0x1432	; 0x1432 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    14a6:	80 e0       	ldi	r24, 0x00	; 0
    14a8:	05 c0       	rjmp	.+10     	; 0x14b4 <xTaskCheckForTimeOut+0x6c>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    14aa:	80 e0       	ldi	r24, 0x00	; 0
    14ac:	03 c0       	rjmp	.+6      	; 0x14b4 <xTaskCheckForTimeOut+0x6c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    14ae:	81 e0       	ldi	r24, 0x01	; 1
    14b0:	01 c0       	rjmp	.+2      	; 0x14b4 <xTaskCheckForTimeOut+0x6c>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    14b2:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    14b4:	0f 90       	pop	r0
    14b6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    14b8:	08 95       	ret

000014ba <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    14ba:	81 e0       	ldi	r24, 0x01	; 1
    14bc:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <xYieldPending>
    14c0:	08 95       	ret

000014c2 <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    14c2:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <xSchedulerRunning>
    14c6:	88 23       	and	r24, r24
    14c8:	31 f0       	breq	.+12     	; 0x14d6 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    14ca:	80 91 8e 07 	lds	r24, 0x078E	; 0x80078e <uxSchedulerSuspended>
    14ce:	88 23       	and	r24, r24
    14d0:	21 f0       	breq	.+8      	; 0x14da <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    14d2:	80 e0       	ldi	r24, 0x00	; 0
    14d4:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    14d6:	81 e0       	ldi	r24, 0x01	; 1
    14d8:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    14da:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    14dc:	08 95       	ret

000014de <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    14de:	fc 01       	movw	r30, r24
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    14e0:	73 83       	std	Z+3, r23	; 0x03
    14e2:	62 83       	std	Z+2, r22	; 0x02
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    14e4:	91 87       	std	Z+9, r25	; 0x09
    14e6:	80 87       	std	Z+8, r24	; 0x08

	if( xNextExpiryTime <= xTimeNow )
    14e8:	46 17       	cp	r20, r22
    14ea:	57 07       	cpc	r21, r23
    14ec:	90 f0       	brcs	.+36     	; 0x1512 <prvInsertTimerInActiveList+0x34>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    14ee:	42 1b       	sub	r20, r18
    14f0:	53 0b       	sbc	r21, r19
    14f2:	84 85       	ldd	r24, Z+12	; 0x0c
    14f4:	95 85       	ldd	r25, Z+13	; 0x0d
    14f6:	48 17       	cp	r20, r24
    14f8:	59 07       	cpc	r21, r25
    14fa:	e0 f4       	brcc	.+56     	; 0x1534 <prvInsertTimerInActiveList+0x56>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    14fc:	bf 01       	movw	r22, r30
    14fe:	6e 5f       	subi	r22, 0xFE	; 254
    1500:	7f 4f       	sbci	r23, 0xFF	; 255
    1502:	80 91 fa 07 	lds	r24, 0x07FA	; 0x8007fa <pxOverflowTimerList>
    1506:	90 91 fb 07 	lds	r25, 0x07FB	; 0x8007fb <pxOverflowTimerList+0x1>
    150a:	0e 94 90 00 	call	0x120	; 0x120 <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    150e:	80 e0       	ldi	r24, 0x00	; 0
    1510:	08 95       	ret
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    1512:	42 17       	cp	r20, r18
    1514:	53 07       	cpc	r21, r19
    1516:	18 f4       	brcc	.+6      	; 0x151e <prvInsertTimerInActiveList+0x40>
    1518:	62 17       	cp	r22, r18
    151a:	73 07       	cpc	r23, r19
    151c:	68 f4       	brcc	.+26     	; 0x1538 <prvInsertTimerInActiveList+0x5a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    151e:	bf 01       	movw	r22, r30
    1520:	6e 5f       	subi	r22, 0xFE	; 254
    1522:	7f 4f       	sbci	r23, 0xFF	; 255
    1524:	80 91 fc 07 	lds	r24, 0x07FC	; 0x8007fc <pxCurrentTimerList>
    1528:	90 91 fd 07 	lds	r25, 0x07FD	; 0x8007fd <pxCurrentTimerList+0x1>
    152c:	0e 94 90 00 	call	0x120	; 0x120 <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    1530:	80 e0       	ldi	r24, 0x00	; 0
    1532:	08 95       	ret
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    1534:	81 e0       	ldi	r24, 0x01	; 1
    1536:	08 95       	ret
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    1538:	81 e0       	ldi	r24, 0x01	; 1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
    153a:	08 95       	ret

0000153c <prvCheckForValidListAndQueue>:
static void prvCheckForValidListAndQueue( void )
{
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    153c:	0f b6       	in	r0, 0x3f	; 63
    153e:	f8 94       	cli
    1540:	0f 92       	push	r0
	{
		if( xTimerQueue == NULL )
    1542:	80 91 f8 07 	lds	r24, 0x07F8	; 0x8007f8 <xTimerQueue>
    1546:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <xTimerQueue+0x1>
    154a:	89 2b       	or	r24, r25
    154c:	19 f5       	brne	.+70     	; 0x1594 <prvCheckForValidListAndQueue+0x58>
		{
			vListInitialise( &xActiveTimerList1 );
    154e:	87 e0       	ldi	r24, 0x07	; 7
    1550:	98 e0       	ldi	r25, 0x08	; 8
    1552:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
    1556:	8e ef       	ldi	r24, 0xFE	; 254
    1558:	97 e0       	ldi	r25, 0x07	; 7
    155a:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
    155e:	87 e0       	ldi	r24, 0x07	; 7
    1560:	98 e0       	ldi	r25, 0x08	; 8
    1562:	90 93 fd 07 	sts	0x07FD, r25	; 0x8007fd <pxCurrentTimerList+0x1>
    1566:	80 93 fc 07 	sts	0x07FC, r24	; 0x8007fc <pxCurrentTimerList>
			pxOverflowTimerList = &xActiveTimerList2;
    156a:	8e ef       	ldi	r24, 0xFE	; 254
    156c:	97 e0       	ldi	r25, 0x07	; 7
    156e:	90 93 fb 07 	sts	0x07FB, r25	; 0x8007fb <pxOverflowTimerList+0x1>
    1572:	80 93 fa 07 	sts	0x07FA, r24	; 0x8007fa <pxOverflowTimerList>

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
			}
			#else
			{
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    1576:	40 e0       	ldi	r20, 0x00	; 0
    1578:	65 e0       	ldi	r22, 0x05	; 5
    157a:	85 e0       	ldi	r24, 0x05	; 5
    157c:	0e 94 6d 03 	call	0x6da	; 0x6da <xQueueGenericCreate>
    1580:	90 93 f9 07 	sts	0x07F9, r25	; 0x8007f9 <xTimerQueue+0x1>
    1584:	80 93 f8 07 	sts	0x07F8, r24	; 0x8007f8 <xTimerQueue>
			}
			#endif

			#if ( configQUEUE_REGISTRY_SIZE > 0 )
			{
				if( xTimerQueue != NULL )
    1588:	00 97       	sbiw	r24, 0x00	; 0
    158a:	21 f0       	breq	.+8      	; 0x1594 <prvCheckForValidListAndQueue+0x58>
				{
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
    158c:	65 e0       	ldi	r22, 0x05	; 5
    158e:	71 e0       	ldi	r23, 0x01	; 1
    1590:	0e 94 2a 05 	call	0xa54	; 0xa54 <vQueueAddToRegistry>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    1594:	0f 90       	pop	r0
    1596:	0f be       	out	0x3f, r0	; 63
    1598:	08 95       	ret

0000159a <xTimerCreateTimerTask>:
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
    159a:	ef 92       	push	r14
    159c:	ff 92       	push	r15
    159e:	0f 93       	push	r16

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
    15a0:	0e 94 9e 0a 	call	0x153c	; 0x153c <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
    15a4:	80 91 f8 07 	lds	r24, 0x07F8	; 0x8007f8 <xTimerQueue>
    15a8:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <xTimerQueue+0x1>
    15ac:	89 2b       	or	r24, r25
    15ae:	91 f0       	breq	.+36     	; 0x15d4 <xTimerCreateTimerTask+0x3a>
				xReturn = pdPASS;
			}
		}
		#else
		{
			xReturn = xTaskCreate(	prvTimerTask,
    15b0:	0f 2e       	mov	r0, r31
    15b2:	f6 ef       	ldi	r31, 0xF6	; 246
    15b4:	ef 2e       	mov	r14, r31
    15b6:	f7 e0       	ldi	r31, 0x07	; 7
    15b8:	ff 2e       	mov	r15, r31
    15ba:	f0 2d       	mov	r31, r0
    15bc:	02 e0       	ldi	r16, 0x02	; 2
    15be:	20 e0       	ldi	r18, 0x00	; 0
    15c0:	30 e0       	ldi	r19, 0x00	; 0
    15c2:	45 e5       	ldi	r20, 0x55	; 85
    15c4:	50 e0       	ldi	r21, 0x00	; 0
    15c6:	6a e0       	ldi	r22, 0x0A	; 10
    15c8:	71 e0       	ldi	r23, 0x01	; 1
    15ca:	89 ed       	ldi	r24, 0xD9	; 217
    15cc:	9b e0       	ldi	r25, 0x0B	; 11
    15ce:	0e 94 cb 05 	call	0xb96	; 0xb96 <xTaskCreate>
    15d2:	01 c0       	rjmp	.+2      	; 0x15d6 <xTimerCreateTimerTask+0x3c>
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
BaseType_t xReturn = pdFAIL;
    15d4:	80 e0       	ldi	r24, 0x00	; 0
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
	return xReturn;
}
    15d6:	0f 91       	pop	r16
    15d8:	ff 90       	pop	r15
    15da:	ef 90       	pop	r14
    15dc:	08 95       	ret

000015de <xTimerCreate>:
	TimerHandle_t xTimerCreate(	const char * const pcTimerName,
								const TickType_t xTimerPeriodInTicks,
								const UBaseType_t uxAutoReload,
								void * const pvTimerID,
								TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    15de:	9f 92       	push	r9
    15e0:	af 92       	push	r10
    15e2:	bf 92       	push	r11
    15e4:	cf 92       	push	r12
    15e6:	df 92       	push	r13
    15e8:	ef 92       	push	r14
    15ea:	ff 92       	push	r15
    15ec:	0f 93       	push	r16
    15ee:	1f 93       	push	r17
    15f0:	cf 93       	push	r28
    15f2:	df 93       	push	r29
    15f4:	5c 01       	movw	r10, r24
    15f6:	6b 01       	movw	r12, r22
    15f8:	94 2e       	mov	r9, r20
    15fa:	79 01       	movw	r14, r18
	Timer_t *pxNewTimer;

		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
    15fc:	83 e1       	ldi	r24, 0x13	; 19
    15fe:	90 e0       	ldi	r25, 0x00	; 0
    1600:	0e 94 e7 00 	call	0x1ce	; 0x1ce <pvPortMalloc>
    1604:	ec 01       	movw	r28, r24
									Timer_t *pxNewTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	if( pxNewTimer != NULL )
    1606:	89 2b       	or	r24, r25
    1608:	79 f0       	breq	.+30     	; 0x1628 <xTimerCreate+0x4a>
	{
		/* Ensure the infrastructure used by the timer service task has been
		created/initialised. */
		prvCheckForValidListAndQueue();
    160a:	0e 94 9e 0a 	call	0x153c	; 0x153c <prvCheckForValidListAndQueue>

		/* Initialise the timer structure members using the function
		parameters. */
		pxNewTimer->pcTimerName = pcTimerName;
    160e:	b9 82       	std	Y+1, r11	; 0x01
    1610:	a8 82       	st	Y, r10
		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    1612:	dd 86       	std	Y+13, r13	; 0x0d
    1614:	cc 86       	std	Y+12, r12	; 0x0c
		pxNewTimer->uxAutoReload = uxAutoReload;
    1616:	9e 86       	std	Y+14, r9	; 0x0e
		pxNewTimer->pvTimerID = pvTimerID;
    1618:	f8 8a       	std	Y+16, r15	; 0x10
    161a:	ef 86       	std	Y+15, r14	; 0x0f
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    161c:	1a 8b       	std	Y+18, r17	; 0x12
    161e:	09 8b       	std	Y+17, r16	; 0x11
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    1620:	ce 01       	movw	r24, r28
    1622:	02 96       	adiw	r24, 0x02	; 2
    1624:	0e 94 6b 00 	call	0xd6	; 0xd6 <vListInitialiseItem>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */
		}

		return pxNewTimer;
	}
    1628:	ce 01       	movw	r24, r28
    162a:	df 91       	pop	r29
    162c:	cf 91       	pop	r28
    162e:	1f 91       	pop	r17
    1630:	0f 91       	pop	r16
    1632:	ff 90       	pop	r15
    1634:	ef 90       	pop	r14
    1636:	df 90       	pop	r13
    1638:	cf 90       	pop	r12
    163a:	bf 90       	pop	r11
    163c:	af 90       	pop	r10
    163e:	9f 90       	pop	r9
    1640:	08 95       	ret

00001642 <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    1642:	0f 93       	push	r16
    1644:	1f 93       	push	r17
    1646:	cf 93       	push	r28
    1648:	df 93       	push	r29
    164a:	00 d0       	rcall	.+0      	; 0x164c <xTimerGenericCommand+0xa>
    164c:	00 d0       	rcall	.+0      	; 0x164e <xTimerGenericCommand+0xc>
    164e:	1f 92       	push	r1
    1650:	cd b7       	in	r28, 0x3d	; 61
    1652:	de b7       	in	r29, 0x3e	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    1654:	e0 91 f8 07 	lds	r30, 0x07F8	; 0x8007f8 <xTimerQueue>
    1658:	f0 91 f9 07 	lds	r31, 0x07F9	; 0x8007f9 <xTimerQueue+0x1>
    165c:	30 97       	sbiw	r30, 0x00	; 0
    165e:	71 f1       	breq	.+92     	; 0x16bc <xTimerGenericCommand+0x7a>
    1660:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    1662:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    1664:	5b 83       	std	Y+3, r21	; 0x03
    1666:	4a 83       	std	Y+2, r20	; 0x02
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    1668:	9d 83       	std	Y+5, r25	; 0x05
    166a:	8c 83       	std	Y+4, r24	; 0x04

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    166c:	66 30       	cpi	r22, 0x06	; 6
    166e:	ec f4       	brge	.+58     	; 0x16aa <xTimerGenericCommand+0x68>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    1670:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <xTaskGetSchedulerState>
    1674:	82 30       	cpi	r24, 0x02	; 2
    1676:	61 f4       	brne	.+24     	; 0x1690 <xTimerGenericCommand+0x4e>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    1678:	20 e0       	ldi	r18, 0x00	; 0
    167a:	a8 01       	movw	r20, r16
    167c:	be 01       	movw	r22, r28
    167e:	6f 5f       	subi	r22, 0xFF	; 255
    1680:	7f 4f       	sbci	r23, 0xFF	; 255
    1682:	80 91 f8 07 	lds	r24, 0x07F8	; 0x8007f8 <xTimerQueue>
    1686:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <xTimerQueue+0x1>
    168a:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
    168e:	17 c0       	rjmp	.+46     	; 0x16be <xTimerGenericCommand+0x7c>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    1690:	20 e0       	ldi	r18, 0x00	; 0
    1692:	40 e0       	ldi	r20, 0x00	; 0
    1694:	50 e0       	ldi	r21, 0x00	; 0
    1696:	be 01       	movw	r22, r28
    1698:	6f 5f       	subi	r22, 0xFF	; 255
    169a:	7f 4f       	sbci	r23, 0xFF	; 255
    169c:	80 91 f8 07 	lds	r24, 0x07F8	; 0x8007f8 <xTimerQueue>
    16a0:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <xTimerQueue+0x1>
    16a4:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
    16a8:	0a c0       	rjmp	.+20     	; 0x16be <xTimerGenericCommand+0x7c>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    16aa:	20 e0       	ldi	r18, 0x00	; 0
    16ac:	ad 01       	movw	r20, r26
    16ae:	be 01       	movw	r22, r28
    16b0:	6f 5f       	subi	r22, 0xFF	; 255
    16b2:	7f 4f       	sbci	r23, 0xFF	; 255
    16b4:	cf 01       	movw	r24, r30
    16b6:	0e 94 3b 04 	call	0x876	; 0x876 <xQueueGenericSendFromISR>
    16ba:	01 c0       	rjmp	.+2      	; 0x16be <xTimerGenericCommand+0x7c>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    16bc:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    16be:	0f 90       	pop	r0
    16c0:	0f 90       	pop	r0
    16c2:	0f 90       	pop	r0
    16c4:	0f 90       	pop	r0
    16c6:	0f 90       	pop	r0
    16c8:	df 91       	pop	r29
    16ca:	cf 91       	pop	r28
    16cc:	1f 91       	pop	r17
    16ce:	0f 91       	pop	r16
    16d0:	08 95       	ret

000016d2 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    16d2:	af 92       	push	r10
    16d4:	bf 92       	push	r11
    16d6:	cf 92       	push	r12
    16d8:	df 92       	push	r13
    16da:	ef 92       	push	r14
    16dc:	ff 92       	push	r15
    16de:	0f 93       	push	r16
    16e0:	1f 93       	push	r17
    16e2:	cf 93       	push	r28
    16e4:	df 93       	push	r29
    16e6:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    16e8:	0e 94 5b 07 	call	0xeb6	; 0xeb6 <xTaskGetTickCount>
    16ec:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    16ee:	80 91 f4 07 	lds	r24, 0x07F4	; 0x8007f4 <xLastTime.2351>
    16f2:	90 91 f5 07 	lds	r25, 0x07F5	; 0x8007f5 <xLastTime.2351+0x1>
    16f6:	e8 16       	cp	r14, r24
    16f8:	f9 06       	cpc	r15, r25
    16fa:	08 f0       	brcs	.+2      	; 0x16fe <prvSampleTimeNow+0x2c>
    16fc:	48 c0       	rjmp	.+144    	; 0x178e <prvSampleTimeNow+0xbc>
    16fe:	30 c0       	rjmp	.+96     	; 0x1760 <prvSampleTimeNow+0x8e>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1700:	05 80       	ldd	r0, Z+5	; 0x05
    1702:	f6 81       	ldd	r31, Z+6	; 0x06
    1704:	e0 2d       	mov	r30, r0
    1706:	a0 80       	ld	r10, Z
    1708:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    170a:	c6 81       	ldd	r28, Z+6	; 0x06
    170c:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    170e:	8e 01       	movw	r16, r28
    1710:	0e 5f       	subi	r16, 0xFE	; 254
    1712:	1f 4f       	sbci	r17, 0xFF	; 255
    1714:	c8 01       	movw	r24, r16
    1716:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    171a:	e9 89       	ldd	r30, Y+17	; 0x11
    171c:	fa 89       	ldd	r31, Y+18	; 0x12
    171e:	ce 01       	movw	r24, r28
    1720:	09 95       	icall

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1722:	8e 85       	ldd	r24, Y+14	; 0x0e
    1724:	81 30       	cpi	r24, 0x01	; 1
    1726:	e1 f4       	brne	.+56     	; 0x1760 <prvSampleTimeNow+0x8e>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    1728:	8c 85       	ldd	r24, Y+12	; 0x0c
    172a:	9d 85       	ldd	r25, Y+13	; 0x0d
    172c:	8a 0d       	add	r24, r10
    172e:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    1730:	a8 16       	cp	r10, r24
    1732:	b9 06       	cpc	r11, r25
    1734:	60 f4       	brcc	.+24     	; 0x174e <prvSampleTimeNow+0x7c>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    1736:	9b 83       	std	Y+3, r25	; 0x03
    1738:	8a 83       	std	Y+2, r24	; 0x02
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    173a:	d9 87       	std	Y+9, r29	; 0x09
    173c:	c8 87       	std	Y+8, r28	; 0x08
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    173e:	b8 01       	movw	r22, r16
    1740:	80 91 fc 07 	lds	r24, 0x07FC	; 0x8007fc <pxCurrentTimerList>
    1744:	90 91 fd 07 	lds	r25, 0x07FD	; 0x8007fd <pxCurrentTimerList+0x1>
    1748:	0e 94 90 00 	call	0x120	; 0x120 <vListInsert>
    174c:	09 c0       	rjmp	.+18     	; 0x1760 <prvSampleTimeNow+0x8e>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    174e:	00 e0       	ldi	r16, 0x00	; 0
    1750:	10 e0       	ldi	r17, 0x00	; 0
    1752:	20 e0       	ldi	r18, 0x00	; 0
    1754:	30 e0       	ldi	r19, 0x00	; 0
    1756:	a5 01       	movw	r20, r10
    1758:	60 e0       	ldi	r22, 0x00	; 0
    175a:	ce 01       	movw	r24, r28
    175c:	0e 94 21 0b 	call	0x1642	; 0x1642 <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    1760:	e0 91 fc 07 	lds	r30, 0x07FC	; 0x8007fc <pxCurrentTimerList>
    1764:	f0 91 fd 07 	lds	r31, 0x07FD	; 0x8007fd <pxCurrentTimerList+0x1>
    1768:	80 81       	ld	r24, Z
    176a:	81 11       	cpse	r24, r1
    176c:	c9 cf       	rjmp	.-110    	; 0x1700 <prvSampleTimeNow+0x2e>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    176e:	80 91 fa 07 	lds	r24, 0x07FA	; 0x8007fa <pxOverflowTimerList>
    1772:	90 91 fb 07 	lds	r25, 0x07FB	; 0x8007fb <pxOverflowTimerList+0x1>
    1776:	90 93 fd 07 	sts	0x07FD, r25	; 0x8007fd <pxCurrentTimerList+0x1>
    177a:	80 93 fc 07 	sts	0x07FC, r24	; 0x8007fc <pxCurrentTimerList>
	pxOverflowTimerList = pxTemp;
    177e:	f0 93 fb 07 	sts	0x07FB, r31	; 0x8007fb <pxOverflowTimerList+0x1>
    1782:	e0 93 fa 07 	sts	0x07FA, r30	; 0x8007fa <pxOverflowTimerList>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    1786:	81 e0       	ldi	r24, 0x01	; 1
    1788:	f6 01       	movw	r30, r12
    178a:	80 83       	st	Z, r24
    178c:	02 c0       	rjmp	.+4      	; 0x1792 <prvSampleTimeNow+0xc0>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    178e:	f6 01       	movw	r30, r12
    1790:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    1792:	f0 92 f5 07 	sts	0x07F5, r15	; 0x8007f5 <xLastTime.2351+0x1>
    1796:	e0 92 f4 07 	sts	0x07F4, r14	; 0x8007f4 <xLastTime.2351>

	return xTimeNow;
}
    179a:	c7 01       	movw	r24, r14
    179c:	df 91       	pop	r29
    179e:	cf 91       	pop	r28
    17a0:	1f 91       	pop	r17
    17a2:	0f 91       	pop	r16
    17a4:	ff 90       	pop	r15
    17a6:	ef 90       	pop	r14
    17a8:	df 90       	pop	r13
    17aa:	cf 90       	pop	r12
    17ac:	bf 90       	pop	r11
    17ae:	af 90       	pop	r10
    17b0:	08 95       	ret

000017b2 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    17b2:	cf 93       	push	r28
    17b4:	df 93       	push	r29
    17b6:	00 d0       	rcall	.+0      	; 0x17b8 <prvTimerTask+0x6>
    17b8:	00 d0       	rcall	.+0      	; 0x17ba <prvTimerTask+0x8>
    17ba:	00 d0       	rcall	.+0      	; 0x17bc <prvTimerTask+0xa>
    17bc:	cd b7       	in	r28, 0x3d	; 61
    17be:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    17c0:	ce 01       	movw	r24, r28
    17c2:	01 96       	adiw	r24, 0x01	; 1
    17c4:	4c 01       	movw	r8, r24
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    17c6:	44 24       	eor	r4, r4
    17c8:	43 94       	inc	r4
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    17ca:	d1 2c       	mov	r13, r1
    17cc:	e1 2c       	mov	r14, r1
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    17ce:	f1 2c       	mov	r15, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    17d0:	58 2e       	mov	r5, r24
    17d2:	c9 2c       	mov	r12, r9
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    17d4:	e0 91 fc 07 	lds	r30, 0x07FC	; 0x8007fc <pxCurrentTimerList>
    17d8:	f0 91 fd 07 	lds	r31, 0x07FD	; 0x8007fd <pxCurrentTimerList+0x1>
	if( *pxListWasEmpty == pdFALSE )
    17dc:	80 81       	ld	r24, Z
    17de:	88 23       	and	r24, r24
    17e0:	09 f4       	brne	.+2      	; 0x17e4 <prvTimerTask+0x32>
    17e2:	c3 c0       	rjmp	.+390    	; 0x196a <prvTimerTask+0x1b8>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    17e4:	05 80       	ldd	r0, Z+5	; 0x05
    17e6:	f6 81       	ldd	r31, Z+6	; 0x06
    17e8:	e0 2d       	mov	r30, r0
    17ea:	a0 80       	ld	r10, Z
    17ec:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    17ee:	0e 94 55 07 	call	0xeaa	; 0xeaa <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    17f2:	c4 01       	movw	r24, r8
    17f4:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <prvSampleTimeNow>
    17f8:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    17fa:	89 81       	ldd	r24, Y+1	; 0x01
    17fc:	81 11       	cpse	r24, r1
    17fe:	47 c0       	rjmp	.+142    	; 0x188e <prvTimerTask+0xdc>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    1800:	0a 15       	cp	r16, r10
    1802:	1b 05       	cpc	r17, r11
    1804:	98 f1       	brcs	.+102    	; 0x186c <prvTimerTask+0xba>
			{
				( void ) xTaskResumeAll();
    1806:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    180a:	e0 91 fc 07 	lds	r30, 0x07FC	; 0x8007fc <pxCurrentTimerList>
    180e:	f0 91 fd 07 	lds	r31, 0x07FD	; 0x8007fd <pxCurrentTimerList+0x1>
    1812:	05 80       	ldd	r0, Z+5	; 0x05
    1814:	f6 81       	ldd	r31, Z+6	; 0x06
    1816:	e0 2d       	mov	r30, r0
    1818:	66 80       	ldd	r6, Z+6	; 0x06
    181a:	77 80       	ldd	r7, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    181c:	c3 01       	movw	r24, r6
    181e:	02 96       	adiw	r24, 0x02	; 2
    1820:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1824:	d3 01       	movw	r26, r6
    1826:	1e 96       	adiw	r26, 0x0e	; 14
    1828:	8c 91       	ld	r24, X
    182a:	1e 97       	sbiw	r26, 0x0e	; 14
    182c:	81 30       	cpi	r24, 0x01	; 1
    182e:	b1 f4       	brne	.+44     	; 0x185c <prvTimerTask+0xaa>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    1830:	1c 96       	adiw	r26, 0x0c	; 12
    1832:	6d 91       	ld	r22, X+
    1834:	7c 91       	ld	r23, X
    1836:	1d 97       	sbiw	r26, 0x0d	; 13
    1838:	6a 0d       	add	r22, r10
    183a:	7b 1d       	adc	r23, r11
    183c:	95 01       	movw	r18, r10
    183e:	a8 01       	movw	r20, r16
    1840:	c3 01       	movw	r24, r6
    1842:	0e 94 6f 0a 	call	0x14de	; 0x14de <prvInsertTimerInActiveList>
    1846:	88 23       	and	r24, r24
    1848:	49 f0       	breq	.+18     	; 0x185c <prvTimerTask+0xaa>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    184a:	0d 2d       	mov	r16, r13
    184c:	1e 2d       	mov	r17, r14
    184e:	2d 2d       	mov	r18, r13
    1850:	3e 2d       	mov	r19, r14
    1852:	a5 01       	movw	r20, r10
    1854:	6f 2d       	mov	r22, r15
    1856:	c3 01       	movw	r24, r6
    1858:	0e 94 21 0b 	call	0x1642	; 0x1642 <xTimerGenericCommand>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    185c:	d3 01       	movw	r26, r6
    185e:	51 96       	adiw	r26, 0x11	; 17
    1860:	ed 91       	ld	r30, X+
    1862:	fc 91       	ld	r31, X
    1864:	52 97       	sbiw	r26, 0x12	; 18
    1866:	c3 01       	movw	r24, r6
    1868:	09 95       	icall
    186a:	71 c0       	rjmp	.+226    	; 0x194e <prvTimerTask+0x19c>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    186c:	4f 2d       	mov	r20, r15
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    186e:	b5 01       	movw	r22, r10
    1870:	60 1b       	sub	r22, r16
    1872:	71 0b       	sbc	r23, r17
    1874:	80 91 f8 07 	lds	r24, 0x07F8	; 0x8007f8 <xTimerQueue>
    1878:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <xTimerQueue+0x1>
    187c:	0e 94 37 05 	call	0xa6e	; 0xa6e <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    1880:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
    1884:	81 11       	cpse	r24, r1
    1886:	63 c0       	rjmp	.+198    	; 0x194e <prvTimerTask+0x19c>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    1888:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
    188c:	60 c0       	rjmp	.+192    	; 0x194e <prvTimerTask+0x19c>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    188e:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
    1892:	5d c0       	rjmp	.+186    	; 0x194e <prvTimerTask+0x19c>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    1894:	89 81       	ldd	r24, Y+1	; 0x01
    1896:	88 23       	and	r24, r24
    1898:	0c f4       	brge	.+2      	; 0x189c <prvTimerTask+0xea>
    189a:	59 c0       	rjmp	.+178    	; 0x194e <prvTimerTask+0x19c>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    189c:	ac 80       	ldd	r10, Y+4	; 0x04
    189e:	bd 80       	ldd	r11, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    18a0:	f5 01       	movw	r30, r10
    18a2:	82 85       	ldd	r24, Z+10	; 0x0a
    18a4:	93 85       	ldd	r25, Z+11	; 0x0b
    18a6:	89 2b       	or	r24, r25
    18a8:	21 f0       	breq	.+8      	; 0x18b2 <prvTimerTask+0x100>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    18aa:	c5 01       	movw	r24, r10
    18ac:	02 96       	adiw	r24, 0x02	; 2
    18ae:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    18b2:	ce 01       	movw	r24, r28
    18b4:	06 96       	adiw	r24, 0x06	; 6
    18b6:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <prvSampleTimeNow>

			switch( xMessage.xMessageID )
    18ba:	e9 81       	ldd	r30, Y+1	; 0x01
    18bc:	0e 2f       	mov	r16, r30
    18be:	ee 0f       	add	r30, r30
    18c0:	11 0b       	sbc	r17, r17
    18c2:	22 0b       	sbc	r18, r18
    18c4:	33 0b       	sbc	r19, r19
    18c6:	0a 30       	cpi	r16, 0x0A	; 10
    18c8:	11 05       	cpc	r17, r1
    18ca:	08 f0       	brcs	.+2      	; 0x18ce <prvTimerTask+0x11c>
    18cc:	40 c0       	rjmp	.+128    	; 0x194e <prvTimerTask+0x19c>
    18ce:	f8 01       	movw	r30, r16
    18d0:	ec 5c       	subi	r30, 0xCC	; 204
    18d2:	ff 4f       	sbci	r31, 0xFF	; 255
    18d4:	0c 94 7f 15 	jmp	0x2afe	; 0x2afe <__tablejump2__>
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    18d8:	2a 81       	ldd	r18, Y+2	; 0x02
    18da:	3b 81       	ldd	r19, Y+3	; 0x03
    18dc:	d5 01       	movw	r26, r10
    18de:	1c 96       	adiw	r26, 0x0c	; 12
    18e0:	6d 91       	ld	r22, X+
    18e2:	7c 91       	ld	r23, X
    18e4:	1d 97       	sbiw	r26, 0x0d	; 13
    18e6:	62 0f       	add	r22, r18
    18e8:	73 1f       	adc	r23, r19
    18ea:	ac 01       	movw	r20, r24
    18ec:	c5 01       	movw	r24, r10
    18ee:	0e 94 6f 0a 	call	0x14de	; 0x14de <prvInsertTimerInActiveList>
    18f2:	88 23       	and	r24, r24
    18f4:	61 f1       	breq	.+88     	; 0x194e <prvTimerTask+0x19c>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    18f6:	d5 01       	movw	r26, r10
    18f8:	51 96       	adiw	r26, 0x11	; 17
    18fa:	ed 91       	ld	r30, X+
    18fc:	fc 91       	ld	r31, X
    18fe:	52 97       	sbiw	r26, 0x12	; 18
    1900:	c5 01       	movw	r24, r10
    1902:	09 95       	icall
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1904:	f5 01       	movw	r30, r10
    1906:	86 85       	ldd	r24, Z+14	; 0x0e
    1908:	81 30       	cpi	r24, 0x01	; 1
    190a:	09 f5       	brne	.+66     	; 0x194e <prvTimerTask+0x19c>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    190c:	4a 81       	ldd	r20, Y+2	; 0x02
    190e:	5b 81       	ldd	r21, Y+3	; 0x03
    1910:	84 85       	ldd	r24, Z+12	; 0x0c
    1912:	95 85       	ldd	r25, Z+13	; 0x0d
    1914:	48 0f       	add	r20, r24
    1916:	59 1f       	adc	r21, r25
    1918:	0d 2d       	mov	r16, r13
    191a:	1e 2d       	mov	r17, r14
    191c:	2d 2d       	mov	r18, r13
    191e:	3e 2d       	mov	r19, r14
    1920:	6f 2d       	mov	r22, r15
    1922:	c5 01       	movw	r24, r10
    1924:	0e 94 21 0b 	call	0x1642	; 0x1642 <xTimerGenericCommand>
    1928:	12 c0       	rjmp	.+36     	; 0x194e <prvTimerTask+0x19c>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    192a:	6a 81       	ldd	r22, Y+2	; 0x02
    192c:	7b 81       	ldd	r23, Y+3	; 0x03
    192e:	d5 01       	movw	r26, r10
    1930:	1d 96       	adiw	r26, 0x0d	; 13
    1932:	7c 93       	st	X, r23
    1934:	6e 93       	st	-X, r22
    1936:	1c 97       	sbiw	r26, 0x0c	; 12
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    1938:	68 0f       	add	r22, r24
    193a:	79 1f       	adc	r23, r25
    193c:	9c 01       	movw	r18, r24
    193e:	ac 01       	movw	r20, r24
    1940:	c5 01       	movw	r24, r10
    1942:	0e 94 6f 0a 	call	0x14de	; 0x14de <prvInsertTimerInActiveList>
    1946:	03 c0       	rjmp	.+6      	; 0x194e <prvTimerTask+0x19c>
					allocated. */
					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
					{
						/* The timer can only have been allocated dynamically -
						free it again. */
						vPortFree( pxTimer );
    1948:	c5 01       	movw	r24, r10
    194a:	0e 94 1c 01 	call	0x238	; 0x238 <vPortFree>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    194e:	2f 2d       	mov	r18, r15
    1950:	4d 2d       	mov	r20, r13
    1952:	5e 2d       	mov	r21, r14
    1954:	65 2d       	mov	r22, r5
    1956:	7c 2d       	mov	r23, r12
    1958:	80 91 f8 07 	lds	r24, 0x07F8	; 0x8007f8 <xTimerQueue>
    195c:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <xTimerQueue+0x1>
    1960:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    1964:	81 11       	cpse	r24, r1
    1966:	96 cf       	rjmp	.-212    	; 0x1894 <prvTimerTask+0xe2>
    1968:	35 cf       	rjmp	.-406    	; 0x17d4 <prvTimerTask+0x22>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    196a:	0e 94 55 07 	call	0xeaa	; 0xeaa <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    196e:	c4 01       	movw	r24, r8
    1970:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <prvSampleTimeNow>
    1974:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    1976:	89 81       	ldd	r24, Y+1	; 0x01
    1978:	81 11       	cpse	r24, r1
    197a:	89 cf       	rjmp	.-238    	; 0x188e <prvTimerTask+0xdc>
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    197c:	e0 91 fa 07 	lds	r30, 0x07FA	; 0x8007fa <pxOverflowTimerList>
    1980:	f0 91 fb 07 	lds	r31, 0x07FB	; 0x8007fb <pxOverflowTimerList+0x1>
    1984:	44 2d       	mov	r20, r4
    1986:	80 81       	ld	r24, Z
    1988:	81 11       	cpse	r24, r1
    198a:	4f 2d       	mov	r20, r15
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    198c:	ad 2c       	mov	r10, r13
    198e:	be 2c       	mov	r11, r14
    1990:	6e cf       	rjmp	.-292    	; 0x186e <prvTimerTask+0xbc>

00001992 <UART_sendChar>:
}

static void UART_sendChar(char data)
{
	//Wait for the transmission buffer is empty
	while (!(UCSR0A & (1 << UDRE0)));
    1992:	e0 ec       	ldi	r30, 0xC0	; 192
    1994:	f0 e0       	ldi	r31, 0x00	; 0
    1996:	90 81       	ld	r25, Z
    1998:	95 ff       	sbrs	r25, 5
    199a:	fd cf       	rjmp	.-6      	; 0x1996 <UART_sendChar+0x4>
	
	//Load the transmission buffer
	UDR0 = data;
    199c:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
    19a0:	08 95       	ret

000019a2 <ADC_read>:
	
}

static float ADC_read(){

	ADCSRA |= (1<<ADSC); //Start conversion
    19a2:	ea e7       	ldi	r30, 0x7A	; 122
    19a4:	f0 e0       	ldi	r31, 0x00	; 0
    19a6:	80 81       	ld	r24, Z
    19a8:	80 64       	ori	r24, 0x40	; 64
    19aa:	80 83       	st	Z, r24
	while ((ADCSRA&(1<<ADIF)) ==0); //wait for end of conversion
    19ac:	80 81       	ld	r24, Z
    19ae:	84 ff       	sbrs	r24, 4
    19b0:	fd cf       	rjmp	.-6      	; 0x19ac <ADC_read+0xa>
	ADCSRA |= (1<<ADIF); //clear the ADIF flag
    19b2:	ea e7       	ldi	r30, 0x7A	; 122
    19b4:	f0 e0       	ldi	r31, 0x00	; 0
    19b6:	80 81       	ld	r24, Z
    19b8:	80 61       	ori	r24, 0x10	; 16
    19ba:	80 83       	st	Z, r24

	return (ADCL+(ADCH<<8));
    19bc:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
    19c0:	60 91 79 00 	lds	r22, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
    19c4:	70 e0       	ldi	r23, 0x00	; 0
    19c6:	76 2f       	mov	r23, r22
    19c8:	66 27       	eor	r22, r22
    19ca:	68 0f       	add	r22, r24
    19cc:	71 1d       	adc	r23, r1
    19ce:	07 2e       	mov	r0, r23
    19d0:	00 0c       	add	r0, r0
    19d2:	88 0b       	sbc	r24, r24
    19d4:	99 0b       	sbc	r25, r25
    19d6:	0e 94 5d 14 	call	0x28ba	; 0x28ba <__floatsisf>
	//return ADC;
}
    19da:	08 95       	ret

000019dc <LCD_putValue>:
	UDR0 = data;
}

static void LCD_putValue(unsigned char val)
{
  LCD_DPRT &= 0x0F;
    19dc:	9b b1       	in	r25, 0x0b	; 11
    19de:	9f 70       	andi	r25, 0x0F	; 15
    19e0:	9b b9       	out	0x0b, r25	; 11
  LCD_DPRT |= (val&0xF0);     //send cmnd to data port
    19e2:	9b b1       	in	r25, 0x0b	; 11
    19e4:	28 2f       	mov	r18, r24
    19e6:	20 7f       	andi	r18, 0xF0	; 240
    19e8:	92 2b       	or	r25, r18
    19ea:	9b b9       	out	0x0b, r25	; 11
  LCD_CPRT |= (1<<LCD_EN);    //EN = 1 for H-to-L pulse
    19ec:	29 9a       	sbi	0x05, 1	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    19ee:	35 e0       	ldi	r19, 0x05	; 5
    19f0:	3a 95       	dec	r19
    19f2:	f1 f7       	brne	.-4      	; 0x19f0 <LCD_putValue+0x14>
    19f4:	00 00       	nop
  _delay_us(1);       //wait to make enable wide
  LCD_CPRT &= ~ (1<<LCD_EN);  //EN = 0 for H-to-L pulse
    19f6:	29 98       	cbi	0x05, 1	; 5
    19f8:	ef e8       	ldi	r30, 0x8F	; 143
    19fa:	f1 e0       	ldi	r31, 0x01	; 1
    19fc:	31 97       	sbiw	r30, 0x01	; 1
    19fe:	f1 f7       	brne	.-4      	; 0x19fc <LCD_putValue+0x20>
    1a00:	00 c0       	rjmp	.+0      	; 0x1a02 <LCD_putValue+0x26>
    1a02:	00 00       	nop
  _delay_us(100);     //wait to make enable wide

  LCD_DPRT &= 0x0F;
    1a04:	9b b1       	in	r25, 0x0b	; 11
    1a06:	9f 70       	andi	r25, 0x0F	; 15
    1a08:	9b b9       	out	0x0b, r25	; 11
  LCD_DPRT |= val<<4;     //send cmnd to data port
    1a0a:	2b b1       	in	r18, 0x0b	; 11
    1a0c:	f0 e1       	ldi	r31, 0x10	; 16
    1a0e:	8f 9f       	mul	r24, r31
    1a10:	c0 01       	movw	r24, r0
    1a12:	11 24       	eor	r1, r1
    1a14:	82 2b       	or	r24, r18
    1a16:	8b b9       	out	0x0b, r24	; 11
  LCD_CPRT |= (1<<LCD_EN);    //EN = 1 for H-to-L pulse
    1a18:	29 9a       	sbi	0x05, 1	; 5
    1a1a:	35 e0       	ldi	r19, 0x05	; 5
    1a1c:	3a 95       	dec	r19
    1a1e:	f1 f7       	brne	.-4      	; 0x1a1c <LCD_putValue+0x40>
    1a20:	00 00       	nop
  _delay_us(1);       //wait to make enable wide
  LCD_CPRT &= ~ (1<<LCD_EN);  //EN = 0 for H-to-L pulse
    1a22:	29 98       	cbi	0x05, 1	; 5
    1a24:	8f e8       	ldi	r24, 0x8F	; 143
    1a26:	91 e0       	ldi	r25, 0x01	; 1
    1a28:	01 97       	sbiw	r24, 0x01	; 1
    1a2a:	f1 f7       	brne	.-4      	; 0x1a28 <LCD_putValue+0x4c>
    1a2c:	00 c0       	rjmp	.+0      	; 0x1a2e <LCD_putValue+0x52>
    1a2e:	00 00       	nop
    1a30:	08 95       	ret

00001a32 <LCD_sendCommand>:
  _delay_us(100);     //wait to make enable wide    
}

static void LCD_sendCommand( unsigned char cmnd )
{ 
  LCD_CPRT &= ~ (1<<LCD_RS);    //RS = 0 for command  
    1a32:	28 98       	cbi	0x05, 0	; 5
  LCD_putValue(cmnd);
    1a34:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <LCD_putValue>
    1a38:	08 95       	ret

00001a3a <LCD_sendData>:
}

static void LCD_sendData( unsigned char data )
{
  LCD_CPRT |= (1<<LCD_RS);    //RS = 1 for data   
    1a3a:	28 9a       	sbi	0x05, 0	; 5
  LCD_putValue(data);  
    1a3c:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <LCD_putValue>
    1a40:	08 95       	ret

00001a42 <LCD_goToXY>:

  LCD_clear();    
}

static void LCD_goToXY(unsigned char x, unsigned char y)
{  
    1a42:	cf 93       	push	r28
    1a44:	df 93       	push	r29
    1a46:	00 d0       	rcall	.+0      	; 0x1a48 <LCD_goToXY+0x6>
    1a48:	00 d0       	rcall	.+0      	; 0x1a4a <LCD_goToXY+0x8>
    1a4a:	cd b7       	in	r28, 0x3d	; 61
    1a4c:	de b7       	in	r29, 0x3e	; 62
  unsigned char firstCharAdr[]={0x80,0xC0,0x94,0xD4};
    1a4e:	90 e8       	ldi	r25, 0x80	; 128
    1a50:	99 83       	std	Y+1, r25	; 0x01
    1a52:	90 ec       	ldi	r25, 0xC0	; 192
    1a54:	9a 83       	std	Y+2, r25	; 0x02
    1a56:	94 e9       	ldi	r25, 0x94	; 148
    1a58:	9b 83       	std	Y+3, r25	; 0x03
    1a5a:	94 ed       	ldi	r25, 0xD4	; 212
    1a5c:	9c 83       	std	Y+4, r25	; 0x04
  LCD_sendCommand(firstCharAdr[y-1] + x - 1);
    1a5e:	fe 01       	movw	r30, r28
    1a60:	e6 0f       	add	r30, r22
    1a62:	f1 1d       	adc	r31, r1
    1a64:	81 50       	subi	r24, 0x01	; 1
    1a66:	90 81       	ld	r25, Z
    1a68:	89 0f       	add	r24, r25
    1a6a:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <LCD_sendCommand>
    1a6e:	8f e8       	ldi	r24, 0x8F	; 143
    1a70:	91 e0       	ldi	r25, 0x01	; 1
    1a72:	01 97       	sbiw	r24, 0x01	; 1
    1a74:	f1 f7       	brne	.-4      	; 0x1a72 <LCD_goToXY+0x30>
    1a76:	00 c0       	rjmp	.+0      	; 0x1a78 <LCD_goToXY+0x36>
    1a78:	00 00       	nop
  _delay_us(100); 
}
    1a7a:	0f 90       	pop	r0
    1a7c:	0f 90       	pop	r0
    1a7e:	0f 90       	pop	r0
    1a80:	0f 90       	pop	r0
    1a82:	df 91       	pop	r29
    1a84:	cf 91       	pop	r28
    1a86:	08 95       	ret

00001a88 <buzzerToggle>:
 	
}

static void buzzerToggle() {		
		//Se il buzzer non  impostato dall'esterno o il sistema non  in stato di allarme, il buzzer deve essere spento.
		if (stateBuzzer == OFF){
    1a88:	80 91 7f 08 	lds	r24, 0x087F	; 0x80087f <stateBuzzer>
    1a8c:	81 11       	cpse	r24, r1
    1a8e:	0b c0       	rjmp	.+22     	; 0x1aa6 <buzzerToggle+0x1e>
			//stop the timer
			TCCR2A &= (~(1 << 1 | 1 << 7 | 1 << 8)); 
    1a90:	e0 eb       	ldi	r30, 0xB0	; 176
    1a92:	f0 e0       	ldi	r31, 0x00	; 0
    1a94:	80 81       	ld	r24, Z
    1a96:	8d 77       	andi	r24, 0x7D	; 125
    1a98:	80 83       	st	Z, r24
			TCCR2B &= (~(1 << 1 | 1 << 2));
    1a9a:	e1 eb       	ldi	r30, 0xB1	; 177
    1a9c:	f0 e0       	ldi	r31, 0x00	; 0
    1a9e:	80 81       	ld	r24, Z
    1aa0:	89 7f       	andi	r24, 0xF9	; 249
    1aa2:	80 83       	st	Z, r24
    1aa4:	08 95       	ret
		}
		else { //Start the PWM
		//Setup the timer
		//COM2A0 & COM2B1 set OC2b on compare match; WGM20 select PWM, Phase correct.
		//DDRD |= (1<<PD3);
		TCCR2A |= (1 << COM2A0 ) | (1 << COM2B1 ) | (1 << WGM20); //COM2A0 & 
    1aa6:	e0 eb       	ldi	r30, 0xB0	; 176
    1aa8:	f0 e0       	ldi	r31, 0x00	; 0
    1aaa:	80 81       	ld	r24, Z
    1aac:	81 66       	ori	r24, 0x61	; 97
    1aae:	80 83       	st	Z, r24
		
		//Select clck/32 (from prescaler); WGM22 is clear, it updates OC2B on 0xFF and not on OCRB.
		TCCR2B |= (1 << CS21) | (1 << CS20); 
    1ab0:	e1 eb       	ldi	r30, 0xB1	; 177
    1ab2:	f0 e0       	ldi	r31, 0x00	; 0
    1ab4:	80 81       	ld	r24, Z
    1ab6:	83 60       	ori	r24, 0x03	; 3
    1ab8:	80 83       	st	Z, r24
		OCR2B = 0xFF - 120;
    1aba:	87 e8       	ldi	r24, 0x87	; 135
    1abc:	80 93 b4 00 	sts	0x00B4, r24	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
		
		if( xSemaphoreTake( xSemaphoreUART, ( TickType_t ) 100 ) == pdTRUE )
    1ac0:	20 e0       	ldi	r18, 0x00	; 0
    1ac2:	44 e6       	ldi	r20, 0x64	; 100
    1ac4:	50 e0       	ldi	r21, 0x00	; 0
    1ac6:	60 e0       	ldi	r22, 0x00	; 0
    1ac8:	70 e0       	ldi	r23, 0x00	; 0
    1aca:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    1ace:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    1ad2:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    1ad6:	81 30       	cpi	r24, 0x01	; 1
    1ad8:	e1 f4       	brne	.+56     	; 0x1b12 <buzzerToggle+0x8a>
		{
			if (stateBuzzer == OFF){
    1ada:	80 91 7f 08 	lds	r24, 0x087F	; 0x80087f <stateBuzzer>
    1ade:	81 11       	cpse	r24, r1
    1ae0:	07 c0       	rjmp	.+14     	; 0x1af0 <buzzerToggle+0x68>
				//UART_sendString("{\"actuator\":\"buzzer\",\"value\":\"off\"}\n");
				UART_sendChar(c_BUZZER_OFF);
    1ae2:	83 e3       	ldi	r24, 0x33	; 51
    1ae4:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
				UART_sendChar('\n');
    1ae8:	8a e0       	ldi	r24, 0x0A	; 10
    1aea:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
    1aee:	06 c0       	rjmp	.+12     	; 0x1afc <buzzerToggle+0x74>
			}
			else{
				//UART_sendString("{\"actuator\":\"buzzer\",\"value\":\"on\"}\n");
				UART_sendChar(c_BUZZER_ON);
    1af0:	82 e3       	ldi	r24, 0x32	; 50
    1af2:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
				UART_sendChar('\n');
    1af6:	8a e0       	ldi	r24, 0x0A	; 10
    1af8:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
				}
			xSemaphoreGive( xSemaphoreUART );
    1afc:	20 e0       	ldi	r18, 0x00	; 0
    1afe:	40 e0       	ldi	r20, 0x00	; 0
    1b00:	50 e0       	ldi	r21, 0x00	; 0
    1b02:	60 e0       	ldi	r22, 0x00	; 0
    1b04:	70 e0       	ldi	r23, 0x00	; 0
    1b06:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    1b0a:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    1b0e:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
    1b12:	08 95       	ret

00001b14 <fanToggle>:
		
}

static void fanToggle() {
		//Se il buzzer non  impostato dall'esterno o il sistema non  in stato di allarme, il buzzer deve essere spento.
		if (stateFan == OFF){
    1b14:	80 91 a1 08 	lds	r24, 0x08A1	; 0x8008a1 <stateFan>
    1b18:	81 11       	cpse	r24, r1
    1b1a:	02 c0       	rjmp	.+4      	; 0x1b20 <fanToggle+0xc>
			PORTB &= (~(1 << PB3)); //stop the fan
    1b1c:	2b 98       	cbi	0x05, 3	; 5
    1b1e:	03 c0       	rjmp	.+6      	; 0x1b26 <fanToggle+0x12>
		}
		else {
			PORTB |= (1 << PB3); //ENABLE FAN
    1b20:	2b 9a       	sbi	0x05, 3	; 5
			PORTB |= (1 << PB2); //5v
    1b22:	2a 9a       	sbi	0x05, 2	; 5
			PORTB &= (~(1<< PB4)); //0v
    1b24:	2c 98       	cbi	0x05, 4	; 5
		}
		if( xSemaphoreTake( xSemaphoreUART, ( TickType_t ) 100 ) == pdTRUE )
    1b26:	20 e0       	ldi	r18, 0x00	; 0
    1b28:	44 e6       	ldi	r20, 0x64	; 100
    1b2a:	50 e0       	ldi	r21, 0x00	; 0
    1b2c:	60 e0       	ldi	r22, 0x00	; 0
    1b2e:	70 e0       	ldi	r23, 0x00	; 0
    1b30:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    1b34:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    1b38:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    1b3c:	81 30       	cpi	r24, 0x01	; 1
    1b3e:	e1 f4       	brne	.+56     	; 0x1b78 <fanToggle+0x64>
		{
			if (stateFan == OFF)
    1b40:	80 91 a1 08 	lds	r24, 0x08A1	; 0x8008a1 <stateFan>
    1b44:	81 11       	cpse	r24, r1
    1b46:	07 c0       	rjmp	.+14     	; 0x1b56 <fanToggle+0x42>
			{
				UART_sendChar(c_FAN_OFF);
    1b48:	85 e3       	ldi	r24, 0x35	; 53
    1b4a:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
				UART_sendChar('\n');
    1b4e:	8a e0       	ldi	r24, 0x0A	; 10
    1b50:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
    1b54:	06 c0       	rjmp	.+12     	; 0x1b62 <fanToggle+0x4e>
					
			}else {
				UART_sendChar(c_FAN_ON);
    1b56:	84 e3       	ldi	r24, 0x34	; 52
    1b58:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
				UART_sendChar('\n');
    1b5c:	8a e0       	ldi	r24, 0x0A	; 10
    1b5e:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
			}
			
			xSemaphoreGive( xSemaphoreUART );
    1b62:	20 e0       	ldi	r18, 0x00	; 0
    1b64:	40 e0       	ldi	r20, 0x00	; 0
    1b66:	50 e0       	ldi	r21, 0x00	; 0
    1b68:	60 e0       	ldi	r22, 0x00	; 0
    1b6a:	70 e0       	ldi	r23, 0x00	; 0
    1b6c:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    1b70:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    1b74:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
    1b78:	08 95       	ret

00001b7a <alarmON>:

/* ----------------------------------- FUNCTION DEFINITIONS -------------------------------------*/

static void alarmON() {
				
		alarmState = ON;
    1b7a:	81 e0       	ldi	r24, 0x01	; 1
    1b7c:	80 93 a0 08 	sts	0x08A0, r24	; 0x8008a0 <alarmState>
		stateBuzzer = ON;
    1b80:	80 93 7f 08 	sts	0x087F, r24	; 0x80087f <stateBuzzer>
		stateFan = ON;
    1b84:	80 93 a1 08 	sts	0x08A1, r24	; 0x8008a1 <stateFan>
		PORTD |= 1<<PD2; //toggle on a led on the board
    1b88:	5a 9a       	sbi	0x0b, 2	; 11
		buzzerToggle();
    1b8a:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <buzzerToggle>
		fanToggle();
    1b8e:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <fanToggle>
		if( xSemaphoreTake( xSemaphoreUART, ( TickType_t ) 100 ) == pdTRUE )
    1b92:	20 e0       	ldi	r18, 0x00	; 0
    1b94:	44 e6       	ldi	r20, 0x64	; 100
    1b96:	50 e0       	ldi	r21, 0x00	; 0
    1b98:	60 e0       	ldi	r22, 0x00	; 0
    1b9a:	70 e0       	ldi	r23, 0x00	; 0
    1b9c:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    1ba0:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    1ba4:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    1ba8:	81 30       	cpi	r24, 0x01	; 1
    1baa:	89 f4       	brne	.+34     	; 0x1bce <alarmON+0x54>
		{
			UART_sendChar(c_ALARM_ON);
    1bac:	80 e3       	ldi	r24, 0x30	; 48
    1bae:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
			UART_sendChar('\n');
    1bb2:	8a e0       	ldi	r24, 0x0A	; 10
    1bb4:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
			xSemaphoreGive( xSemaphoreUART );
    1bb8:	20 e0       	ldi	r18, 0x00	; 0
    1bba:	40 e0       	ldi	r20, 0x00	; 0
    1bbc:	50 e0       	ldi	r21, 0x00	; 0
    1bbe:	60 e0       	ldi	r22, 0x00	; 0
    1bc0:	70 e0       	ldi	r23, 0x00	; 0
    1bc2:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    1bc6:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    1bca:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
    1bce:	08 95       	ret

00001bd0 <alarmOFF>:
			
}

static void alarmOFF() {
		
		alarmState = OFF;
    1bd0:	10 92 a0 08 	sts	0x08A0, r1	; 0x8008a0 <alarmState>
		PORTD &= (~(1<< PD2)); //toggle off the led on the board
    1bd4:	5a 98       	cbi	0x0b, 2	; 11
		
		stateBuzzer = OFF;
    1bd6:	10 92 7f 08 	sts	0x087F, r1	; 0x80087f <stateBuzzer>
		stateFan = OFF;
    1bda:	10 92 a1 08 	sts	0x08A1, r1	; 0x8008a1 <stateFan>
		fanToggle();
    1bde:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <fanToggle>
		buzzerToggle();
    1be2:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <buzzerToggle>
		if( xSemaphoreTake( xSemaphoreUART, ( TickType_t ) 100 ) == pdTRUE )
    1be6:	20 e0       	ldi	r18, 0x00	; 0
    1be8:	44 e6       	ldi	r20, 0x64	; 100
    1bea:	50 e0       	ldi	r21, 0x00	; 0
    1bec:	60 e0       	ldi	r22, 0x00	; 0
    1bee:	70 e0       	ldi	r23, 0x00	; 0
    1bf0:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    1bf4:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    1bf8:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    1bfc:	81 30       	cpi	r24, 0x01	; 1
    1bfe:	89 f4       	brne	.+34     	; 0x1c22 <alarmOFF+0x52>
		{
			UART_sendChar(c_ALARM_OFF);
    1c00:	81 e3       	ldi	r24, 0x31	; 49
    1c02:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
			UART_sendChar('\n');
    1c06:	8a e0       	ldi	r24, 0x0A	; 10
    1c08:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
			xSemaphoreGive( xSemaphoreUART );
    1c0c:	20 e0       	ldi	r18, 0x00	; 0
    1c0e:	40 e0       	ldi	r20, 0x00	; 0
    1c10:	50 e0       	ldi	r21, 0x00	; 0
    1c12:	60 e0       	ldi	r22, 0x00	; 0
    1c14:	70 e0       	ldi	r23, 0x00	; 0
    1c16:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    1c1a:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    1c1e:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
    1c22:	08 95       	ret

00001c24 <serialFromISRTask>:
	LCD_sendData(d1+ASCII_OFFSET);
	LCD_sendData(d2+ASCII_OFFSET);
	LCD_sendData(d3+ASCII_OFFSET);
 }

void serialFromISRTask (void *parameters) {
    1c24:	cf 93       	push	r28
    1c26:	df 93       	push	r29
    1c28:	00 d0       	rcall	.+0      	; 0x1c2a <serialFromISRTask+0x6>
    1c2a:	cd b7       	in	r28, 0x3d	; 61
    1c2c:	de b7       	in	r29, 0x3e	; 62
			case BUZZER_OFF:
				stateBuzzer = OFF;
				buzzerToggle();
				break;
			case FAN_ON:
				stateFan = ON;
    1c2e:	11 e0       	ldi	r17, 0x01	; 1
	char *pcString; //where the queue receive the msg.
	uint8_t commandReceived;
	
	for( ;; ) {
		/* Block on the queue to wait for data to arrive. */
		xQueueReceive(xCharQueue, &pcString, portMAX_DELAY);
    1c30:	20 e0       	ldi	r18, 0x00	; 0
    1c32:	4f ef       	ldi	r20, 0xFF	; 255
    1c34:	5f ef       	ldi	r21, 0xFF	; 255
    1c36:	be 01       	movw	r22, r28
    1c38:	6f 5f       	subi	r22, 0xFF	; 255
    1c3a:	7f 4f       	sbci	r23, 0xFF	; 255
    1c3c:	80 91 9a 08 	lds	r24, 0x089A	; 0x80089a <xCharQueue>
    1c40:	90 91 9b 08 	lds	r25, 0x089B	; 0x80089b <xCharQueue+0x1>
    1c44:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
		
		commandReceived = pcString - ASCII_OFFSET; //Gives the number from exadecimal to Ascii
		
		switch (commandReceived) {
    1c48:	89 81       	ldd	r24, Y+1	; 0x01
    1c4a:	9a 81       	ldd	r25, Y+2	; 0x02
    1c4c:	c0 97       	sbiw	r24, 0x30	; 48
    1c4e:	99 27       	eor	r25, r25
    1c50:	82 30       	cpi	r24, 0x02	; 2
    1c52:	91 05       	cpc	r25, r1
    1c54:	99 f0       	breq	.+38     	; 0x1c7c <serialFromISRTask+0x58>
    1c56:	2c f4       	brge	.+10     	; 0x1c62 <serialFromISRTask+0x3e>
    1c58:	00 97       	sbiw	r24, 0x00	; 0
    1c5a:	51 f0       	breq	.+20     	; 0x1c70 <serialFromISRTask+0x4c>
    1c5c:	01 97       	sbiw	r24, 0x01	; 1
    1c5e:	59 f0       	breq	.+22     	; 0x1c76 <serialFromISRTask+0x52>
    1c60:	e7 cf       	rjmp	.-50     	; 0x1c30 <serialFromISRTask+0xc>
    1c62:	84 30       	cpi	r24, 0x04	; 4
    1c64:	91 05       	cpc	r25, r1
    1c66:	a1 f0       	breq	.+40     	; 0x1c90 <serialFromISRTask+0x6c>
    1c68:	74 f0       	brlt	.+28     	; 0x1c86 <serialFromISRTask+0x62>
    1c6a:	05 97       	sbiw	r24, 0x05	; 5
    1c6c:	b1 f0       	breq	.+44     	; 0x1c9a <serialFromISRTask+0x76>
    1c6e:	e0 cf       	rjmp	.-64     	; 0x1c30 <serialFromISRTask+0xc>
			case ALARM_ON:
				alarmON();
    1c70:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <alarmON>
				break;
    1c74:	dd cf       	rjmp	.-70     	; 0x1c30 <serialFromISRTask+0xc>
			case ALARM_OFF:
				alarmOFF();
    1c76:	0e 94 e8 0d 	call	0x1bd0	; 0x1bd0 <alarmOFF>
				break;
    1c7a:	da cf       	rjmp	.-76     	; 0x1c30 <serialFromISRTask+0xc>
			case BUZZER_ON:
				stateBuzzer = ON;
    1c7c:	10 93 7f 08 	sts	0x087F, r17	; 0x80087f <stateBuzzer>
				buzzerToggle();
    1c80:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <buzzerToggle>
				break;
    1c84:	d5 cf       	rjmp	.-86     	; 0x1c30 <serialFromISRTask+0xc>
			case BUZZER_OFF:
				stateBuzzer = OFF;
    1c86:	10 92 7f 08 	sts	0x087F, r1	; 0x80087f <stateBuzzer>
				buzzerToggle();
    1c8a:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <buzzerToggle>
				break;
    1c8e:	d0 cf       	rjmp	.-96     	; 0x1c30 <serialFromISRTask+0xc>
			case FAN_ON:
				stateFan = ON;
    1c90:	10 93 a1 08 	sts	0x08A1, r17	; 0x8008a1 <stateFan>
				fanToggle();
    1c94:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <fanToggle>
				break;
    1c98:	cb cf       	rjmp	.-106    	; 0x1c30 <serialFromISRTask+0xc>
			case FAN_OFF:
				stateFan = OFF;
    1c9a:	10 92 a1 08 	sts	0x08A1, r1	; 0x8008a1 <stateFan>
				fanToggle();
    1c9e:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <fanToggle>
				break;
    1ca2:	c6 cf       	rjmp	.-116    	; 0x1c30 <serialFromISRTask+0xc>

00001ca4 <temperatureReadTask>:
 		}
		
	}
}

void temperatureReadTask(void* parameter) {
    1ca4:	cf 93       	push	r28
    1ca6:	df 93       	push	r29
    1ca8:	00 d0       	rcall	.+0      	; 0x1caa <temperatureReadTask+0x6>
    1caa:	00 d0       	rcall	.+0      	; 0x1cac <temperatureReadTask+0x8>
    1cac:	cd b7       	in	r28, 0x3d	; 61
    1cae:	de b7       	in	r29, 0x3e	; 62
	
}

static void ADC_setupToReadTemp(void){
	DDRC&=~(1<<0);
	ADCSRA = 0x87; //make ADC enagle and select ck/128
    1cb0:	0f 2e       	mov	r0, r31
    1cb2:	fa e7       	ldi	r31, 0x7A	; 122
    1cb4:	ef 2e       	mov	r14, r31
    1cb6:	f1 2c       	mov	r15, r1
    1cb8:	f0 2d       	mov	r31, r0
    1cba:	0f 2e       	mov	r0, r31
    1cbc:	f7 e8       	ldi	r31, 0x87	; 135
    1cbe:	cf 2e       	mov	r12, r31
    1cc0:	f0 2d       	mov	r31, r0
	ADMUX = 0b11000000; //adc0
    1cc2:	0c e7       	ldi	r16, 0x7C	; 124
    1cc4:	10 e0       	ldi	r17, 0x00	; 0
    1cc6:	0f 2e       	mov	r0, r31
    1cc8:	f0 ec       	ldi	r31, 0xC0	; 192
    1cca:	df 2e       	mov	r13, r31
    1ccc:	f0 2d       	mov	r31, r0
	//float threshold = THRESHOLD_TEMPERATURE;
	float temperature;
	
	for (;;){
		
		vTaskSuspend(temperatureReadTaskHandle);
    1cce:	80 91 9c 08 	lds	r24, 0x089C	; 0x80089c <temperatureReadTaskHandle>
    1cd2:	90 91 9d 08 	lds	r25, 0x089D	; 0x80089d <temperatureReadTaskHandle+0x1>
    1cd6:	0e 94 58 09 	call	0x12b0	; 0x12b0 <vTaskSuspend>
		
		if( xSemaphoreADC != NULL )
    1cda:	80 91 94 08 	lds	r24, 0x0894	; 0x800894 <xSemaphoreADC>
    1cde:	90 91 95 08 	lds	r25, 0x0895	; 0x800895 <xSemaphoreADC+0x1>
    1ce2:	00 97       	sbiw	r24, 0x00	; 0
    1ce4:	09 f4       	brne	.+2      	; 0x1ce8 <temperatureReadTask+0x44>
    1ce6:	4b c0       	rjmp	.+150    	; 0x1d7e <temperatureReadTask+0xda>
		{
        /* See if we can obtain the semaphore.  If the semaphore is not
        available wait 10 ticks to see if it becomes free. */
			if( xSemaphoreTake( xSemaphoreADC, ( TickType_t ) 100 ) == pdTRUE )
    1ce8:	20 e0       	ldi	r18, 0x00	; 0
    1cea:	44 e6       	ldi	r20, 0x64	; 100
    1cec:	50 e0       	ldi	r21, 0x00	; 0
    1cee:	60 e0       	ldi	r22, 0x00	; 0
    1cf0:	70 e0       	ldi	r23, 0x00	; 0
    1cf2:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    1cf6:	81 30       	cpi	r24, 0x01	; 1
    1cf8:	09 f0       	breq	.+2      	; 0x1cfc <temperatureReadTask+0x58>
    1cfa:	41 c0       	rjmp	.+130    	; 0x1d7e <temperatureReadTask+0xda>
	DDRB |= (1 << 3) | (1 << 2) | (1 << 4); //make port b output for PB3, PB2, PB4
	
}

static void ADC_setupToReadTemp(void){
	DDRC&=~(1<<0);
    1cfc:	38 98       	cbi	0x07, 0	; 7
	ADCSRA = 0x87; //make ADC enagle and select ck/128
    1cfe:	f7 01       	movw	r30, r14
    1d00:	c0 82       	st	Z, r12
	ADMUX = 0b11000000; //adc0
    1d02:	f8 01       	movw	r30, r16
    1d04:	d0 82       	st	Z, r13
			if( xSemaphoreTake( xSemaphoreADC, ( TickType_t ) 100 ) == pdTRUE )
			{
				/* We were able to obtain the semaphore and can now access the
				shared resource. */
				ADC_setupToReadTemp();
				vTaskDelay(10);
    1d06:	8a e0       	ldi	r24, 0x0A	; 10
    1d08:	90 e0       	ldi	r25, 0x00	; 0
    1d0a:	0e 94 9f 08 	call	0x113e	; 0x113e <vTaskDelay>
				float tempTemperature = ADC_read();
    1d0e:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <ADC_read>
				temperature = (tempTemperature*10/93)-50;
    1d12:	20 e0       	ldi	r18, 0x00	; 0
    1d14:	30 e0       	ldi	r19, 0x00	; 0
    1d16:	40 e2       	ldi	r20, 0x20	; 32
    1d18:	51 e4       	ldi	r21, 0x41	; 65
    1d1a:	0e 94 ee 14 	call	0x29dc	; 0x29dc <__mulsf3>
    1d1e:	20 e0       	ldi	r18, 0x00	; 0
    1d20:	30 e0       	ldi	r19, 0x00	; 0
    1d22:	4a eb       	ldi	r20, 0xBA	; 186
    1d24:	52 e4       	ldi	r21, 0x42	; 66
    1d26:	0e 94 ba 13 	call	0x2774	; 0x2774 <__divsf3>
    1d2a:	20 e0       	ldi	r18, 0x00	; 0
    1d2c:	30 e0       	ldi	r19, 0x00	; 0
    1d2e:	48 e4       	ldi	r20, 0x48	; 72
    1d30:	52 e4       	ldi	r21, 0x42	; 66
    1d32:	0e 94 4d 13 	call	0x269a	; 0x269a <__subsf3>
    1d36:	69 83       	std	Y+1, r22	; 0x01
    1d38:	7a 83       	std	Y+2, r23	; 0x02
    1d3a:	8b 83       	std	Y+3, r24	; 0x03
    1d3c:	9c 83       	std	Y+4, r25	; 0x04
				
				/* We have finished accessing the shared resource.  Release the
				semaphore. */
				xSemaphoreGive( xSemaphoreADC );
    1d3e:	20 e0       	ldi	r18, 0x00	; 0
    1d40:	40 e0       	ldi	r20, 0x00	; 0
    1d42:	50 e0       	ldi	r21, 0x00	; 0
    1d44:	60 e0       	ldi	r22, 0x00	; 0
    1d46:	70 e0       	ldi	r23, 0x00	; 0
    1d48:	80 91 94 08 	lds	r24, 0x0894	; 0x800894 <xSemaphoreADC>
    1d4c:	90 91 95 08 	lds	r25, 0x0895	; 0x800895 <xSemaphoreADC+0x1>
    1d50:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
				if (temperature > THRESHOLD_TEMPERATURE) {
    1d54:	20 e0       	ldi	r18, 0x00	; 0
    1d56:	30 e0       	ldi	r19, 0x00	; 0
    1d58:	44 e6       	ldi	r20, 0x64	; 100
    1d5a:	52 e4       	ldi	r21, 0x42	; 66
    1d5c:	69 81       	ldd	r22, Y+1	; 0x01
    1d5e:	7a 81       	ldd	r23, Y+2	; 0x02
    1d60:	8b 81       	ldd	r24, Y+3	; 0x03
    1d62:	9c 81       	ldd	r25, Y+4	; 0x04
    1d64:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <__gesf2>
    1d68:	18 16       	cp	r1, r24
    1d6a:	1c f4       	brge	.+6      	; 0x1d72 <temperatureReadTask+0xce>
					alarmON();
    1d6c:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <alarmON>
    1d70:	06 c0       	rjmp	.+12     	; 0x1d7e <temperatureReadTask+0xda>
				}
				else {
					if (alarmState == ON){
    1d72:	80 91 a0 08 	lds	r24, 0x08A0	; 0x8008a0 <alarmState>
    1d76:	81 30       	cpi	r24, 0x01	; 1
    1d78:	11 f4       	brne	.+4      	; 0x1d7e <temperatureReadTask+0xda>
					alarmOFF();
    1d7a:	0e 94 e8 0d 	call	0x1bd0	; 0x1bd0 <alarmOFF>
			{
				/* We could not obtain the semaphore and can therefore not access
				the shared resource safely. */
			}
		}			
		if( xQueueTemperatureSendings != 0 )
    1d7e:	80 91 8a 08 	lds	r24, 0x088A	; 0x80088a <xQueueTemperatureSendings>
    1d82:	90 91 8b 08 	lds	r25, 0x088B	; 0x80088b <xQueueTemperatureSendings+0x1>
    1d86:	00 97       	sbiw	r24, 0x00	; 0
    1d88:	09 f4       	brne	.+2      	; 0x1d8c <temperatureReadTask+0xe8>
    1d8a:	a1 cf       	rjmp	.-190    	; 0x1cce <temperatureReadTask+0x2a>
		{
        /* Send an unsigned long.  Wait for 10 ticks for space to become
        available if necessary. */
			if( xQueueSend( xQueueTemperatureSendings,
    1d8c:	20 e0       	ldi	r18, 0x00	; 0
    1d8e:	44 e6       	ldi	r20, 0x64	; 100
    1d90:	50 e0       	ldi	r21, 0x00	; 0
    1d92:	be 01       	movw	r22, r28
    1d94:	6f 5f       	subi	r22, 0xFF	; 255
    1d96:	7f 4f       	sbci	r23, 0xFF	; 255
    1d98:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
    1d9c:	98 cf       	rjmp	.-208    	; 0x1cce <temperatureReadTask+0x2a>

00001d9e <airReadTask>:
			}	
		}
	}
}

void airReadTask(void* parameter) {
    1d9e:	cf 93       	push	r28
    1da0:	df 93       	push	r29
    1da2:	00 d0       	rcall	.+0      	; 0x1da4 <airReadTask+0x6>
    1da4:	00 d0       	rcall	.+0      	; 0x1da6 <airReadTask+0x8>
    1da6:	cd b7       	in	r28, 0x3d	; 61
    1da8:	de b7       	in	r29, 0x3e	; 62
	
}

static void ADC_setupToReadAir(void){
	DDRC&=~(1<<1);
	ADCSRA = 0x87; //make ADC enagle and select ck/128
    1daa:	0f 2e       	mov	r0, r31
    1dac:	fa e7       	ldi	r31, 0x7A	; 122
    1dae:	ef 2e       	mov	r14, r31
    1db0:	f1 2c       	mov	r15, r1
    1db2:	f0 2d       	mov	r31, r0
    1db4:	0f 2e       	mov	r0, r31
    1db6:	f7 e8       	ldi	r31, 0x87	; 135
    1db8:	cf 2e       	mov	r12, r31
    1dba:	f0 2d       	mov	r31, r0
	ADMUX = 0b01000001; //adc1
    1dbc:	0c e7       	ldi	r16, 0x7C	; 124
    1dbe:	10 e0       	ldi	r17, 0x00	; 0
    1dc0:	0f 2e       	mov	r0, r31
    1dc2:	f1 e4       	ldi	r31, 0x41	; 65
    1dc4:	df 2e       	mov	r13, r31
    1dc6:	f0 2d       	mov	r31, r0
	
	float air;
	
	for (;;)
 	{
 		vTaskSuspend(NULL);
    1dc8:	80 e0       	ldi	r24, 0x00	; 0
    1dca:	90 e0       	ldi	r25, 0x00	; 0
    1dcc:	0e 94 58 09 	call	0x12b0	; 0x12b0 <vTaskSuspend>
		
		if( xSemaphoreADC != NULL )
    1dd0:	80 91 94 08 	lds	r24, 0x0894	; 0x800894 <xSemaphoreADC>
    1dd4:	90 91 95 08 	lds	r25, 0x0895	; 0x800895 <xSemaphoreADC+0x1>
    1dd8:	00 97       	sbiw	r24, 0x00	; 0
    1dda:	c1 f1       	breq	.+112    	; 0x1e4c <airReadTask+0xae>
		{
			/* See if we can obtain the semaphore.  If the semaphore is not
			available wait 10 ticks to see if it becomes free. */
 			if( xSemaphoreTake( xSemaphoreADC, ( TickType_t ) 100 ) == pdTRUE )
    1ddc:	20 e0       	ldi	r18, 0x00	; 0
    1dde:	44 e6       	ldi	r20, 0x64	; 100
    1de0:	50 e0       	ldi	r21, 0x00	; 0
    1de2:	60 e0       	ldi	r22, 0x00	; 0
    1de4:	70 e0       	ldi	r23, 0x00	; 0
    1de6:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    1dea:	81 30       	cpi	r24, 0x01	; 1
    1dec:	79 f5       	brne	.+94     	; 0x1e4c <airReadTask+0xae>
	ADMUX = 0b11000000; //adc0
	
}

static void ADC_setupToReadAir(void){
	DDRC&=~(1<<1);
    1dee:	39 98       	cbi	0x07, 1	; 7
	ADCSRA = 0x87; //make ADC enagle and select ck/128
    1df0:	f7 01       	movw	r30, r14
    1df2:	c0 82       	st	Z, r12
	ADMUX = 0b01000001; //adc1
    1df4:	f8 01       	movw	r30, r16
    1df6:	d0 82       	st	Z, r13
			{
				/* We were able to obtain the semaphore and can now access the
				shared resource. */

				ADC_setupToReadAir();
				vTaskDelay(10);
    1df8:	8a e0       	ldi	r24, 0x0A	; 10
    1dfa:	90 e0       	ldi	r25, 0x00	; 0
    1dfc:	0e 94 9f 08 	call	0x113e	; 0x113e <vTaskDelay>
				air = ADC_read();
    1e00:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <ADC_read>
    1e04:	69 83       	std	Y+1, r22	; 0x01
    1e06:	7a 83       	std	Y+2, r23	; 0x02
    1e08:	8b 83       	std	Y+3, r24	; 0x03
    1e0a:	9c 83       	std	Y+4, r25	; 0x04
			

				/* We have finished accessing the shared resource.  Release the
				semaphore. */
				xSemaphoreGive( xSemaphoreADC );
    1e0c:	20 e0       	ldi	r18, 0x00	; 0
    1e0e:	40 e0       	ldi	r20, 0x00	; 0
    1e10:	50 e0       	ldi	r21, 0x00	; 0
    1e12:	60 e0       	ldi	r22, 0x00	; 0
    1e14:	70 e0       	ldi	r23, 0x00	; 0
    1e16:	80 91 94 08 	lds	r24, 0x0894	; 0x800894 <xSemaphoreADC>
    1e1a:	90 91 95 08 	lds	r25, 0x0895	; 0x800895 <xSemaphoreADC+0x1>
    1e1e:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
				
				if (air > THRESHOLD_AIR) {
    1e22:	20 e0       	ldi	r18, 0x00	; 0
    1e24:	30 e0       	ldi	r19, 0x00	; 0
    1e26:	48 e4       	ldi	r20, 0x48	; 72
    1e28:	53 e4       	ldi	r21, 0x43	; 67
    1e2a:	69 81       	ldd	r22, Y+1	; 0x01
    1e2c:	7a 81       	ldd	r23, Y+2	; 0x02
    1e2e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e30:	9c 81       	ldd	r25, Y+4	; 0x04
    1e32:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <__gesf2>
    1e36:	18 16       	cp	r1, r24
    1e38:	1c f4       	brge	.+6      	; 0x1e40 <airReadTask+0xa2>
					alarmON();
    1e3a:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <alarmON>
    1e3e:	06 c0       	rjmp	.+12     	; 0x1e4c <airReadTask+0xae>
				}
				else {
					if (alarmState == ON){
    1e40:	80 91 a0 08 	lds	r24, 0x08A0	; 0x8008a0 <alarmState>
    1e44:	81 30       	cpi	r24, 0x01	; 1
    1e46:	11 f4       	brne	.+4      	; 0x1e4c <airReadTask+0xae>
						alarmOFF();
    1e48:	0e 94 e8 0d 	call	0x1bd0	; 0x1bd0 <alarmOFF>
				/* We could not obtain the semaphore and can therefore not access
				the shared resource safely. */
			}
		}
		
		if( xQueueAirSendings != 0 )
    1e4c:	80 91 9e 08 	lds	r24, 0x089E	; 0x80089e <xQueueAirSendings>
    1e50:	90 91 9f 08 	lds	r25, 0x089F	; 0x80089f <xQueueAirSendings+0x1>
    1e54:	00 97       	sbiw	r24, 0x00	; 0
    1e56:	09 f4       	brne	.+2      	; 0x1e5a <airReadTask+0xbc>
    1e58:	b7 cf       	rjmp	.-146    	; 0x1dc8 <airReadTask+0x2a>
		{
			/* Send an unsigned long.  Wait for 10 ticks for space to become
			available if necessary. */
			if( xQueueSend( xQueueAirSendings,
    1e5a:	20 e0       	ldi	r18, 0x00	; 0
    1e5c:	44 e6       	ldi	r20, 0x64	; 100
    1e5e:	50 e0       	ldi	r21, 0x00	; 0
    1e60:	be 01       	movw	r22, r28
    1e62:	6f 5f       	subi	r22, 0xFF	; 255
    1e64:	7f 4f       	sbci	r23, 0xFF	; 255
    1e66:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
    1e6a:	ae cf       	rjmp	.-164    	; 0x1dc8 <airReadTask+0x2a>

00001e6c <vTimerCallback>:
}//airSendTask

void vTimerCallback(TimerHandle_t xTimerReadings)
 {
	//LCD_print("test");
	vTaskResume(temperatureReadTaskHandle);
    1e6c:	80 91 9c 08 	lds	r24, 0x089C	; 0x80089c <temperatureReadTaskHandle>
    1e70:	90 91 9d 08 	lds	r25, 0x089D	; 0x80089d <temperatureReadTaskHandle+0x1>
    1e74:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <vTaskResume>
	
	vTaskResume (AirReadTaskHandle);  
    1e78:	80 91 98 08 	lds	r24, 0x0898	; 0x800898 <AirReadTaskHandle>
    1e7c:	90 91 99 08 	lds	r25, 0x0899	; 0x800899 <AirReadTaskHandle+0x1>
    1e80:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <vTaskResume>
    1e84:	08 95       	ret

00001e86 <__vector_18>:
void vTimerCallback(TimerHandle_t xTimerReadings); //called when timer elapse

/* ----------------------------------- ISR -------------------------------------*/

//INTERRUPT SERVICE ROUTINE
ISR (USART_RX_vect) {
    1e86:	1f 92       	push	r1
    1e88:	0f 92       	push	r0
    1e8a:	0f b6       	in	r0, 0x3f	; 63
    1e8c:	0f 92       	push	r0
    1e8e:	11 24       	eor	r1, r1
    1e90:	2f 93       	push	r18
    1e92:	3f 93       	push	r19
    1e94:	4f 93       	push	r20
    1e96:	5f 93       	push	r21
    1e98:	6f 93       	push	r22
    1e9a:	7f 93       	push	r23
    1e9c:	8f 93       	push	r24
    1e9e:	9f 93       	push	r25
    1ea0:	af 93       	push	r26
    1ea2:	bf 93       	push	r27
    1ea4:	ef 93       	push	r30
    1ea6:	ff 93       	push	r31
    1ea8:	cf 93       	push	r28
    1eaa:	df 93       	push	r29
    1eac:	00 d0       	rcall	.+0      	; 0x1eae <__vector_18+0x28>
    1eae:	cd b7       	in	r28, 0x3d	; 61
    1eb0:	de b7       	in	r29, 0x3e	; 62
	
	signed char cChar;
	
	cChar = UDR0;
    1eb2:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
    1eb6:	89 83       	std	Y+1, r24	; 0x01
	//We need it for the task YIELD
	BaseType_t xHigherPriorityTaskWoken;
	xHigherPriorityTaskWoken = pdFALSE;
    1eb8:	1a 82       	std	Y+2, r1	; 0x02
	
	//The queue is useful exchange message with the other task
	xQueueSendFromISR( xCharQueue, &cChar, &xHigherPriorityTaskWoken );
    1eba:	20 e0       	ldi	r18, 0x00	; 0
    1ebc:	ae 01       	movw	r20, r28
    1ebe:	4e 5f       	subi	r20, 0xFE	; 254
    1ec0:	5f 4f       	sbci	r21, 0xFF	; 255
    1ec2:	be 01       	movw	r22, r28
    1ec4:	6f 5f       	subi	r22, 0xFF	; 255
    1ec6:	7f 4f       	sbci	r23, 0xFF	; 255
    1ec8:	80 91 9a 08 	lds	r24, 0x089A	; 0x80089a <xCharQueue>
    1ecc:	90 91 9b 08 	lds	r25, 0x089B	; 0x80089b <xCharQueue+0x1>
    1ed0:	0e 94 3b 04 	call	0x876	; 0x876 <xQueueGenericSendFromISR>
	
	//TaskYIELD in Atmega328p.
	if( xHigherPriorityTaskWoken != pdFALSE ) {
    1ed4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ed6:	81 11       	cpse	r24, r1
		taskYIELD();
    1ed8:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
	}
	
}
    1edc:	0f 90       	pop	r0
    1ede:	0f 90       	pop	r0
    1ee0:	df 91       	pop	r29
    1ee2:	cf 91       	pop	r28
    1ee4:	ff 91       	pop	r31
    1ee6:	ef 91       	pop	r30
    1ee8:	bf 91       	pop	r27
    1eea:	af 91       	pop	r26
    1eec:	9f 91       	pop	r25
    1eee:	8f 91       	pop	r24
    1ef0:	7f 91       	pop	r23
    1ef2:	6f 91       	pop	r22
    1ef4:	5f 91       	pop	r21
    1ef6:	4f 91       	pop	r20
    1ef8:	3f 91       	pop	r19
    1efa:	2f 91       	pop	r18
    1efc:	0f 90       	pop	r0
    1efe:	0f be       	out	0x3f, r0	; 63
    1f00:	0f 90       	pop	r0
    1f02:	1f 90       	pop	r1
    1f04:	18 95       	reti

00001f06 <UART_sendString>:
	// Setup data format: 8 bit data, 1 stop bit
	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);
}

void UART_sendString(const char* data)
{
    1f06:	cf 93       	push	r28
    1f08:	df 93       	push	r29
    1f0a:	ec 01       	movw	r28, r24
	//Send character until null terminator
	while (*data != '\0')
    1f0c:	88 81       	ld	r24, Y
    1f0e:	88 23       	and	r24, r24
    1f10:	31 f0       	breq	.+12     	; 0x1f1e <UART_sendString+0x18>
    1f12:	21 96       	adiw	r28, 0x01	; 1
	{
		UART_sendChar(*data);
    1f14:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
}

void UART_sendString(const char* data)
{
	//Send character until null terminator
	while (*data != '\0')
    1f18:	89 91       	ld	r24, Y+
    1f1a:	81 11       	cpse	r24, r1
    1f1c:	fb cf       	rjmp	.-10     	; 0x1f14 <UART_sendString+0xe>
	{
		UART_sendChar(*data);
		data++;
	}
}
    1f1e:	df 91       	pop	r29
    1f20:	cf 91       	pop	r28
    1f22:	08 95       	ret

00001f24 <generateArrayTemperature>:

	return (ADCL+(ADCH<<8));
	//return ADC;
}

char* generateArrayTemperature(unsigned char d1, unsigned char d2, unsigned char d3, unsigned char d4){
    1f24:	0f 93       	push	r16
    1f26:	1f 93       	push	r17
    1f28:	cf 93       	push	r28
    1f2a:	df 93       	push	r29
    1f2c:	cd b7       	in	r28, 0x3d	; 61
    1f2e:	de b7       	in	r29, 0x3e	; 62
    1f30:	a0 97       	sbiw	r28, 0x20	; 32
    1f32:	0f b6       	in	r0, 0x3f	; 63
    1f34:	f8 94       	cli
    1f36:	de bf       	out	0x3e, r29	; 62
    1f38:	0f be       	out	0x3f, r0	; 63
    1f3a:	cd bf       	out	0x3d, r28	; 61
	//Handwriting the array of sending temperature
	const char jsonDataTemperatureTemp [] = "{\"sensor\":\"temperature\",\"value\"";
    1f3c:	90 e2       	ldi	r25, 0x20	; 32
    1f3e:	e2 e1       	ldi	r30, 0x12	; 18
    1f40:	f1 e0       	ldi	r31, 0x01	; 1
    1f42:	de 01       	movw	r26, r28
    1f44:	11 96       	adiw	r26, 0x01	; 1
    1f46:	01 90       	ld	r0, Z+
    1f48:	0d 92       	st	X+, r0
    1f4a:	9a 95       	dec	r25
    1f4c:	e1 f7       	brne	.-8      	; 0x1f46 <generateArrayTemperature+0x22>
    1f4e:	fe 01       	movw	r30, r28
    1f50:	31 96       	adiw	r30, 0x01	; 1
    1f52:	a9 e4       	ldi	r26, 0x49	; 73
    1f54:	b8 e0       	ldi	r27, 0x08	; 8
    1f56:	8e 01       	movw	r16, r28
    1f58:	0f 5d       	subi	r16, 0xDF	; 223
    1f5a:	1f 4f       	sbci	r17, 0xFF	; 255
	int len1 = sizeof(jsonDataTemperatureTemp)/sizeof(jsonDataTemperatureTemp[0]);
	static char jsonDataTemperatureTempT2 [SIZE_ARRAY];
	
	for (int i = 0; i<len1; i++){
		jsonDataTemperatureTempT2[i] = jsonDataTemperatureTemp[i];
    1f5c:	91 91       	ld	r25, Z+
    1f5e:	9d 93       	st	X+, r25
	//Handwriting the array of sending temperature
	const char jsonDataTemperatureTemp [] = "{\"sensor\":\"temperature\",\"value\"";
	int len1 = sizeof(jsonDataTemperatureTemp)/sizeof(jsonDataTemperatureTemp[0]);
	static char jsonDataTemperatureTempT2 [SIZE_ARRAY];
	
	for (int i = 0; i<len1; i++){
    1f60:	e0 17       	cp	r30, r16
    1f62:	f1 07       	cpc	r31, r17
    1f64:	d9 f7       	brne	.-10     	; 0x1f5c <generateArrayTemperature+0x38>
		jsonDataTemperatureTempT2[i] = jsonDataTemperatureTemp[i];
	}
	jsonDataTemperatureTempT2 [len1-1] = ':';
    1f66:	e9 e4       	ldi	r30, 0x49	; 73
    1f68:	f8 e0       	ldi	r31, 0x08	; 8
    1f6a:	9a e3       	ldi	r25, 0x3A	; 58
    1f6c:	97 8f       	std	Z+31, r25	; 0x1f
	jsonDataTemperatureTempT2 [len1] = ASCII_CONVERT(d1);
    1f6e:	80 5d       	subi	r24, 0xD0	; 208
    1f70:	80 a3       	std	Z+32, r24	; 0x20
	jsonDataTemperatureTempT2 [len1+1] = ASCII_CONVERT(d2);
    1f72:	60 5d       	subi	r22, 0xD0	; 208
    1f74:	61 a3       	std	Z+33, r22	; 0x21
	jsonDataTemperatureTempT2 [len1+2] = '.';
    1f76:	8e e2       	ldi	r24, 0x2E	; 46
    1f78:	82 a3       	std	Z+34, r24	; 0x22
	jsonDataTemperatureTempT2 [len1+3] = ASCII_CONVERT(d3);
    1f7a:	40 5d       	subi	r20, 0xD0	; 208
    1f7c:	43 a3       	std	Z+35, r20	; 0x23
	jsonDataTemperatureTempT2 [len1+4] = ASCII_CONVERT(d4);
    1f7e:	20 5d       	subi	r18, 0xD0	; 208
    1f80:	24 a3       	std	Z+36, r18	; 0x24
	jsonDataTemperatureTempT2 [len1+5] = '}';
    1f82:	8d e7       	ldi	r24, 0x7D	; 125
    1f84:	85 a3       	std	Z+37, r24	; 0x25
	jsonDataTemperatureTempT2 [len1+6] = '\n';
    1f86:	8a e0       	ldi	r24, 0x0A	; 10
    1f88:	86 a3       	std	Z+38, r24	; 0x26
	jsonDataTemperatureTempT2 [len1+7] = '\0';
    1f8a:	17 a2       	std	Z+39, r1	; 0x27
	return jsonDataTemperatureTempT2;
	
}
    1f8c:	cf 01       	movw	r24, r30
    1f8e:	a0 96       	adiw	r28, 0x20	; 32
    1f90:	0f b6       	in	r0, 0x3f	; 63
    1f92:	f8 94       	cli
    1f94:	de bf       	out	0x3e, r29	; 62
    1f96:	0f be       	out	0x3f, r0	; 63
    1f98:	cd bf       	out	0x3d, r28	; 61
    1f9a:	df 91       	pop	r29
    1f9c:	cf 91       	pop	r28
    1f9e:	1f 91       	pop	r17
    1fa0:	0f 91       	pop	r16
    1fa2:	08 95       	ret

00001fa4 <convertTemperature>:

unsigned char* convertTemperature(float value){ //it must create  "{\"sensor\":\"temperature\",\"value\":25}\n"
    1fa4:	cf 92       	push	r12
    1fa6:	df 92       	push	r13
    1fa8:	ef 92       	push	r14
    1faa:	ff 92       	push	r15
	static unsigned char result[4];
		
	/*float convert = value*10/93-50;*/
	float convert = value;
	//it must take single digit to print in LCD
	z = convert*100;
    1fac:	20 e0       	ldi	r18, 0x00	; 0
    1fae:	30 e0       	ldi	r19, 0x00	; 0
    1fb0:	48 ec       	ldi	r20, 0xC8	; 200
    1fb2:	52 e4       	ldi	r21, 0x42	; 66
    1fb4:	0e 94 ee 14 	call	0x29dc	; 0x29dc <__mulsf3>
    1fb8:	0e 94 2c 14 	call	0x2858	; 0x2858 <__fixunssfsi>
    1fbc:	6b 01       	movw	r12, r22
    1fbe:	7c 01       	movw	r14, r24
	w = z/10;
	x=w/10;
	y=x/10;
	
	//module to take single unit digit
	result[0]=y%10;
    1fc0:	e5 e4       	ldi	r30, 0x45	; 69
    1fc2:	f8 e0       	ldi	r31, 0x08	; 8
    1fc4:	9b 01       	movw	r18, r22
    1fc6:	36 95       	lsr	r19
    1fc8:	27 95       	ror	r18
    1fca:	36 95       	lsr	r19
    1fcc:	27 95       	ror	r18
    1fce:	36 95       	lsr	r19
    1fd0:	27 95       	ror	r18
    1fd2:	a5 ec       	ldi	r26, 0xC5	; 197
    1fd4:	b0 e2       	ldi	r27, 0x20	; 32
    1fd6:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <__umulhisi3>
    1fda:	ac 01       	movw	r20, r24
    1fdc:	52 95       	swap	r21
    1fde:	42 95       	swap	r20
    1fe0:	4f 70       	andi	r20, 0x0F	; 15
    1fe2:	45 27       	eor	r20, r21
    1fe4:	5f 70       	andi	r21, 0x0F	; 15
    1fe6:	45 27       	eor	r20, r21
    1fe8:	9a 01       	movw	r18, r20
    1fea:	ad ec       	ldi	r26, 0xCD	; 205
    1fec:	bc ec       	ldi	r27, 0xCC	; 204
    1fee:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <__umulhisi3>
    1ff2:	96 95       	lsr	r25
    1ff4:	87 95       	ror	r24
    1ff6:	96 95       	lsr	r25
    1ff8:	87 95       	ror	r24
    1ffa:	96 95       	lsr	r25
    1ffc:	87 95       	ror	r24
    1ffe:	9c 01       	movw	r18, r24
    2000:	22 0f       	add	r18, r18
    2002:	33 1f       	adc	r19, r19
    2004:	88 0f       	add	r24, r24
    2006:	99 1f       	adc	r25, r25
    2008:	88 0f       	add	r24, r24
    200a:	99 1f       	adc	r25, r25
    200c:	88 0f       	add	r24, r24
    200e:	99 1f       	adc	r25, r25
    2010:	82 0f       	add	r24, r18
    2012:	93 1f       	adc	r25, r19
    2014:	48 1b       	sub	r20, r24
    2016:	59 0b       	sbc	r21, r25
    2018:	40 83       	st	Z, r20
	result[1]=x%10;
    201a:	96 01       	movw	r18, r12
    201c:	36 95       	lsr	r19
    201e:	27 95       	ror	r18
    2020:	36 95       	lsr	r19
    2022:	27 95       	ror	r18
    2024:	ab e7       	ldi	r26, 0x7B	; 123
    2026:	b4 e1       	ldi	r27, 0x14	; 20
    2028:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <__umulhisi3>
    202c:	ac 01       	movw	r20, r24
    202e:	56 95       	lsr	r21
    2030:	47 95       	ror	r20
    2032:	9a 01       	movw	r18, r20
    2034:	ad ec       	ldi	r26, 0xCD	; 205
    2036:	bc ec       	ldi	r27, 0xCC	; 204
    2038:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <__umulhisi3>
    203c:	96 95       	lsr	r25
    203e:	87 95       	ror	r24
    2040:	96 95       	lsr	r25
    2042:	87 95       	ror	r24
    2044:	96 95       	lsr	r25
    2046:	87 95       	ror	r24
    2048:	9c 01       	movw	r18, r24
    204a:	22 0f       	add	r18, r18
    204c:	33 1f       	adc	r19, r19
    204e:	88 0f       	add	r24, r24
    2050:	99 1f       	adc	r25, r25
    2052:	88 0f       	add	r24, r24
    2054:	99 1f       	adc	r25, r25
    2056:	88 0f       	add	r24, r24
    2058:	99 1f       	adc	r25, r25
    205a:	82 0f       	add	r24, r18
    205c:	93 1f       	adc	r25, r19
    205e:	48 1b       	sub	r20, r24
    2060:	59 0b       	sbc	r21, r25
    2062:	41 83       	std	Z+1, r20	; 0x01
	result[2]=w%10;
    2064:	96 01       	movw	r18, r12
    2066:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <__umulhisi3>
    206a:	ac 01       	movw	r20, r24
    206c:	56 95       	lsr	r21
    206e:	47 95       	ror	r20
    2070:	56 95       	lsr	r21
    2072:	47 95       	ror	r20
    2074:	56 95       	lsr	r21
    2076:	47 95       	ror	r20
    2078:	9a 01       	movw	r18, r20
    207a:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <__umulhisi3>
    207e:	96 95       	lsr	r25
    2080:	87 95       	ror	r24
    2082:	96 95       	lsr	r25
    2084:	87 95       	ror	r24
    2086:	96 95       	lsr	r25
    2088:	87 95       	ror	r24
    208a:	9c 01       	movw	r18, r24
    208c:	22 0f       	add	r18, r18
    208e:	33 1f       	adc	r19, r19
    2090:	88 0f       	add	r24, r24
    2092:	99 1f       	adc	r25, r25
    2094:	88 0f       	add	r24, r24
    2096:	99 1f       	adc	r25, r25
    2098:	88 0f       	add	r24, r24
    209a:	99 1f       	adc	r25, r25
    209c:	82 0f       	add	r24, r18
    209e:	93 1f       	adc	r25, r19
    20a0:	9a 01       	movw	r18, r20
    20a2:	28 1b       	sub	r18, r24
    20a4:	39 0b       	sbc	r19, r25
    20a6:	22 83       	std	Z+2, r18	; 0x02
	result[3]=z%10;
    20a8:	ca 01       	movw	r24, r20
    20aa:	88 0f       	add	r24, r24
    20ac:	99 1f       	adc	r25, r25
    20ae:	44 0f       	add	r20, r20
    20b0:	55 1f       	adc	r21, r21
    20b2:	44 0f       	add	r20, r20
    20b4:	55 1f       	adc	r21, r21
    20b6:	44 0f       	add	r20, r20
    20b8:	55 1f       	adc	r21, r21
    20ba:	48 0f       	add	r20, r24
    20bc:	59 1f       	adc	r21, r25
    20be:	c4 1a       	sub	r12, r20
    20c0:	d5 0a       	sbc	r13, r21
    20c2:	c3 82       	std	Z+3, r12	; 0x03
// 	LCD_sendData(d4+0x30);
// 	LCD_sendData(223);

	//return generateArrayTemperature(d1, d2, d3, d4);
	return result;
}
    20c4:	cf 01       	movw	r24, r30
    20c6:	ff 90       	pop	r15
    20c8:	ef 90       	pop	r14
    20ca:	df 90       	pop	r13
    20cc:	cf 90       	pop	r12
    20ce:	08 95       	ret

000020d0 <LCD_sendTemp>:

 void LCD_sendTemp (unsigned char d1, unsigned char d2, unsigned char d3, unsigned char d4){
    20d0:	1f 93       	push	r17
    20d2:	cf 93       	push	r28
    20d4:	df 93       	push	r29
    20d6:	16 2f       	mov	r17, r22
    20d8:	d4 2f       	mov	r29, r20
    20da:	c2 2f       	mov	r28, r18
 	LCD_sendData(d1+0x30);
    20dc:	80 5d       	subi	r24, 0xD0	; 208
    20de:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
 	LCD_sendData(d2+0x30);
    20e2:	80 e3       	ldi	r24, 0x30	; 48
    20e4:	81 0f       	add	r24, r17
    20e6:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
 	LCD_sendData('.');
    20ea:	8e e2       	ldi	r24, 0x2E	; 46
    20ec:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
 	LCD_sendData(d3+0x30);
    20f0:	80 e3       	ldi	r24, 0x30	; 48
    20f2:	8d 0f       	add	r24, r29
    20f4:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
 	LCD_sendData(d4+0x30);
    20f8:	80 e3       	ldi	r24, 0x30	; 48
    20fa:	8c 0f       	add	r24, r28
    20fc:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
 	LCD_sendData(223);	
    2100:	8f ed       	ldi	r24, 0xDF	; 223
    2102:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
}
    2106:	df 91       	pop	r29
    2108:	cf 91       	pop	r28
    210a:	1f 91       	pop	r17
    210c:	08 95       	ret

0000210e <temperatureSendTask>:
			}
		}
	}
}
	
void temperatureSendTask (void* parameter){
    210e:	cf 93       	push	r28
    2110:	df 93       	push	r29
    2112:	00 d0       	rcall	.+0      	; 0x2114 <temperatureSendTask+0x6>
    2114:	00 d0       	rcall	.+0      	; 0x2116 <temperatureSendTask+0x8>
    2116:	cd b7       	in	r28, 0x3d	; 61
    2118:	de b7       	in	r29, 0x3e	; 62
	
	float temperature;
	for (;;)
	{
		if( xQueueTemperatureSendings != NULL )
    211a:	80 91 8a 08 	lds	r24, 0x088A	; 0x80088a <xQueueTemperatureSendings>
    211e:	90 91 8b 08 	lds	r25, 0x088B	; 0x80088b <xQueueTemperatureSendings+0x1>
    2122:	00 97       	sbiw	r24, 0x00	; 0
    2124:	f1 f3       	breq	.-4      	; 0x2122 <temperatureSendTask+0x14>
		{
		 /* Receive a message from the created queue to hold pointers.  Block for 10
		ticks if a message is not immediately available.  The value is read into a
		 pointer variable, and as the value received is the address of the xMessage
		variable, after this call pxRxedPointer will point to xMessage. */
			if( xQueueReceive( xQueueTemperatureSendings,
    2126:	20 e0       	ldi	r18, 0x00	; 0
    2128:	44 e6       	ldi	r20, 0x64	; 100
    212a:	50 e0       	ldi	r21, 0x00	; 0
    212c:	be 01       	movw	r22, r28
    212e:	6f 5f       	subi	r22, 0xFF	; 255
    2130:	7f 4f       	sbci	r23, 0xFF	; 255
    2132:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    2136:	81 30       	cpi	r24, 0x01	; 1
    2138:	81 f7       	brne	.-32     	; 0x211a <temperatureSendTask+0xc>
                         &temperature,
                         100 ) == pdPASS )
						 
			{
				
				unsigned char *values = convertTemperature(temperature);
    213a:	69 81       	ldd	r22, Y+1	; 0x01
    213c:	7a 81       	ldd	r23, Y+2	; 0x02
    213e:	8b 81       	ldd	r24, Y+3	; 0x03
    2140:	9c 81       	ldd	r25, Y+4	; 0x04
    2142:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <convertTemperature>
    2146:	8c 01       	movw	r16, r24
				char *jsonDataTemperature = generateArrayTemperature(values[0], values[1], values[2], values[3]);
    2148:	fc 01       	movw	r30, r24
    214a:	23 81       	ldd	r18, Z+3	; 0x03
    214c:	42 81       	ldd	r20, Z+2	; 0x02
    214e:	61 81       	ldd	r22, Z+1	; 0x01
    2150:	80 81       	ld	r24, Z
    2152:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <generateArrayTemperature>
    2156:	7c 01       	movw	r14, r24
				vTaskDelay(pdMS_TO_TICKS(1500));
    2158:	8a e3       	ldi	r24, 0x3A	; 58
    215a:	90 e0       	ldi	r25, 0x00	; 0
    215c:	0e 94 9f 08 	call	0x113e	; 0x113e <vTaskDelay>
				
				
				if( xSemaphoreTake( xSemaphoreLCD, ( TickType_t ) 100 ) == pdTRUE )
    2160:	20 e0       	ldi	r18, 0x00	; 0
    2162:	44 e6       	ldi	r20, 0x64	; 100
    2164:	50 e0       	ldi	r21, 0x00	; 0
    2166:	60 e0       	ldi	r22, 0x00	; 0
    2168:	70 e0       	ldi	r23, 0x00	; 0
    216a:	80 91 80 08 	lds	r24, 0x0880	; 0x800880 <xSemaphoreLCD>
    216e:	90 91 81 08 	lds	r25, 0x0881	; 0x800881 <xSemaphoreLCD+0x1>
    2172:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    2176:	81 30       	cpi	r24, 0x01	; 1
    2178:	b1 f4       	brne	.+44     	; 0x21a6 <temperatureSendTask+0x98>
				{
					LCD_goToXY(6,1);
    217a:	61 e0       	ldi	r22, 0x01	; 1
    217c:	86 e0       	ldi	r24, 0x06	; 6
    217e:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <LCD_goToXY>
					LCD_sendTemp(values[0], values[1], values[2], values[3]);
    2182:	f8 01       	movw	r30, r16
    2184:	23 81       	ldd	r18, Z+3	; 0x03
    2186:	42 81       	ldd	r20, Z+2	; 0x02
    2188:	61 81       	ldd	r22, Z+1	; 0x01
    218a:	80 81       	ld	r24, Z
    218c:	0e 94 68 10 	call	0x20d0	; 0x20d0 <LCD_sendTemp>
					xSemaphoreGive( xSemaphoreLCD );
    2190:	20 e0       	ldi	r18, 0x00	; 0
    2192:	40 e0       	ldi	r20, 0x00	; 0
    2194:	50 e0       	ldi	r21, 0x00	; 0
    2196:	60 e0       	ldi	r22, 0x00	; 0
    2198:	70 e0       	ldi	r23, 0x00	; 0
    219a:	80 91 80 08 	lds	r24, 0x0880	; 0x800880 <xSemaphoreLCD>
    219e:	90 91 81 08 	lds	r25, 0x0881	; 0x800881 <xSemaphoreLCD+0x1>
    21a2:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
				}	
				
				if( xSemaphoreTake( xSemaphoreUART, ( TickType_t ) 100 ) == pdTRUE )
    21a6:	20 e0       	ldi	r18, 0x00	; 0
    21a8:	44 e6       	ldi	r20, 0x64	; 100
    21aa:	50 e0       	ldi	r21, 0x00	; 0
    21ac:	60 e0       	ldi	r22, 0x00	; 0
    21ae:	70 e0       	ldi	r23, 0x00	; 0
    21b0:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    21b4:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    21b8:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    21bc:	81 30       	cpi	r24, 0x01	; 1
    21be:	09 f0       	breq	.+2      	; 0x21c2 <temperatureSendTask+0xb4>
    21c0:	ac cf       	rjmp	.-168    	; 0x211a <temperatureSendTask+0xc>
				{
					/* We were able to obtain the semaphore and can now access the
					shared resource. */
					
					UART_sendString(jsonDataTemperature);
    21c2:	c7 01       	movw	r24, r14
    21c4:	0e 94 83 0f 	call	0x1f06	; 0x1f06 <UART_sendString>
					
					/* We have finished accessing the shared resource.  Release the
					semaphore. */
					xSemaphoreGive( xSemaphoreUART );
    21c8:	20 e0       	ldi	r18, 0x00	; 0
    21ca:	40 e0       	ldi	r20, 0x00	; 0
    21cc:	50 e0       	ldi	r21, 0x00	; 0
    21ce:	60 e0       	ldi	r22, 0x00	; 0
    21d0:	70 e0       	ldi	r23, 0x00	; 0
    21d2:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    21d6:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    21da:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
    21de:	9d cf       	rjmp	.-198    	; 0x211a <temperatureSendTask+0xc>

000021e0 <convertAir>:

	return jsonDataAirT2;
	
}

unsigned char* convertAir(float value){
    21e0:	cf 92       	push	r12
    21e2:	df 92       	push	r13
    21e4:	ef 92       	push	r14
    21e6:	ff 92       	push	r15
	//3 digit: 000 -> 999 
	unsigned int x,y,w;
	
	static unsigned char result[3];
	
	w = value;
    21e8:	0e 94 2c 14 	call	0x2858	; 0x2858 <__fixunssfsi>
    21ec:	6b 01       	movw	r12, r22
    21ee:	7c 01       	movw	r14, r24
	x=w/10;
	y=x/10;
	
	result[0]=y%10;
    21f0:	e2 e4       	ldi	r30, 0x42	; 66
    21f2:	f8 e0       	ldi	r31, 0x08	; 8
    21f4:	9b 01       	movw	r18, r22
    21f6:	36 95       	lsr	r19
    21f8:	27 95       	ror	r18
    21fa:	36 95       	lsr	r19
    21fc:	27 95       	ror	r18
    21fe:	ab e7       	ldi	r26, 0x7B	; 123
    2200:	b4 e1       	ldi	r27, 0x14	; 20
    2202:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <__umulhisi3>
    2206:	ac 01       	movw	r20, r24
    2208:	56 95       	lsr	r21
    220a:	47 95       	ror	r20
    220c:	9a 01       	movw	r18, r20
    220e:	ad ec       	ldi	r26, 0xCD	; 205
    2210:	bc ec       	ldi	r27, 0xCC	; 204
    2212:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <__umulhisi3>
    2216:	96 95       	lsr	r25
    2218:	87 95       	ror	r24
    221a:	96 95       	lsr	r25
    221c:	87 95       	ror	r24
    221e:	96 95       	lsr	r25
    2220:	87 95       	ror	r24
    2222:	9c 01       	movw	r18, r24
    2224:	22 0f       	add	r18, r18
    2226:	33 1f       	adc	r19, r19
    2228:	88 0f       	add	r24, r24
    222a:	99 1f       	adc	r25, r25
    222c:	88 0f       	add	r24, r24
    222e:	99 1f       	adc	r25, r25
    2230:	88 0f       	add	r24, r24
    2232:	99 1f       	adc	r25, r25
    2234:	82 0f       	add	r24, r18
    2236:	93 1f       	adc	r25, r19
    2238:	48 1b       	sub	r20, r24
    223a:	59 0b       	sbc	r21, r25
    223c:	40 83       	st	Z, r20
	result[1]=x%10;
    223e:	96 01       	movw	r18, r12
    2240:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <__umulhisi3>
    2244:	ac 01       	movw	r20, r24
    2246:	56 95       	lsr	r21
    2248:	47 95       	ror	r20
    224a:	56 95       	lsr	r21
    224c:	47 95       	ror	r20
    224e:	56 95       	lsr	r21
    2250:	47 95       	ror	r20
    2252:	9a 01       	movw	r18, r20
    2254:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <__umulhisi3>
    2258:	96 95       	lsr	r25
    225a:	87 95       	ror	r24
    225c:	96 95       	lsr	r25
    225e:	87 95       	ror	r24
    2260:	96 95       	lsr	r25
    2262:	87 95       	ror	r24
    2264:	9c 01       	movw	r18, r24
    2266:	22 0f       	add	r18, r18
    2268:	33 1f       	adc	r19, r19
    226a:	88 0f       	add	r24, r24
    226c:	99 1f       	adc	r25, r25
    226e:	88 0f       	add	r24, r24
    2270:	99 1f       	adc	r25, r25
    2272:	88 0f       	add	r24, r24
    2274:	99 1f       	adc	r25, r25
    2276:	82 0f       	add	r24, r18
    2278:	93 1f       	adc	r25, r19
    227a:	9a 01       	movw	r18, r20
    227c:	28 1b       	sub	r18, r24
    227e:	39 0b       	sbc	r19, r25
    2280:	21 83       	std	Z+1, r18	; 0x01
	result[2]=w%10;
    2282:	ca 01       	movw	r24, r20
    2284:	88 0f       	add	r24, r24
    2286:	99 1f       	adc	r25, r25
    2288:	44 0f       	add	r20, r20
    228a:	55 1f       	adc	r21, r21
    228c:	44 0f       	add	r20, r20
    228e:	55 1f       	adc	r21, r21
    2290:	44 0f       	add	r20, r20
    2292:	55 1f       	adc	r21, r21
    2294:	48 0f       	add	r20, r24
    2296:	59 1f       	adc	r21, r25
    2298:	c4 1a       	sub	r12, r20
    229a:	d5 0a       	sbc	r13, r21
    229c:	c2 82       	std	Z+2, r12	; 0x02
// 	LCD_sendData(d2+ASCII_OFFSET);
// 	LCD_sendData(d3+ASCII_OFFSET);

	//return generateArrayAir(d1, d2, d3);
	return result;
}
    229e:	cf 01       	movw	r24, r30
    22a0:	ff 90       	pop	r15
    22a2:	ef 90       	pop	r14
    22a4:	df 90       	pop	r13
    22a6:	cf 90       	pop	r12
    22a8:	08 95       	ret

000022aa <LCD_sendAir>:

 void LCD_sendAir (unsigned char d1, unsigned char d2, unsigned char d3){
    22aa:	cf 93       	push	r28
    22ac:	df 93       	push	r29
    22ae:	d6 2f       	mov	r29, r22
    22b0:	c4 2f       	mov	r28, r20
	LCD_sendData(d1+ASCII_OFFSET);
    22b2:	80 5d       	subi	r24, 0xD0	; 208
    22b4:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
	LCD_sendData(d2+ASCII_OFFSET);
    22b8:	80 e3       	ldi	r24, 0x30	; 48
    22ba:	8d 0f       	add	r24, r29
    22bc:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
	LCD_sendData(d3+ASCII_OFFSET);
    22c0:	80 e3       	ldi	r24, 0x30	; 48
    22c2:	8c 0f       	add	r24, r28
    22c4:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
 }
    22c8:	df 91       	pop	r29
    22ca:	cf 91       	pop	r28
    22cc:	08 95       	ret

000022ce <airSendTask>:
			}
		}
	}//FOR	
}//READING AIR

void airSendTask (void* parameter){
    22ce:	cf 93       	push	r28
    22d0:	df 93       	push	r29
    22d2:	cd b7       	in	r28, 0x3d	; 61
    22d4:	de b7       	in	r29, 0x3e	; 62
    22d6:	6c 97       	sbiw	r28, 0x1c	; 28
    22d8:	0f b6       	in	r0, 0x3f	; 63
    22da:	f8 94       	cli
    22dc:	de bf       	out	0x3e, r29	; 62
    22de:	0f be       	out	0x3f, r0	; 63
    22e0:	cd bf       	out	0x3d, r28	; 61
    22e2:	8e 01       	movw	r16, r28
    22e4:	03 5e       	subi	r16, 0xE3	; 227
    22e6:	1f 4f       	sbci	r17, 0xFF	; 255
	for (int i = 0; i<len; i++){
		jsonDataAirT2[i] = jsonDataAir[i];
	}

		
	jsonDataAirT2 [len-1] = ':';
    22e8:	0f 2e       	mov	r0, r31
    22ea:	f0 e1       	ldi	r31, 0x10	; 16
    22ec:	cf 2e       	mov	r12, r31
    22ee:	f8 e0       	ldi	r31, 0x08	; 8
    22f0:	df 2e       	mov	r13, r31
    22f2:	f0 2d       	mov	r31, r0
    22f4:	0f 2e       	mov	r0, r31
    22f6:	fa e3       	ldi	r31, 0x3A	; 58
    22f8:	9f 2e       	mov	r9, r31
    22fa:	f0 2d       	mov	r31, r0
		jsonDataAirT2 [len+1] = d2+ASCII_OFFSET;
	}
		
	jsonDataAirT2 [len+2] = d3+ASCII_OFFSET;
		
	jsonDataAirT2 [len+3] = '.';
    22fc:	0f 2e       	mov	r0, r31
    22fe:	fe e2       	ldi	r31, 0x2E	; 46
    2300:	af 2e       	mov	r10, r31
    2302:	f0 2d       	mov	r31, r0
 	LCD_sendData(223);	
}

static char* generateArrayAir(unsigned char d1, unsigned char d2, unsigned char d3){
	char jsonDataAir [] = "{\"sensor\":\"air\",\"value\"";
	int len = sizeof(jsonDataAir)/sizeof(jsonDataAir[0]);
    2304:	0f 2e       	mov	r0, r31
    2306:	f8 e1       	ldi	r31, 0x18	; 24
    2308:	5f 2e       	mov	r5, r31
    230a:	f0 2d       	mov	r31, r0
    230c:	61 2c       	mov	r6, r1
		
	jsonDataAirT2 [len-1] = ':';

	if ((d1+ASCII_OFFSET) == '0'){ //excluding 0 when the value is < 100
		jsonDataAirT2 [len] = d2+ASCII_OFFSET;
		len = len -1;
    230e:	0f 2e       	mov	r0, r31
    2310:	f7 e1       	ldi	r31, 0x17	; 23
    2312:	3f 2e       	mov	r3, r31
    2314:	f0 2d       	mov	r31, r0
    2316:	41 2c       	mov	r4, r1
	}
		
	jsonDataAirT2 [len+2] = d3+ASCII_OFFSET;
		
	jsonDataAirT2 [len+3] = '.';
	jsonDataAirT2 [len+4] = '0';
    2318:	0f 2e       	mov	r0, r31
    231a:	f0 e3       	ldi	r31, 0x30	; 48
    231c:	bf 2e       	mov	r11, r31
    231e:	f0 2d       	mov	r31, r0
	jsonDataAirT2 [len+5] = '0';
		
	jsonDataAirT2 [len+6] = '}';
    2320:	0f 2e       	mov	r0, r31
    2322:	fd e7       	ldi	r31, 0x7D	; 125
    2324:	7f 2e       	mov	r7, r31
    2326:	f0 2d       	mov	r31, r0
	
	jsonDataAirT2 [len+7] = '\n';
    2328:	0f 2e       	mov	r0, r31
    232a:	fa e0       	ldi	r31, 0x0A	; 10
    232c:	8f 2e       	mov	r8, r31
    232e:	f0 2d       	mov	r31, r0
void airSendTask (void* parameter){
	
	float air;
	for (;;)
 	{	
 		if( xQueueAirSendings != NULL )
    2330:	80 91 9e 08 	lds	r24, 0x089E	; 0x80089e <xQueueAirSendings>
    2334:	90 91 9f 08 	lds	r25, 0x089F	; 0x80089f <xQueueAirSendings+0x1>
    2338:	00 97       	sbiw	r24, 0x00	; 0
    233a:	f1 f3       	breq	.-4      	; 0x2338 <airSendTask+0x6a>
 		{
 			if( xQueueReceive( xQueueAirSendings,
    233c:	20 e0       	ldi	r18, 0x00	; 0
    233e:	44 e6       	ldi	r20, 0x64	; 100
    2340:	50 e0       	ldi	r21, 0x00	; 0
    2342:	be 01       	movw	r22, r28
    2344:	6f 5f       	subi	r22, 0xFF	; 255
    2346:	7f 4f       	sbci	r23, 0xFF	; 255
    2348:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    234c:	81 30       	cpi	r24, 0x01	; 1
    234e:	81 f7       	brne	.-32     	; 0x2330 <airSendTask+0x62>
                          &( air ),
                          ( TickType_t ) 100 ) == pdPASS )		 
 			{
				unsigned char *values = convertAir(air);
    2350:	69 81       	ldd	r22, Y+1	; 0x01
    2352:	7a 81       	ldd	r23, Y+2	; 0x02
    2354:	8b 81       	ldd	r24, Y+3	; 0x03
    2356:	9c 81       	ldd	r25, Y+4	; 0x04
    2358:	0e 94 f0 10 	call	0x21e0	; 0x21e0 <convertAir>
    235c:	7c 01       	movw	r14, r24
				char *jsonDataAir = generateArrayAir(values[0], values[1], values[2]);
    235e:	fc 01       	movw	r30, r24
    2360:	92 81       	ldd	r25, Z+2	; 0x02
    2362:	21 81       	ldd	r18, Z+1	; 0x01
    2364:	30 81       	ld	r19, Z
 	LCD_sendData(d4+0x30);
 	LCD_sendData(223);	
}

static char* generateArrayAir(unsigned char d1, unsigned char d2, unsigned char d3){
	char jsonDataAir [] = "{\"sensor\":\"air\",\"value\"";
    2366:	88 e1       	ldi	r24, 0x18	; 24
    2368:	e2 e3       	ldi	r30, 0x32	; 50
    236a:	f1 e0       	ldi	r31, 0x01	; 1
    236c:	de 01       	movw	r26, r28
    236e:	15 96       	adiw	r26, 0x05	; 5
    2370:	01 90       	ld	r0, Z+
    2372:	0d 92       	st	X+, r0
    2374:	8a 95       	dec	r24
    2376:	e1 f7       	brne	.-8      	; 0x2370 <airSendTask+0xa2>
    2378:	fe 01       	movw	r30, r28
    237a:	35 96       	adiw	r30, 0x05	; 5
    237c:	a0 e1       	ldi	r26, 0x10	; 16
    237e:	b8 e0       	ldi	r27, 0x08	; 8
	int len = sizeof(jsonDataAir)/sizeof(jsonDataAir[0]);
	//char *jsonDataAirT2 = malloc(len+8);
	static char jsonDataAirT2 [SIZE_ARRAY];
		
	for (int i = 0; i<len; i++){
		jsonDataAirT2[i] = jsonDataAir[i];
    2380:	81 91       	ld	r24, Z+
    2382:	8d 93       	st	X+, r24
	char jsonDataAir [] = "{\"sensor\":\"air\",\"value\"";
	int len = sizeof(jsonDataAir)/sizeof(jsonDataAir[0]);
	//char *jsonDataAirT2 = malloc(len+8);
	static char jsonDataAirT2 [SIZE_ARRAY];
		
	for (int i = 0; i<len; i++){
    2384:	e0 17       	cp	r30, r16
    2386:	f1 07       	cpc	r31, r17
    2388:	d9 f7       	brne	.-10     	; 0x2380 <airSendTask+0xb2>
		jsonDataAirT2[i] = jsonDataAir[i];
	}

		
	jsonDataAirT2 [len-1] = ':';
    238a:	f6 01       	movw	r30, r12
    238c:	97 8a       	std	Z+23, r9	; 0x17

	if ((d1+ASCII_OFFSET) == '0'){ //excluding 0 when the value is < 100
    238e:	31 11       	cpse	r19, r1
    2390:	05 c0       	rjmp	.+10     	; 0x239c <airSendTask+0xce>
		jsonDataAirT2 [len] = d2+ASCII_OFFSET;
    2392:	20 5d       	subi	r18, 0xD0	; 208
    2394:	20 8f       	std	Z+24, r18	; 0x18
		len = len -1;
    2396:	e3 2d       	mov	r30, r3
    2398:	f4 2d       	mov	r31, r4
    239a:	07 c0       	rjmp	.+14     	; 0x23aa <airSendTask+0xdc>
		} else {
		jsonDataAirT2 [len] = d1+ASCII_OFFSET;
    239c:	30 5d       	subi	r19, 0xD0	; 208
    239e:	f6 01       	movw	r30, r12
    23a0:	30 8f       	std	Z+24, r19	; 0x18
		jsonDataAirT2 [len+1] = d2+ASCII_OFFSET;
    23a2:	20 5d       	subi	r18, 0xD0	; 208
    23a4:	21 8f       	std	Z+25, r18	; 0x19
 	LCD_sendData(223);	
}

static char* generateArrayAir(unsigned char d1, unsigned char d2, unsigned char d3){
	char jsonDataAir [] = "{\"sensor\":\"air\",\"value\"";
	int len = sizeof(jsonDataAir)/sizeof(jsonDataAir[0]);
    23a6:	e5 2d       	mov	r30, r5
    23a8:	f6 2d       	mov	r31, r6
		} else {
		jsonDataAirT2 [len] = d1+ASCII_OFFSET;
		jsonDataAirT2 [len+1] = d2+ASCII_OFFSET;
	}
		
	jsonDataAirT2 [len+2] = d3+ASCII_OFFSET;
    23aa:	e0 5f       	subi	r30, 0xF0	; 240
    23ac:	f7 4f       	sbci	r31, 0xF7	; 247
    23ae:	90 5d       	subi	r25, 0xD0	; 208
    23b0:	92 83       	std	Z+2, r25	; 0x02
		
	jsonDataAirT2 [len+3] = '.';
    23b2:	a3 82       	std	Z+3, r10	; 0x03
	jsonDataAirT2 [len+4] = '0';
    23b4:	b4 82       	std	Z+4, r11	; 0x04
	jsonDataAirT2 [len+5] = '0';
    23b6:	b5 82       	std	Z+5, r11	; 0x05
		
	jsonDataAirT2 [len+6] = '}';
    23b8:	76 82       	std	Z+6, r7	; 0x06
	
	jsonDataAirT2 [len+7] = '\n';
    23ba:	87 82       	std	Z+7, r8	; 0x07
	jsonDataAirT2 [len+8] = '\0';
    23bc:	10 86       	std	Z+8, r1	; 0x08
                          &( air ),
                          ( TickType_t ) 100 ) == pdPASS )		 
 			{
				unsigned char *values = convertAir(air);
				char *jsonDataAir = generateArrayAir(values[0], values[1], values[2]);
				vTaskDelay(pdMS_TO_TICKS(1500));
    23be:	8a e3       	ldi	r24, 0x3A	; 58
    23c0:	90 e0       	ldi	r25, 0x00	; 0
    23c2:	0e 94 9f 08 	call	0x113e	; 0x113e <vTaskDelay>
				
				if( xSemaphoreTake( xSemaphoreLCD, ( TickType_t ) 100 ) == pdTRUE )
    23c6:	20 e0       	ldi	r18, 0x00	; 0
    23c8:	44 e6       	ldi	r20, 0x64	; 100
    23ca:	50 e0       	ldi	r21, 0x00	; 0
    23cc:	60 e0       	ldi	r22, 0x00	; 0
    23ce:	70 e0       	ldi	r23, 0x00	; 0
    23d0:	80 91 80 08 	lds	r24, 0x0880	; 0x800880 <xSemaphoreLCD>
    23d4:	90 91 81 08 	lds	r25, 0x0881	; 0x800881 <xSemaphoreLCD+0x1>
    23d8:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    23dc:	81 30       	cpi	r24, 0x01	; 1
    23de:	a9 f4       	brne	.+42     	; 0x240a <airSendTask+0x13c>
				{
					LCD_goToXY(6,2);
    23e0:	62 e0       	ldi	r22, 0x02	; 2
    23e2:	86 e0       	ldi	r24, 0x06	; 6
    23e4:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <LCD_goToXY>
					LCD_sendAir(values[0], values[1], values[2]);
    23e8:	f7 01       	movw	r30, r14
    23ea:	42 81       	ldd	r20, Z+2	; 0x02
    23ec:	61 81       	ldd	r22, Z+1	; 0x01
    23ee:	80 81       	ld	r24, Z
    23f0:	0e 94 55 11 	call	0x22aa	; 0x22aa <LCD_sendAir>
					xSemaphoreGive( xSemaphoreLCD );
    23f4:	20 e0       	ldi	r18, 0x00	; 0
    23f6:	40 e0       	ldi	r20, 0x00	; 0
    23f8:	50 e0       	ldi	r21, 0x00	; 0
    23fa:	60 e0       	ldi	r22, 0x00	; 0
    23fc:	70 e0       	ldi	r23, 0x00	; 0
    23fe:	80 91 80 08 	lds	r24, 0x0880	; 0x800880 <xSemaphoreLCD>
    2402:	90 91 81 08 	lds	r25, 0x0881	; 0x800881 <xSemaphoreLCD+0x1>
    2406:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
				}
				
				if( xSemaphoreTake( xSemaphoreUART, ( TickType_t ) 100 ) == pdTRUE )
    240a:	20 e0       	ldi	r18, 0x00	; 0
    240c:	44 e6       	ldi	r20, 0x64	; 100
    240e:	50 e0       	ldi	r21, 0x00	; 0
    2410:	60 e0       	ldi	r22, 0x00	; 0
    2412:	70 e0       	ldi	r23, 0x00	; 0
    2414:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    2418:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    241c:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    2420:	81 30       	cpi	r24, 0x01	; 1
    2422:	09 f0       	breq	.+2      	; 0x2426 <airSendTask+0x158>
    2424:	85 cf       	rjmp	.-246    	; 0x2330 <airSendTask+0x62>
				{
					/* We were able to obtain the semaphore and can now access the
					shared resource. */
					UART_sendString(jsonDataAir);
    2426:	c6 01       	movw	r24, r12
    2428:	0e 94 83 0f 	call	0x1f06	; 0x1f06 <UART_sendString>
					
					/* We have finished accessing the shared resource.  Release the
					semaphore. */
					xSemaphoreGive( xSemaphoreUART );
    242c:	20 e0       	ldi	r18, 0x00	; 0
    242e:	40 e0       	ldi	r20, 0x00	; 0
    2430:	50 e0       	ldi	r21, 0x00	; 0
    2432:	60 e0       	ldi	r22, 0x00	; 0
    2434:	70 e0       	ldi	r23, 0x00	; 0
    2436:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    243a:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    243e:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
    2442:	6a cf       	rjmp	.-300    	; 0x2318 <airSendTask+0x4a>

00002444 <main>:
 }
 
// MAIN PROGRAM
int main(void)
{
	alarmState = OFF;
    2444:	10 92 a0 08 	sts	0x08A0, r1	; 0x8008a0 <alarmState>
	stateBuzzer = OFF;
    2448:	10 92 7f 08 	sts	0x087F, r1	; 0x80087f <stateBuzzer>
	stateFan = OFF;
    244c:	10 92 a1 08 	sts	0x08A1, r1	; 0x8008a1 <stateFan>
}
*/

static void LCD_init()
{
  LCD_DDDR |= 0xF0;
    2450:	8a b1       	in	r24, 0x0a	; 10
    2452:	80 6f       	ori	r24, 0xF0	; 240
    2454:	8a b9       	out	0x0a, r24	; 10
  LCD_CDDR |= (1<<LCD_RS)|(1<<LCD_EN);
    2456:	84 b1       	in	r24, 0x04	; 4
    2458:	83 60       	ori	r24, 0x03	; 3
    245a:	84 b9       	out	0x04, r24	; 4
 
  LCD_CPRT &=~(1<<LCD_EN);  //LCD_EN = 0
    245c:	29 98       	cbi	0x05, 1	; 5
    245e:	8f e3       	ldi	r24, 0x3F	; 63
    2460:	9f e1       	ldi	r25, 0x1F	; 31
    2462:	01 97       	sbiw	r24, 0x01	; 1
    2464:	f1 f7       	brne	.-4      	; 0x2462 <main+0x1e>
    2466:	00 c0       	rjmp	.+0      	; 0x2468 <main+0x24>
    2468:	00 00       	nop
  _delay_us(2000);      //wait for init.

  LCD_sendCommand(0x33); //send $33 for init.
    246a:	83 e3       	ldi	r24, 0x33	; 51
    246c:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <LCD_sendCommand>
  LCD_sendCommand(0x32); //send $32 for init
    2470:	82 e3       	ldi	r24, 0x32	; 50
    2472:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <LCD_sendCommand>
  LCD_sendCommand(0x28); //init. LCD 2 line,5*7 matrix
    2476:	88 e2       	ldi	r24, 0x28	; 40
    2478:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <LCD_sendCommand>
  LCD_sendCommand(0x0C); //display on, cursor on
    247c:	8c e0       	ldi	r24, 0x0C	; 12
    247e:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <LCD_sendCommand>
  LCD_sendCommand(0x06); //shift cursor right
    2482:	86 e0       	ldi	r24, 0x06	; 6
    2484:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <LCD_sendCommand>
  LCD_putValue(data);  
}

static void LCD_clear()
{
  LCD_sendCommand(0x01);
    2488:	81 e0       	ldi	r24, 0x01	; 1
    248a:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <LCD_sendCommand>
    248e:	8f e8       	ldi	r24, 0x8F	; 143
    2490:	9a e1       	ldi	r25, 0x1A	; 26
    2492:	01 97       	sbiw	r24, 0x01	; 1
    2494:	f1 f7       	brne	.-4      	; 0x2492 <main+0x4e>
    2496:	00 c0       	rjmp	.+0      	; 0x2498 <main+0x54>
    2498:	00 00       	nop
    249a:	c0 e0       	ldi	r28, 0x00	; 0
    249c:	84 e5       	ldi	r24, 0x54	; 84
{
  unsigned char i = 0;

  while(str[i] != 0) //while it is not end of string
  {
    LCD_sendData(str[i]);
    249e:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
    i++ ;
    24a2:	cf 5f       	subi	r28, 0xFF	; 255

static void LCD_print( char * str )
{
  unsigned char i = 0;

  while(str[i] != 0) //while it is not end of string
    24a4:	ec 2f       	mov	r30, r28
    24a6:	f0 e0       	ldi	r31, 0x00	; 0
    24a8:	e6 5b       	subi	r30, 0xB6	; 182
    24aa:	fe 4f       	sbci	r31, 0xFE	; 254
    24ac:	80 81       	ld	r24, Z
    24ae:	81 11       	cpse	r24, r1
    24b0:	f6 cf       	rjmp	.-20     	; 0x249e <main+0x5a>
	stateBuzzer = OFF;
	stateFan = OFF;
	LCD_init();
	
	LCD_print("Temp:");
	LCD_goToXY(1,2);
    24b2:	62 e0       	ldi	r22, 0x02	; 2
    24b4:	81 e0       	ldi	r24, 0x01	; 1
    24b6:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <LCD_goToXY>
    24ba:	c0 e0       	ldi	r28, 0x00	; 0
    24bc:	81 e4       	ldi	r24, 0x41	; 65
{
  unsigned char i = 0;

  while(str[i] != 0) //while it is not end of string
  {
    LCD_sendData(str[i]);
    24be:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
    i++ ;
    24c2:	cf 5f       	subi	r28, 0xFF	; 255

static void LCD_print( char * str )
{
  unsigned char i = 0;

  while(str[i] != 0) //while it is not end of string
    24c4:	ec 2f       	mov	r30, r28
    24c6:	f0 e0       	ldi	r31, 0x00	; 0
    24c8:	e0 5b       	subi	r30, 0xB0	; 176
    24ca:	fe 4f       	sbci	r31, 0xFE	; 254
    24cc:	80 81       	ld	r24, Z
    24ce:	81 11       	cpse	r24, r1
    24d0:	f6 cf       	rjmp	.-20     	; 0x24be <main+0x7a>
}

static void UART_init()
{
	// Setup transmission speed
	UBRR0H = (BAUD_PRESCALER >> 8);
    24d2:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
	UBRR0L = BAUD_PRESCALER;
    24d6:	87 e6       	ldi	r24, 0x67	; 103
    24d8:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
	
	// Enable transmission and receiving (FULL DUPLEX)
	UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
    24dc:	88 e9       	ldi	r24, 0x98	; 152
    24de:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
	
	// Setup data format: 8 bit data, 1 stop bit
	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);
    24e2:	86 e0       	ldi	r24, 0x06	; 6
    24e4:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__DATA_REGION_ORIGIN__+0x62>
  }
}

static void portInit (void){
	
	DDRC = 0; //make Porct C an input for ADC input
    24e8:	17 b8       	out	0x07, r1	; 7
	DDRD = 0xFF; //make port D output
    24ea:	8f ef       	ldi	r24, 0xFF	; 255
    24ec:	8a b9       	out	0x0a, r24	; 10
	//DDRD |= (1<<PD3);
	DDRB |= (1 << 3) | (1 << 2) | (1 << 4); //make port b output for PB3, PB2, PB4
    24ee:	84 b1       	in	r24, 0x04	; 4
    24f0:	8c 61       	ori	r24, 0x1C	; 28
    24f2:	84 b9       	out	0x04, r24	; 4

	UART_init();
	
	portInit();
	
	xTimerReadings = xTimerCreate ("Timer", 5000, pdTRUE, ( void * ) 0, vTimerCallback);
    24f4:	06 e3       	ldi	r16, 0x36	; 54
    24f6:	1f e0       	ldi	r17, 0x0F	; 15
    24f8:	20 e0       	ldi	r18, 0x00	; 0
    24fa:	30 e0       	ldi	r19, 0x00	; 0
    24fc:	41 e0       	ldi	r20, 0x01	; 1
    24fe:	68 e8       	ldi	r22, 0x88	; 136
    2500:	73 e1       	ldi	r23, 0x13	; 19
    2502:	85 e5       	ldi	r24, 0x55	; 85
    2504:	91 e0       	ldi	r25, 0x01	; 1
    2506:	0e 94 ef 0a 	call	0x15de	; 0x15de <xTimerCreate>
    250a:	90 93 85 08 	sts	0x0885, r25	; 0x800885 <xTimerReadings+0x1>
    250e:	80 93 84 08 	sts	0x0884, r24	; 0x800884 <xTimerReadings>

         if( xTimerReadings == NULL )
    2512:	89 2b       	or	r24, r25
    2514:	71 f0       	breq	.+28     	; 0x2532 <main+0xee>
         else
         {
             /* Start the timer.  No block time is specified, and
             even if one was it would be ignored because the RTOS
             scheduler has not yet been started. */
             if( xTimerStart( xTimerReadings, 0) != pdPASS )
    2516:	0e 94 5b 07 	call	0xeb6	; 0xeb6 <xTaskGetTickCount>
    251a:	00 e0       	ldi	r16, 0x00	; 0
    251c:	10 e0       	ldi	r17, 0x00	; 0
    251e:	20 e0       	ldi	r18, 0x00	; 0
    2520:	30 e0       	ldi	r19, 0x00	; 0
    2522:	ac 01       	movw	r20, r24
    2524:	61 e0       	ldi	r22, 0x01	; 1
    2526:	80 91 84 08 	lds	r24, 0x0884	; 0x800884 <xTimerReadings>
    252a:	90 91 85 08 	lds	r25, 0x0885	; 0x800885 <xTimerReadings+0x1>
    252e:	0e 94 21 0b 	call	0x1642	; 0x1642 <xTimerGenericCommand>
                 state. */
             }
         }
	
    // Attempt to create a semaphores.
    xSemaphoreADC = xSemaphoreCreateBinary();
    2532:	43 e0       	ldi	r20, 0x03	; 3
    2534:	60 e0       	ldi	r22, 0x00	; 0
    2536:	81 e0       	ldi	r24, 0x01	; 1
    2538:	0e 94 6d 03 	call	0x6da	; 0x6da <xQueueGenericCreate>
    253c:	90 93 95 08 	sts	0x0895, r25	; 0x800895 <xSemaphoreADC+0x1>
    2540:	80 93 94 08 	sts	0x0894, r24	; 0x800894 <xSemaphoreADC>
	xSemaphoreUART = xSemaphoreCreateBinary();
    2544:	43 e0       	ldi	r20, 0x03	; 3
    2546:	60 e0       	ldi	r22, 0x00	; 0
    2548:	81 e0       	ldi	r24, 0x01	; 1
    254a:	0e 94 6d 03 	call	0x6da	; 0x6da <xQueueGenericCreate>
    254e:	90 93 83 08 	sts	0x0883, r25	; 0x800883 <xSemaphoreUART+0x1>
    2552:	80 93 82 08 	sts	0x0882, r24	; 0x800882 <xSemaphoreUART>
	xSemaphoreLCD = xSemaphoreCreateBinary();
    2556:	43 e0       	ldi	r20, 0x03	; 3
    2558:	60 e0       	ldi	r22, 0x00	; 0
    255a:	81 e0       	ldi	r24, 0x01	; 1
    255c:	0e 94 6d 03 	call	0x6da	; 0x6da <xQueueGenericCreate>
    2560:	90 93 81 08 	sts	0x0881, r25	; 0x800881 <xSemaphoreLCD+0x1>
    2564:	80 93 80 08 	sts	0x0880, r24	; 0x800880 <xSemaphoreLCD>
	
	if( xSemaphoreADC != NULL )
    2568:	80 91 94 08 	lds	r24, 0x0894	; 0x800894 <xSemaphoreADC>
    256c:	90 91 95 08 	lds	r25, 0x0895	; 0x800895 <xSemaphoreADC+0x1>
    2570:	00 97       	sbiw	r24, 0x00	; 0
    2572:	39 f0       	breq	.+14     	; 0x2582 <main+0x13e>
   {
       xSemaphoreGive(xSemaphoreADC);
    2574:	20 e0       	ldi	r18, 0x00	; 0
    2576:	40 e0       	ldi	r20, 0x00	; 0
    2578:	50 e0       	ldi	r21, 0x00	; 0
    257a:	60 e0       	ldi	r22, 0x00	; 0
    257c:	70 e0       	ldi	r23, 0x00	; 0
    257e:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
   }
   
   if( xSemaphoreUART != NULL )
    2582:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    2586:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    258a:	00 97       	sbiw	r24, 0x00	; 0
    258c:	39 f0       	breq	.+14     	; 0x259c <main+0x158>
   {
       xSemaphoreGive(xSemaphoreUART);
    258e:	20 e0       	ldi	r18, 0x00	; 0
    2590:	40 e0       	ldi	r20, 0x00	; 0
    2592:	50 e0       	ldi	r21, 0x00	; 0
    2594:	60 e0       	ldi	r22, 0x00	; 0
    2596:	70 e0       	ldi	r23, 0x00	; 0
    2598:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
   }
   
   	if( xSemaphoreLCD != NULL )
    259c:	80 91 80 08 	lds	r24, 0x0880	; 0x800880 <xSemaphoreLCD>
    25a0:	90 91 81 08 	lds	r25, 0x0881	; 0x800881 <xSemaphoreLCD+0x1>
    25a4:	00 97       	sbiw	r24, 0x00	; 0
    25a6:	39 f0       	breq	.+14     	; 0x25b6 <main+0x172>
   	{
	   	xSemaphoreGive(xSemaphoreLCD);
    25a8:	20 e0       	ldi	r18, 0x00	; 0
    25aa:	40 e0       	ldi	r20, 0x00	; 0
    25ac:	50 e0       	ldi	r21, 0x00	; 0
    25ae:	60 e0       	ldi	r22, 0x00	; 0
    25b0:	70 e0       	ldi	r23, 0x00	; 0
    25b2:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
   	}
	
	xCharQueue = xQueueCreate( 2, sizeof( char * ) );
    25b6:	40 e0       	ldi	r20, 0x00	; 0
    25b8:	62 e0       	ldi	r22, 0x02	; 2
    25ba:	82 e0       	ldi	r24, 0x02	; 2
    25bc:	0e 94 6d 03 	call	0x6da	; 0x6da <xQueueGenericCreate>
    25c0:	90 93 9b 08 	sts	0x089B, r25	; 0x80089b <xCharQueue+0x1>
    25c4:	80 93 9a 08 	sts	0x089A, r24	; 0x80089a <xCharQueue>
	
	xQueueAirSendings = xQueueCreate( 2, sizeof (float) );
    25c8:	40 e0       	ldi	r20, 0x00	; 0
    25ca:	64 e0       	ldi	r22, 0x04	; 4
    25cc:	82 e0       	ldi	r24, 0x02	; 2
    25ce:	0e 94 6d 03 	call	0x6da	; 0x6da <xQueueGenericCreate>
    25d2:	90 93 9f 08 	sts	0x089F, r25	; 0x80089f <xQueueAirSendings+0x1>
    25d6:	80 93 9e 08 	sts	0x089E, r24	; 0x80089e <xQueueAirSendings>
	xQueueTemperatureSendings = xQueueCreate( 2, sizeof (float) );
    25da:	40 e0       	ldi	r20, 0x00	; 0
    25dc:	64 e0       	ldi	r22, 0x04	; 4
    25de:	82 e0       	ldi	r24, 0x02	; 2
    25e0:	0e 94 6d 03 	call	0x6da	; 0x6da <xQueueGenericCreate>
    25e4:	90 93 8b 08 	sts	0x088B, r25	; 0x80088b <xQueueTemperatureSendings+0x1>
    25e8:	80 93 8a 08 	sts	0x088A, r24	; 0x80088a <xQueueTemperatureSendings>
			
	
	
 	xTaskCreate(temperatureReadTask, "temperatureReadTask", 100, NULL, 2, &temperatureReadTaskHandle);
    25ec:	0f 2e       	mov	r0, r31
    25ee:	fc e9       	ldi	r31, 0x9C	; 156
    25f0:	ef 2e       	mov	r14, r31
    25f2:	f8 e0       	ldi	r31, 0x08	; 8
    25f4:	ff 2e       	mov	r15, r31
    25f6:	f0 2d       	mov	r31, r0
    25f8:	02 e0       	ldi	r16, 0x02	; 2
    25fa:	20 e0       	ldi	r18, 0x00	; 0
    25fc:	30 e0       	ldi	r19, 0x00	; 0
    25fe:	44 e6       	ldi	r20, 0x64	; 100
    2600:	50 e0       	ldi	r21, 0x00	; 0
    2602:	6b e5       	ldi	r22, 0x5B	; 91
    2604:	71 e0       	ldi	r23, 0x01	; 1
    2606:	82 e5       	ldi	r24, 0x52	; 82
    2608:	9e e0       	ldi	r25, 0x0E	; 14
    260a:	0e 94 cb 05 	call	0xb96	; 0xb96 <xTaskCreate>
 	
 	xTaskCreate(temperatureSendTask, "temperatureSendTask", 250, NULL, 2, &temperatureSendTaskHandle);
    260e:	0f 2e       	mov	r0, r31
    2610:	fc e8       	ldi	r31, 0x8C	; 140
    2612:	ef 2e       	mov	r14, r31
    2614:	f8 e0       	ldi	r31, 0x08	; 8
    2616:	ff 2e       	mov	r15, r31
    2618:	f0 2d       	mov	r31, r0
    261a:	20 e0       	ldi	r18, 0x00	; 0
    261c:	30 e0       	ldi	r19, 0x00	; 0
    261e:	4a ef       	ldi	r20, 0xFA	; 250
    2620:	50 e0       	ldi	r21, 0x00	; 0
    2622:	6f e6       	ldi	r22, 0x6F	; 111
    2624:	71 e0       	ldi	r23, 0x01	; 1
    2626:	87 e8       	ldi	r24, 0x87	; 135
    2628:	90 e1       	ldi	r25, 0x10	; 16
    262a:	0e 94 cb 05 	call	0xb96	; 0xb96 <xTaskCreate>
 	
 	xTaskCreate(airReadTask, "airReadTask", 100, NULL, 2, &AirReadTaskHandle);
    262e:	0f 2e       	mov	r0, r31
    2630:	f8 e9       	ldi	r31, 0x98	; 152
    2632:	ef 2e       	mov	r14, r31
    2634:	f8 e0       	ldi	r31, 0x08	; 8
    2636:	ff 2e       	mov	r15, r31
    2638:	f0 2d       	mov	r31, r0
    263a:	20 e0       	ldi	r18, 0x00	; 0
    263c:	30 e0       	ldi	r19, 0x00	; 0
    263e:	44 e6       	ldi	r20, 0x64	; 100
    2640:	50 e0       	ldi	r21, 0x00	; 0
    2642:	63 e8       	ldi	r22, 0x83	; 131
    2644:	71 e0       	ldi	r23, 0x01	; 1
    2646:	8f ec       	ldi	r24, 0xCF	; 207
    2648:	9e e0       	ldi	r25, 0x0E	; 14
    264a:	0e 94 cb 05 	call	0xb96	; 0xb96 <xTaskCreate>
 	
 	xTaskCreate(airSendTask, "airSendTask", 200, NULL, 2, &AirSendTaskHandle);
    264e:	0f 2e       	mov	r0, r31
    2650:	fe e8       	ldi	r31, 0x8E	; 142
    2652:	ef 2e       	mov	r14, r31
    2654:	f8 e0       	ldi	r31, 0x08	; 8
    2656:	ff 2e       	mov	r15, r31
    2658:	f0 2d       	mov	r31, r0
    265a:	20 e0       	ldi	r18, 0x00	; 0
    265c:	30 e0       	ldi	r19, 0x00	; 0
    265e:	48 ec       	ldi	r20, 0xC8	; 200
    2660:	50 e0       	ldi	r21, 0x00	; 0
    2662:	6f e8       	ldi	r22, 0x8F	; 143
    2664:	71 e0       	ldi	r23, 0x01	; 1
    2666:	87 e6       	ldi	r24, 0x67	; 103
    2668:	91 e1       	ldi	r25, 0x11	; 17
    266a:	0e 94 cb 05 	call	0xb96	; 0xb96 <xTaskCreate>
 	
 	xTaskCreate(serialFromISRTask, "serialFromISRTask", 100, NULL, 3, &serialFromISRTaskHandle);
    266e:	0f 2e       	mov	r0, r31
    2670:	f6 e9       	ldi	r31, 0x96	; 150
    2672:	ef 2e       	mov	r14, r31
    2674:	f8 e0       	ldi	r31, 0x08	; 8
    2676:	ff 2e       	mov	r15, r31
    2678:	f0 2d       	mov	r31, r0
    267a:	03 e0       	ldi	r16, 0x03	; 3
    267c:	20 e0       	ldi	r18, 0x00	; 0
    267e:	30 e0       	ldi	r19, 0x00	; 0
    2680:	44 e6       	ldi	r20, 0x64	; 100
    2682:	50 e0       	ldi	r21, 0x00	; 0
    2684:	6b e9       	ldi	r22, 0x9B	; 155
    2686:	71 e0       	ldi	r23, 0x01	; 1
    2688:	82 e1       	ldi	r24, 0x12	; 18
    268a:	9e e0       	ldi	r25, 0x0E	; 14
    268c:	0e 94 cb 05 	call	0xb96	; 0xb96 <xTaskCreate>
	
	sei();
    2690:	78 94       	sei
	
	// START SCHELUDER
	vTaskStartScheduler();
    2692:	0e 94 27 07 	call	0xe4e	; 0xe4e <vTaskStartScheduler>
    2696:	ff cf       	rjmp	.-2      	; 0x2696 <main+0x252>

00002698 <vApplicationIdleHook>:

}

// IDLE TASK
void vApplicationIdleHook(void)
{
    2698:	08 95       	ret

0000269a <__subsf3>:
    269a:	50 58       	subi	r21, 0x80	; 128

0000269c <__addsf3>:
    269c:	bb 27       	eor	r27, r27
    269e:	aa 27       	eor	r26, r26
    26a0:	0e 94 65 13 	call	0x26ca	; 0x26ca <__addsf3x>
    26a4:	0c 94 af 14 	jmp	0x295e	; 0x295e <__fp_round>
    26a8:	0e 94 a1 14 	call	0x2942	; 0x2942 <__fp_pscA>
    26ac:	38 f0       	brcs	.+14     	; 0x26bc <__addsf3+0x20>
    26ae:	0e 94 a8 14 	call	0x2950	; 0x2950 <__fp_pscB>
    26b2:	20 f0       	brcs	.+8      	; 0x26bc <__addsf3+0x20>
    26b4:	39 f4       	brne	.+14     	; 0x26c4 <__addsf3+0x28>
    26b6:	9f 3f       	cpi	r25, 0xFF	; 255
    26b8:	19 f4       	brne	.+6      	; 0x26c0 <__addsf3+0x24>
    26ba:	26 f4       	brtc	.+8      	; 0x26c4 <__addsf3+0x28>
    26bc:	0c 94 9e 14 	jmp	0x293c	; 0x293c <__fp_nan>
    26c0:	0e f4       	brtc	.+2      	; 0x26c4 <__addsf3+0x28>
    26c2:	e0 95       	com	r30
    26c4:	e7 fb       	bst	r30, 7
    26c6:	0c 94 98 14 	jmp	0x2930	; 0x2930 <__fp_inf>

000026ca <__addsf3x>:
    26ca:	e9 2f       	mov	r30, r25
    26cc:	0e 94 c0 14 	call	0x2980	; 0x2980 <__fp_split3>
    26d0:	58 f3       	brcs	.-42     	; 0x26a8 <__addsf3+0xc>
    26d2:	ba 17       	cp	r27, r26
    26d4:	62 07       	cpc	r22, r18
    26d6:	73 07       	cpc	r23, r19
    26d8:	84 07       	cpc	r24, r20
    26da:	95 07       	cpc	r25, r21
    26dc:	20 f0       	brcs	.+8      	; 0x26e6 <__addsf3x+0x1c>
    26de:	79 f4       	brne	.+30     	; 0x26fe <__addsf3x+0x34>
    26e0:	a6 f5       	brtc	.+104    	; 0x274a <__addsf3x+0x80>
    26e2:	0c 94 e2 14 	jmp	0x29c4	; 0x29c4 <__fp_zero>
    26e6:	0e f4       	brtc	.+2      	; 0x26ea <__addsf3x+0x20>
    26e8:	e0 95       	com	r30
    26ea:	0b 2e       	mov	r0, r27
    26ec:	ba 2f       	mov	r27, r26
    26ee:	a0 2d       	mov	r26, r0
    26f0:	0b 01       	movw	r0, r22
    26f2:	b9 01       	movw	r22, r18
    26f4:	90 01       	movw	r18, r0
    26f6:	0c 01       	movw	r0, r24
    26f8:	ca 01       	movw	r24, r20
    26fa:	a0 01       	movw	r20, r0
    26fc:	11 24       	eor	r1, r1
    26fe:	ff 27       	eor	r31, r31
    2700:	59 1b       	sub	r21, r25
    2702:	99 f0       	breq	.+38     	; 0x272a <__addsf3x+0x60>
    2704:	59 3f       	cpi	r21, 0xF9	; 249
    2706:	50 f4       	brcc	.+20     	; 0x271c <__addsf3x+0x52>
    2708:	50 3e       	cpi	r21, 0xE0	; 224
    270a:	68 f1       	brcs	.+90     	; 0x2766 <__addsf3x+0x9c>
    270c:	1a 16       	cp	r1, r26
    270e:	f0 40       	sbci	r31, 0x00	; 0
    2710:	a2 2f       	mov	r26, r18
    2712:	23 2f       	mov	r18, r19
    2714:	34 2f       	mov	r19, r20
    2716:	44 27       	eor	r20, r20
    2718:	58 5f       	subi	r21, 0xF8	; 248
    271a:	f3 cf       	rjmp	.-26     	; 0x2702 <__addsf3x+0x38>
    271c:	46 95       	lsr	r20
    271e:	37 95       	ror	r19
    2720:	27 95       	ror	r18
    2722:	a7 95       	ror	r26
    2724:	f0 40       	sbci	r31, 0x00	; 0
    2726:	53 95       	inc	r21
    2728:	c9 f7       	brne	.-14     	; 0x271c <__addsf3x+0x52>
    272a:	7e f4       	brtc	.+30     	; 0x274a <__addsf3x+0x80>
    272c:	1f 16       	cp	r1, r31
    272e:	ba 0b       	sbc	r27, r26
    2730:	62 0b       	sbc	r22, r18
    2732:	73 0b       	sbc	r23, r19
    2734:	84 0b       	sbc	r24, r20
    2736:	ba f0       	brmi	.+46     	; 0x2766 <__addsf3x+0x9c>
    2738:	91 50       	subi	r25, 0x01	; 1
    273a:	a1 f0       	breq	.+40     	; 0x2764 <__addsf3x+0x9a>
    273c:	ff 0f       	add	r31, r31
    273e:	bb 1f       	adc	r27, r27
    2740:	66 1f       	adc	r22, r22
    2742:	77 1f       	adc	r23, r23
    2744:	88 1f       	adc	r24, r24
    2746:	c2 f7       	brpl	.-16     	; 0x2738 <__addsf3x+0x6e>
    2748:	0e c0       	rjmp	.+28     	; 0x2766 <__addsf3x+0x9c>
    274a:	ba 0f       	add	r27, r26
    274c:	62 1f       	adc	r22, r18
    274e:	73 1f       	adc	r23, r19
    2750:	84 1f       	adc	r24, r20
    2752:	48 f4       	brcc	.+18     	; 0x2766 <__addsf3x+0x9c>
    2754:	87 95       	ror	r24
    2756:	77 95       	ror	r23
    2758:	67 95       	ror	r22
    275a:	b7 95       	ror	r27
    275c:	f7 95       	ror	r31
    275e:	9e 3f       	cpi	r25, 0xFE	; 254
    2760:	08 f0       	brcs	.+2      	; 0x2764 <__addsf3x+0x9a>
    2762:	b0 cf       	rjmp	.-160    	; 0x26c4 <__addsf3+0x28>
    2764:	93 95       	inc	r25
    2766:	88 0f       	add	r24, r24
    2768:	08 f0       	brcs	.+2      	; 0x276c <__addsf3x+0xa2>
    276a:	99 27       	eor	r25, r25
    276c:	ee 0f       	add	r30, r30
    276e:	97 95       	ror	r25
    2770:	87 95       	ror	r24
    2772:	08 95       	ret

00002774 <__divsf3>:
    2774:	0e 94 ce 13 	call	0x279c	; 0x279c <__divsf3x>
    2778:	0c 94 af 14 	jmp	0x295e	; 0x295e <__fp_round>
    277c:	0e 94 a8 14 	call	0x2950	; 0x2950 <__fp_pscB>
    2780:	58 f0       	brcs	.+22     	; 0x2798 <__divsf3+0x24>
    2782:	0e 94 a1 14 	call	0x2942	; 0x2942 <__fp_pscA>
    2786:	40 f0       	brcs	.+16     	; 0x2798 <__divsf3+0x24>
    2788:	29 f4       	brne	.+10     	; 0x2794 <__divsf3+0x20>
    278a:	5f 3f       	cpi	r21, 0xFF	; 255
    278c:	29 f0       	breq	.+10     	; 0x2798 <__divsf3+0x24>
    278e:	0c 94 98 14 	jmp	0x2930	; 0x2930 <__fp_inf>
    2792:	51 11       	cpse	r21, r1
    2794:	0c 94 e3 14 	jmp	0x29c6	; 0x29c6 <__fp_szero>
    2798:	0c 94 9e 14 	jmp	0x293c	; 0x293c <__fp_nan>

0000279c <__divsf3x>:
    279c:	0e 94 c0 14 	call	0x2980	; 0x2980 <__fp_split3>
    27a0:	68 f3       	brcs	.-38     	; 0x277c <__divsf3+0x8>

000027a2 <__divsf3_pse>:
    27a2:	99 23       	and	r25, r25
    27a4:	b1 f3       	breq	.-20     	; 0x2792 <__divsf3+0x1e>
    27a6:	55 23       	and	r21, r21
    27a8:	91 f3       	breq	.-28     	; 0x278e <__divsf3+0x1a>
    27aa:	95 1b       	sub	r25, r21
    27ac:	55 0b       	sbc	r21, r21
    27ae:	bb 27       	eor	r27, r27
    27b0:	aa 27       	eor	r26, r26
    27b2:	62 17       	cp	r22, r18
    27b4:	73 07       	cpc	r23, r19
    27b6:	84 07       	cpc	r24, r20
    27b8:	38 f0       	brcs	.+14     	; 0x27c8 <__divsf3_pse+0x26>
    27ba:	9f 5f       	subi	r25, 0xFF	; 255
    27bc:	5f 4f       	sbci	r21, 0xFF	; 255
    27be:	22 0f       	add	r18, r18
    27c0:	33 1f       	adc	r19, r19
    27c2:	44 1f       	adc	r20, r20
    27c4:	aa 1f       	adc	r26, r26
    27c6:	a9 f3       	breq	.-22     	; 0x27b2 <__divsf3_pse+0x10>
    27c8:	35 d0       	rcall	.+106    	; 0x2834 <__divsf3_pse+0x92>
    27ca:	0e 2e       	mov	r0, r30
    27cc:	3a f0       	brmi	.+14     	; 0x27dc <__divsf3_pse+0x3a>
    27ce:	e0 e8       	ldi	r30, 0x80	; 128
    27d0:	32 d0       	rcall	.+100    	; 0x2836 <__divsf3_pse+0x94>
    27d2:	91 50       	subi	r25, 0x01	; 1
    27d4:	50 40       	sbci	r21, 0x00	; 0
    27d6:	e6 95       	lsr	r30
    27d8:	00 1c       	adc	r0, r0
    27da:	ca f7       	brpl	.-14     	; 0x27ce <__divsf3_pse+0x2c>
    27dc:	2b d0       	rcall	.+86     	; 0x2834 <__divsf3_pse+0x92>
    27de:	fe 2f       	mov	r31, r30
    27e0:	29 d0       	rcall	.+82     	; 0x2834 <__divsf3_pse+0x92>
    27e2:	66 0f       	add	r22, r22
    27e4:	77 1f       	adc	r23, r23
    27e6:	88 1f       	adc	r24, r24
    27e8:	bb 1f       	adc	r27, r27
    27ea:	26 17       	cp	r18, r22
    27ec:	37 07       	cpc	r19, r23
    27ee:	48 07       	cpc	r20, r24
    27f0:	ab 07       	cpc	r26, r27
    27f2:	b0 e8       	ldi	r27, 0x80	; 128
    27f4:	09 f0       	breq	.+2      	; 0x27f8 <__divsf3_pse+0x56>
    27f6:	bb 0b       	sbc	r27, r27
    27f8:	80 2d       	mov	r24, r0
    27fa:	bf 01       	movw	r22, r30
    27fc:	ff 27       	eor	r31, r31
    27fe:	93 58       	subi	r25, 0x83	; 131
    2800:	5f 4f       	sbci	r21, 0xFF	; 255
    2802:	3a f0       	brmi	.+14     	; 0x2812 <__divsf3_pse+0x70>
    2804:	9e 3f       	cpi	r25, 0xFE	; 254
    2806:	51 05       	cpc	r21, r1
    2808:	78 f0       	brcs	.+30     	; 0x2828 <__divsf3_pse+0x86>
    280a:	0c 94 98 14 	jmp	0x2930	; 0x2930 <__fp_inf>
    280e:	0c 94 e3 14 	jmp	0x29c6	; 0x29c6 <__fp_szero>
    2812:	5f 3f       	cpi	r21, 0xFF	; 255
    2814:	e4 f3       	brlt	.-8      	; 0x280e <__divsf3_pse+0x6c>
    2816:	98 3e       	cpi	r25, 0xE8	; 232
    2818:	d4 f3       	brlt	.-12     	; 0x280e <__divsf3_pse+0x6c>
    281a:	86 95       	lsr	r24
    281c:	77 95       	ror	r23
    281e:	67 95       	ror	r22
    2820:	b7 95       	ror	r27
    2822:	f7 95       	ror	r31
    2824:	9f 5f       	subi	r25, 0xFF	; 255
    2826:	c9 f7       	brne	.-14     	; 0x281a <__divsf3_pse+0x78>
    2828:	88 0f       	add	r24, r24
    282a:	91 1d       	adc	r25, r1
    282c:	96 95       	lsr	r25
    282e:	87 95       	ror	r24
    2830:	97 f9       	bld	r25, 7
    2832:	08 95       	ret
    2834:	e1 e0       	ldi	r30, 0x01	; 1
    2836:	66 0f       	add	r22, r22
    2838:	77 1f       	adc	r23, r23
    283a:	88 1f       	adc	r24, r24
    283c:	bb 1f       	adc	r27, r27
    283e:	62 17       	cp	r22, r18
    2840:	73 07       	cpc	r23, r19
    2842:	84 07       	cpc	r24, r20
    2844:	ba 07       	cpc	r27, r26
    2846:	20 f0       	brcs	.+8      	; 0x2850 <__divsf3_pse+0xae>
    2848:	62 1b       	sub	r22, r18
    284a:	73 0b       	sbc	r23, r19
    284c:	84 0b       	sbc	r24, r20
    284e:	ba 0b       	sbc	r27, r26
    2850:	ee 1f       	adc	r30, r30
    2852:	88 f7       	brcc	.-30     	; 0x2836 <__divsf3_pse+0x94>
    2854:	e0 95       	com	r30
    2856:	08 95       	ret

00002858 <__fixunssfsi>:
    2858:	0e 94 c8 14 	call	0x2990	; 0x2990 <__fp_splitA>
    285c:	88 f0       	brcs	.+34     	; 0x2880 <__fixunssfsi+0x28>
    285e:	9f 57       	subi	r25, 0x7F	; 127
    2860:	98 f0       	brcs	.+38     	; 0x2888 <__fixunssfsi+0x30>
    2862:	b9 2f       	mov	r27, r25
    2864:	99 27       	eor	r25, r25
    2866:	b7 51       	subi	r27, 0x17	; 23
    2868:	b0 f0       	brcs	.+44     	; 0x2896 <__fixunssfsi+0x3e>
    286a:	e1 f0       	breq	.+56     	; 0x28a4 <__fixunssfsi+0x4c>
    286c:	66 0f       	add	r22, r22
    286e:	77 1f       	adc	r23, r23
    2870:	88 1f       	adc	r24, r24
    2872:	99 1f       	adc	r25, r25
    2874:	1a f0       	brmi	.+6      	; 0x287c <__fixunssfsi+0x24>
    2876:	ba 95       	dec	r27
    2878:	c9 f7       	brne	.-14     	; 0x286c <__fixunssfsi+0x14>
    287a:	14 c0       	rjmp	.+40     	; 0x28a4 <__fixunssfsi+0x4c>
    287c:	b1 30       	cpi	r27, 0x01	; 1
    287e:	91 f0       	breq	.+36     	; 0x28a4 <__fixunssfsi+0x4c>
    2880:	0e 94 e2 14 	call	0x29c4	; 0x29c4 <__fp_zero>
    2884:	b1 e0       	ldi	r27, 0x01	; 1
    2886:	08 95       	ret
    2888:	0c 94 e2 14 	jmp	0x29c4	; 0x29c4 <__fp_zero>
    288c:	67 2f       	mov	r22, r23
    288e:	78 2f       	mov	r23, r24
    2890:	88 27       	eor	r24, r24
    2892:	b8 5f       	subi	r27, 0xF8	; 248
    2894:	39 f0       	breq	.+14     	; 0x28a4 <__fixunssfsi+0x4c>
    2896:	b9 3f       	cpi	r27, 0xF9	; 249
    2898:	cc f3       	brlt	.-14     	; 0x288c <__fixunssfsi+0x34>
    289a:	86 95       	lsr	r24
    289c:	77 95       	ror	r23
    289e:	67 95       	ror	r22
    28a0:	b3 95       	inc	r27
    28a2:	d9 f7       	brne	.-10     	; 0x289a <__fixunssfsi+0x42>
    28a4:	3e f4       	brtc	.+14     	; 0x28b4 <__fixunssfsi+0x5c>
    28a6:	90 95       	com	r25
    28a8:	80 95       	com	r24
    28aa:	70 95       	com	r23
    28ac:	61 95       	neg	r22
    28ae:	7f 4f       	sbci	r23, 0xFF	; 255
    28b0:	8f 4f       	sbci	r24, 0xFF	; 255
    28b2:	9f 4f       	sbci	r25, 0xFF	; 255
    28b4:	08 95       	ret

000028b6 <__floatunsisf>:
    28b6:	e8 94       	clt
    28b8:	09 c0       	rjmp	.+18     	; 0x28cc <__floatsisf+0x12>

000028ba <__floatsisf>:
    28ba:	97 fb       	bst	r25, 7
    28bc:	3e f4       	brtc	.+14     	; 0x28cc <__floatsisf+0x12>
    28be:	90 95       	com	r25
    28c0:	80 95       	com	r24
    28c2:	70 95       	com	r23
    28c4:	61 95       	neg	r22
    28c6:	7f 4f       	sbci	r23, 0xFF	; 255
    28c8:	8f 4f       	sbci	r24, 0xFF	; 255
    28ca:	9f 4f       	sbci	r25, 0xFF	; 255
    28cc:	99 23       	and	r25, r25
    28ce:	a9 f0       	breq	.+42     	; 0x28fa <__floatsisf+0x40>
    28d0:	f9 2f       	mov	r31, r25
    28d2:	96 e9       	ldi	r25, 0x96	; 150
    28d4:	bb 27       	eor	r27, r27
    28d6:	93 95       	inc	r25
    28d8:	f6 95       	lsr	r31
    28da:	87 95       	ror	r24
    28dc:	77 95       	ror	r23
    28de:	67 95       	ror	r22
    28e0:	b7 95       	ror	r27
    28e2:	f1 11       	cpse	r31, r1
    28e4:	f8 cf       	rjmp	.-16     	; 0x28d6 <__floatsisf+0x1c>
    28e6:	fa f4       	brpl	.+62     	; 0x2926 <__floatsisf+0x6c>
    28e8:	bb 0f       	add	r27, r27
    28ea:	11 f4       	brne	.+4      	; 0x28f0 <__floatsisf+0x36>
    28ec:	60 ff       	sbrs	r22, 0
    28ee:	1b c0       	rjmp	.+54     	; 0x2926 <__floatsisf+0x6c>
    28f0:	6f 5f       	subi	r22, 0xFF	; 255
    28f2:	7f 4f       	sbci	r23, 0xFF	; 255
    28f4:	8f 4f       	sbci	r24, 0xFF	; 255
    28f6:	9f 4f       	sbci	r25, 0xFF	; 255
    28f8:	16 c0       	rjmp	.+44     	; 0x2926 <__floatsisf+0x6c>
    28fa:	88 23       	and	r24, r24
    28fc:	11 f0       	breq	.+4      	; 0x2902 <__floatsisf+0x48>
    28fe:	96 e9       	ldi	r25, 0x96	; 150
    2900:	11 c0       	rjmp	.+34     	; 0x2924 <__floatsisf+0x6a>
    2902:	77 23       	and	r23, r23
    2904:	21 f0       	breq	.+8      	; 0x290e <__floatsisf+0x54>
    2906:	9e e8       	ldi	r25, 0x8E	; 142
    2908:	87 2f       	mov	r24, r23
    290a:	76 2f       	mov	r23, r22
    290c:	05 c0       	rjmp	.+10     	; 0x2918 <__floatsisf+0x5e>
    290e:	66 23       	and	r22, r22
    2910:	71 f0       	breq	.+28     	; 0x292e <__floatsisf+0x74>
    2912:	96 e8       	ldi	r25, 0x86	; 134
    2914:	86 2f       	mov	r24, r22
    2916:	70 e0       	ldi	r23, 0x00	; 0
    2918:	60 e0       	ldi	r22, 0x00	; 0
    291a:	2a f0       	brmi	.+10     	; 0x2926 <__floatsisf+0x6c>
    291c:	9a 95       	dec	r25
    291e:	66 0f       	add	r22, r22
    2920:	77 1f       	adc	r23, r23
    2922:	88 1f       	adc	r24, r24
    2924:	da f7       	brpl	.-10     	; 0x291c <__floatsisf+0x62>
    2926:	88 0f       	add	r24, r24
    2928:	96 95       	lsr	r25
    292a:	87 95       	ror	r24
    292c:	97 f9       	bld	r25, 7
    292e:	08 95       	ret

00002930 <__fp_inf>:
    2930:	97 f9       	bld	r25, 7
    2932:	9f 67       	ori	r25, 0x7F	; 127
    2934:	80 e8       	ldi	r24, 0x80	; 128
    2936:	70 e0       	ldi	r23, 0x00	; 0
    2938:	60 e0       	ldi	r22, 0x00	; 0
    293a:	08 95       	ret

0000293c <__fp_nan>:
    293c:	9f ef       	ldi	r25, 0xFF	; 255
    293e:	80 ec       	ldi	r24, 0xC0	; 192
    2940:	08 95       	ret

00002942 <__fp_pscA>:
    2942:	00 24       	eor	r0, r0
    2944:	0a 94       	dec	r0
    2946:	16 16       	cp	r1, r22
    2948:	17 06       	cpc	r1, r23
    294a:	18 06       	cpc	r1, r24
    294c:	09 06       	cpc	r0, r25
    294e:	08 95       	ret

00002950 <__fp_pscB>:
    2950:	00 24       	eor	r0, r0
    2952:	0a 94       	dec	r0
    2954:	12 16       	cp	r1, r18
    2956:	13 06       	cpc	r1, r19
    2958:	14 06       	cpc	r1, r20
    295a:	05 06       	cpc	r0, r21
    295c:	08 95       	ret

0000295e <__fp_round>:
    295e:	09 2e       	mov	r0, r25
    2960:	03 94       	inc	r0
    2962:	00 0c       	add	r0, r0
    2964:	11 f4       	brne	.+4      	; 0x296a <__fp_round+0xc>
    2966:	88 23       	and	r24, r24
    2968:	52 f0       	brmi	.+20     	; 0x297e <__fp_round+0x20>
    296a:	bb 0f       	add	r27, r27
    296c:	40 f4       	brcc	.+16     	; 0x297e <__fp_round+0x20>
    296e:	bf 2b       	or	r27, r31
    2970:	11 f4       	brne	.+4      	; 0x2976 <__fp_round+0x18>
    2972:	60 ff       	sbrs	r22, 0
    2974:	04 c0       	rjmp	.+8      	; 0x297e <__fp_round+0x20>
    2976:	6f 5f       	subi	r22, 0xFF	; 255
    2978:	7f 4f       	sbci	r23, 0xFF	; 255
    297a:	8f 4f       	sbci	r24, 0xFF	; 255
    297c:	9f 4f       	sbci	r25, 0xFF	; 255
    297e:	08 95       	ret

00002980 <__fp_split3>:
    2980:	57 fd       	sbrc	r21, 7
    2982:	90 58       	subi	r25, 0x80	; 128
    2984:	44 0f       	add	r20, r20
    2986:	55 1f       	adc	r21, r21
    2988:	59 f0       	breq	.+22     	; 0x29a0 <__fp_splitA+0x10>
    298a:	5f 3f       	cpi	r21, 0xFF	; 255
    298c:	71 f0       	breq	.+28     	; 0x29aa <__fp_splitA+0x1a>
    298e:	47 95       	ror	r20

00002990 <__fp_splitA>:
    2990:	88 0f       	add	r24, r24
    2992:	97 fb       	bst	r25, 7
    2994:	99 1f       	adc	r25, r25
    2996:	61 f0       	breq	.+24     	; 0x29b0 <__fp_splitA+0x20>
    2998:	9f 3f       	cpi	r25, 0xFF	; 255
    299a:	79 f0       	breq	.+30     	; 0x29ba <__fp_splitA+0x2a>
    299c:	87 95       	ror	r24
    299e:	08 95       	ret
    29a0:	12 16       	cp	r1, r18
    29a2:	13 06       	cpc	r1, r19
    29a4:	14 06       	cpc	r1, r20
    29a6:	55 1f       	adc	r21, r21
    29a8:	f2 cf       	rjmp	.-28     	; 0x298e <__fp_split3+0xe>
    29aa:	46 95       	lsr	r20
    29ac:	f1 df       	rcall	.-30     	; 0x2990 <__fp_splitA>
    29ae:	08 c0       	rjmp	.+16     	; 0x29c0 <__fp_splitA+0x30>
    29b0:	16 16       	cp	r1, r22
    29b2:	17 06       	cpc	r1, r23
    29b4:	18 06       	cpc	r1, r24
    29b6:	99 1f       	adc	r25, r25
    29b8:	f1 cf       	rjmp	.-30     	; 0x299c <__fp_splitA+0xc>
    29ba:	86 95       	lsr	r24
    29bc:	71 05       	cpc	r23, r1
    29be:	61 05       	cpc	r22, r1
    29c0:	08 94       	sec
    29c2:	08 95       	ret

000029c4 <__fp_zero>:
    29c4:	e8 94       	clt

000029c6 <__fp_szero>:
    29c6:	bb 27       	eor	r27, r27
    29c8:	66 27       	eor	r22, r22
    29ca:	77 27       	eor	r23, r23
    29cc:	cb 01       	movw	r24, r22
    29ce:	97 f9       	bld	r25, 7
    29d0:	08 95       	ret

000029d2 <__gesf2>:
    29d2:	0e 94 5b 15 	call	0x2ab6	; 0x2ab6 <__fp_cmp>
    29d6:	08 f4       	brcc	.+2      	; 0x29da <__gesf2+0x8>
    29d8:	8f ef       	ldi	r24, 0xFF	; 255
    29da:	08 95       	ret

000029dc <__mulsf3>:
    29dc:	0e 94 01 15 	call	0x2a02	; 0x2a02 <__mulsf3x>
    29e0:	0c 94 af 14 	jmp	0x295e	; 0x295e <__fp_round>
    29e4:	0e 94 a1 14 	call	0x2942	; 0x2942 <__fp_pscA>
    29e8:	38 f0       	brcs	.+14     	; 0x29f8 <__mulsf3+0x1c>
    29ea:	0e 94 a8 14 	call	0x2950	; 0x2950 <__fp_pscB>
    29ee:	20 f0       	brcs	.+8      	; 0x29f8 <__mulsf3+0x1c>
    29f0:	95 23       	and	r25, r21
    29f2:	11 f0       	breq	.+4      	; 0x29f8 <__mulsf3+0x1c>
    29f4:	0c 94 98 14 	jmp	0x2930	; 0x2930 <__fp_inf>
    29f8:	0c 94 9e 14 	jmp	0x293c	; 0x293c <__fp_nan>
    29fc:	11 24       	eor	r1, r1
    29fe:	0c 94 e3 14 	jmp	0x29c6	; 0x29c6 <__fp_szero>

00002a02 <__mulsf3x>:
    2a02:	0e 94 c0 14 	call	0x2980	; 0x2980 <__fp_split3>
    2a06:	70 f3       	brcs	.-36     	; 0x29e4 <__mulsf3+0x8>

00002a08 <__mulsf3_pse>:
    2a08:	95 9f       	mul	r25, r21
    2a0a:	c1 f3       	breq	.-16     	; 0x29fc <__mulsf3+0x20>
    2a0c:	95 0f       	add	r25, r21
    2a0e:	50 e0       	ldi	r21, 0x00	; 0
    2a10:	55 1f       	adc	r21, r21
    2a12:	62 9f       	mul	r22, r18
    2a14:	f0 01       	movw	r30, r0
    2a16:	72 9f       	mul	r23, r18
    2a18:	bb 27       	eor	r27, r27
    2a1a:	f0 0d       	add	r31, r0
    2a1c:	b1 1d       	adc	r27, r1
    2a1e:	63 9f       	mul	r22, r19
    2a20:	aa 27       	eor	r26, r26
    2a22:	f0 0d       	add	r31, r0
    2a24:	b1 1d       	adc	r27, r1
    2a26:	aa 1f       	adc	r26, r26
    2a28:	64 9f       	mul	r22, r20
    2a2a:	66 27       	eor	r22, r22
    2a2c:	b0 0d       	add	r27, r0
    2a2e:	a1 1d       	adc	r26, r1
    2a30:	66 1f       	adc	r22, r22
    2a32:	82 9f       	mul	r24, r18
    2a34:	22 27       	eor	r18, r18
    2a36:	b0 0d       	add	r27, r0
    2a38:	a1 1d       	adc	r26, r1
    2a3a:	62 1f       	adc	r22, r18
    2a3c:	73 9f       	mul	r23, r19
    2a3e:	b0 0d       	add	r27, r0
    2a40:	a1 1d       	adc	r26, r1
    2a42:	62 1f       	adc	r22, r18
    2a44:	83 9f       	mul	r24, r19
    2a46:	a0 0d       	add	r26, r0
    2a48:	61 1d       	adc	r22, r1
    2a4a:	22 1f       	adc	r18, r18
    2a4c:	74 9f       	mul	r23, r20
    2a4e:	33 27       	eor	r19, r19
    2a50:	a0 0d       	add	r26, r0
    2a52:	61 1d       	adc	r22, r1
    2a54:	23 1f       	adc	r18, r19
    2a56:	84 9f       	mul	r24, r20
    2a58:	60 0d       	add	r22, r0
    2a5a:	21 1d       	adc	r18, r1
    2a5c:	82 2f       	mov	r24, r18
    2a5e:	76 2f       	mov	r23, r22
    2a60:	6a 2f       	mov	r22, r26
    2a62:	11 24       	eor	r1, r1
    2a64:	9f 57       	subi	r25, 0x7F	; 127
    2a66:	50 40       	sbci	r21, 0x00	; 0
    2a68:	9a f0       	brmi	.+38     	; 0x2a90 <__mulsf3_pse+0x88>
    2a6a:	f1 f0       	breq	.+60     	; 0x2aa8 <__mulsf3_pse+0xa0>
    2a6c:	88 23       	and	r24, r24
    2a6e:	4a f0       	brmi	.+18     	; 0x2a82 <__mulsf3_pse+0x7a>
    2a70:	ee 0f       	add	r30, r30
    2a72:	ff 1f       	adc	r31, r31
    2a74:	bb 1f       	adc	r27, r27
    2a76:	66 1f       	adc	r22, r22
    2a78:	77 1f       	adc	r23, r23
    2a7a:	88 1f       	adc	r24, r24
    2a7c:	91 50       	subi	r25, 0x01	; 1
    2a7e:	50 40       	sbci	r21, 0x00	; 0
    2a80:	a9 f7       	brne	.-22     	; 0x2a6c <__mulsf3_pse+0x64>
    2a82:	9e 3f       	cpi	r25, 0xFE	; 254
    2a84:	51 05       	cpc	r21, r1
    2a86:	80 f0       	brcs	.+32     	; 0x2aa8 <__mulsf3_pse+0xa0>
    2a88:	0c 94 98 14 	jmp	0x2930	; 0x2930 <__fp_inf>
    2a8c:	0c 94 e3 14 	jmp	0x29c6	; 0x29c6 <__fp_szero>
    2a90:	5f 3f       	cpi	r21, 0xFF	; 255
    2a92:	e4 f3       	brlt	.-8      	; 0x2a8c <__mulsf3_pse+0x84>
    2a94:	98 3e       	cpi	r25, 0xE8	; 232
    2a96:	d4 f3       	brlt	.-12     	; 0x2a8c <__mulsf3_pse+0x84>
    2a98:	86 95       	lsr	r24
    2a9a:	77 95       	ror	r23
    2a9c:	67 95       	ror	r22
    2a9e:	b7 95       	ror	r27
    2aa0:	f7 95       	ror	r31
    2aa2:	e7 95       	ror	r30
    2aa4:	9f 5f       	subi	r25, 0xFF	; 255
    2aa6:	c1 f7       	brne	.-16     	; 0x2a98 <__mulsf3_pse+0x90>
    2aa8:	fe 2b       	or	r31, r30
    2aaa:	88 0f       	add	r24, r24
    2aac:	91 1d       	adc	r25, r1
    2aae:	96 95       	lsr	r25
    2ab0:	87 95       	ror	r24
    2ab2:	97 f9       	bld	r25, 7
    2ab4:	08 95       	ret

00002ab6 <__fp_cmp>:
    2ab6:	99 0f       	add	r25, r25
    2ab8:	00 08       	sbc	r0, r0
    2aba:	55 0f       	add	r21, r21
    2abc:	aa 0b       	sbc	r26, r26
    2abe:	e0 e8       	ldi	r30, 0x80	; 128
    2ac0:	fe ef       	ldi	r31, 0xFE	; 254
    2ac2:	16 16       	cp	r1, r22
    2ac4:	17 06       	cpc	r1, r23
    2ac6:	e8 07       	cpc	r30, r24
    2ac8:	f9 07       	cpc	r31, r25
    2aca:	c0 f0       	brcs	.+48     	; 0x2afc <__fp_cmp+0x46>
    2acc:	12 16       	cp	r1, r18
    2ace:	13 06       	cpc	r1, r19
    2ad0:	e4 07       	cpc	r30, r20
    2ad2:	f5 07       	cpc	r31, r21
    2ad4:	98 f0       	brcs	.+38     	; 0x2afc <__fp_cmp+0x46>
    2ad6:	62 1b       	sub	r22, r18
    2ad8:	73 0b       	sbc	r23, r19
    2ada:	84 0b       	sbc	r24, r20
    2adc:	95 0b       	sbc	r25, r21
    2ade:	39 f4       	brne	.+14     	; 0x2aee <__fp_cmp+0x38>
    2ae0:	0a 26       	eor	r0, r26
    2ae2:	61 f0       	breq	.+24     	; 0x2afc <__fp_cmp+0x46>
    2ae4:	23 2b       	or	r18, r19
    2ae6:	24 2b       	or	r18, r20
    2ae8:	25 2b       	or	r18, r21
    2aea:	21 f4       	brne	.+8      	; 0x2af4 <__fp_cmp+0x3e>
    2aec:	08 95       	ret
    2aee:	0a 26       	eor	r0, r26
    2af0:	09 f4       	brne	.+2      	; 0x2af4 <__fp_cmp+0x3e>
    2af2:	a1 40       	sbci	r26, 0x01	; 1
    2af4:	a6 95       	lsr	r26
    2af6:	8f ef       	ldi	r24, 0xFF	; 255
    2af8:	81 1d       	adc	r24, r1
    2afa:	81 1d       	adc	r24, r1
    2afc:	08 95       	ret

00002afe <__tablejump2__>:
    2afe:	ee 0f       	add	r30, r30
    2b00:	ff 1f       	adc	r31, r31
    2b02:	05 90       	lpm	r0, Z+
    2b04:	f4 91       	lpm	r31, Z
    2b06:	e0 2d       	mov	r30, r0
    2b08:	09 94       	ijmp

00002b0a <__umulhisi3>:
    2b0a:	a2 9f       	mul	r26, r18
    2b0c:	b0 01       	movw	r22, r0
    2b0e:	b3 9f       	mul	r27, r19
    2b10:	c0 01       	movw	r24, r0
    2b12:	a3 9f       	mul	r26, r19
    2b14:	70 0d       	add	r23, r0
    2b16:	81 1d       	adc	r24, r1
    2b18:	11 24       	eor	r1, r1
    2b1a:	91 1d       	adc	r25, r1
    2b1c:	b2 9f       	mul	r27, r18
    2b1e:	70 0d       	add	r23, r0
    2b20:	81 1d       	adc	r24, r1
    2b22:	11 24       	eor	r1, r1
    2b24:	91 1d       	adc	r25, r1
    2b26:	08 95       	ret

00002b28 <memcpy>:
    2b28:	fb 01       	movw	r30, r22
    2b2a:	dc 01       	movw	r26, r24
    2b2c:	02 c0       	rjmp	.+4      	; 0x2b32 <memcpy+0xa>
    2b2e:	01 90       	ld	r0, Z+
    2b30:	0d 92       	st	X+, r0
    2b32:	41 50       	subi	r20, 0x01	; 1
    2b34:	50 40       	sbci	r21, 0x00	; 0
    2b36:	d8 f7       	brcc	.-10     	; 0x2b2e <memcpy+0x6>
    2b38:	08 95       	ret

00002b3a <_exit>:
    2b3a:	f8 94       	cli

00002b3c <__stop_program>:
    2b3c:	ff cf       	rjmp	.-2      	; 0x2b3c <__stop_program>
