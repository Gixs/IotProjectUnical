
ArduinoFreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000ae  00800100  00002be8  00002c7c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002be8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006f4  008001ae  008001ae  00002d2a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002d2a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002d5c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000458  00000000  00000000  00002d9c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006349  00000000  00000000  000031f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001037  00000000  00000000  0000953d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003093  00000000  00000000  0000a574  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000db8  00000000  00000000  0000d608  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001b47  00000000  00000000  0000e3c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005aff  00000000  00000000  0000ff07  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000598  00000000  00000000  00015a06  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
       4:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       8:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      2c:	0c 94 7d 02 	jmp	0x4fa	; 0x4fa <__vector_11>
      30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      34:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      40:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      48:	0c 94 77 0f 	jmp	0x1eee	; 0x1eee <__vector_18>
      4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      50:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      68:	6c 0c       	add	r6, r12
      6a:	6c 0c       	add	r6, r12
      6c:	6c 0c       	add	r6, r12
      6e:	a7 0c       	add	r10, r7
      70:	95 0c       	add	r9, r5
      72:	a4 0c       	add	r10, r4
      74:	6c 0c       	add	r6, r12
      76:	6c 0c       	add	r6, r12
      78:	a7 0c       	add	r10, r7
      7a:	95 0c       	add	r9, r5

0000007c <__ctors_end>:
      7c:	11 24       	eor	r1, r1
      7e:	1f be       	out	0x3f, r1	; 63
      80:	cf ef       	ldi	r28, 0xFF	; 255
      82:	d8 e0       	ldi	r29, 0x08	; 8
      84:	de bf       	out	0x3e, r29	; 62
      86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
      88:	11 e0       	ldi	r17, 0x01	; 1
      8a:	a0 e0       	ldi	r26, 0x00	; 0
      8c:	b1 e0       	ldi	r27, 0x01	; 1
      8e:	e8 ee       	ldi	r30, 0xE8	; 232
      90:	fb e2       	ldi	r31, 0x2B	; 43
      92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
      94:	05 90       	lpm	r0, Z+
      96:	0d 92       	st	X+, r0
      98:	ae 3a       	cpi	r26, 0xAE	; 174
      9a:	b1 07       	cpc	r27, r17
      9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
      9e:	28 e0       	ldi	r18, 0x08	; 8
      a0:	ae ea       	ldi	r26, 0xAE	; 174
      a2:	b1 e0       	ldi	r27, 0x01	; 1
      a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
      a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
      a8:	a2 3a       	cpi	r26, 0xA2	; 162
      aa:	b2 07       	cpc	r27, r18
      ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
      ae:	0e 94 78 12 	call	0x24f0	; 0x24f0 <main>
      b2:	0c 94 f2 15 	jmp	0x2be4	; 0x2be4 <_exit>

000000b6 <__bad_interrupt>:
      b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
      ba:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      bc:	03 96       	adiw	r24, 0x03	; 3
      be:	92 83       	std	Z+2, r25	; 0x02
      c0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
      c2:	2f ef       	ldi	r18, 0xFF	; 255
      c4:	3f ef       	ldi	r19, 0xFF	; 255
      c6:	34 83       	std	Z+4, r19	; 0x04
      c8:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      ca:	96 83       	std	Z+6, r25	; 0x06
      cc:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      ce:	90 87       	std	Z+8, r25	; 0x08
      d0:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
      d2:	10 82       	st	Z, r1
      d4:	08 95       	ret

000000d6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
      d6:	fc 01       	movw	r30, r24
      d8:	11 86       	std	Z+9, r1	; 0x09
      da:	10 86       	std	Z+8, r1	; 0x08
      dc:	08 95       	ret

000000de <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
      de:	cf 93       	push	r28
      e0:	df 93       	push	r29
      e2:	9c 01       	movw	r18, r24
      e4:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
      e6:	dc 01       	movw	r26, r24
      e8:	11 96       	adiw	r26, 0x01	; 1
      ea:	cd 91       	ld	r28, X+
      ec:	dc 91       	ld	r29, X
      ee:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
      f0:	d3 83       	std	Z+3, r29	; 0x03
      f2:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
      f4:	8c 81       	ldd	r24, Y+4	; 0x04
      f6:	9d 81       	ldd	r25, Y+5	; 0x05
      f8:	95 83       	std	Z+5, r25	; 0x05
      fa:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
      fc:	8c 81       	ldd	r24, Y+4	; 0x04
      fe:	9d 81       	ldd	r25, Y+5	; 0x05
     100:	dc 01       	movw	r26, r24
     102:	13 96       	adiw	r26, 0x03	; 3
     104:	7c 93       	st	X, r23
     106:	6e 93       	st	-X, r22
     108:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     10a:	7d 83       	std	Y+5, r23	; 0x05
     10c:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     10e:	31 87       	std	Z+9, r19	; 0x09
     110:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     112:	f9 01       	movw	r30, r18
     114:	80 81       	ld	r24, Z
     116:	8f 5f       	subi	r24, 0xFF	; 255
     118:	80 83       	st	Z, r24
}
     11a:	df 91       	pop	r29
     11c:	cf 91       	pop	r28
     11e:	08 95       	ret

00000120 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     120:	cf 93       	push	r28
     122:	df 93       	push	r29
     124:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     126:	48 81       	ld	r20, Y
     128:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     12a:	4f 3f       	cpi	r20, 0xFF	; 255
     12c:	2f ef       	ldi	r18, 0xFF	; 255
     12e:	52 07       	cpc	r21, r18
     130:	21 f4       	brne	.+8      	; 0x13a <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     132:	fc 01       	movw	r30, r24
     134:	a7 81       	ldd	r26, Z+7	; 0x07
     136:	b0 85       	ldd	r27, Z+8	; 0x08
     138:	0d c0       	rjmp	.+26     	; 0x154 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     13a:	dc 01       	movw	r26, r24
     13c:	13 96       	adiw	r26, 0x03	; 3
     13e:	01 c0       	rjmp	.+2      	; 0x142 <vListInsert+0x22>
     140:	df 01       	movw	r26, r30
     142:	12 96       	adiw	r26, 0x02	; 2
     144:	ed 91       	ld	r30, X+
     146:	fc 91       	ld	r31, X
     148:	13 97       	sbiw	r26, 0x03	; 3
     14a:	20 81       	ld	r18, Z
     14c:	31 81       	ldd	r19, Z+1	; 0x01
     14e:	42 17       	cp	r20, r18
     150:	53 07       	cpc	r21, r19
     152:	b0 f7       	brcc	.-20     	; 0x140 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     154:	12 96       	adiw	r26, 0x02	; 2
     156:	ed 91       	ld	r30, X+
     158:	fc 91       	ld	r31, X
     15a:	13 97       	sbiw	r26, 0x03	; 3
     15c:	fb 83       	std	Y+3, r31	; 0x03
     15e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     160:	d5 83       	std	Z+5, r29	; 0x05
     162:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     164:	bd 83       	std	Y+5, r27	; 0x05
     166:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     168:	13 96       	adiw	r26, 0x03	; 3
     16a:	dc 93       	st	X, r29
     16c:	ce 93       	st	-X, r28
     16e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     170:	99 87       	std	Y+9, r25	; 0x09
     172:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     174:	fc 01       	movw	r30, r24
     176:	20 81       	ld	r18, Z
     178:	2f 5f       	subi	r18, 0xFF	; 255
     17a:	20 83       	st	Z, r18
}
     17c:	df 91       	pop	r29
     17e:	cf 91       	pop	r28
     180:	08 95       	ret

00000182 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     182:	cf 93       	push	r28
     184:	df 93       	push	r29
     186:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     188:	a0 85       	ldd	r26, Z+8	; 0x08
     18a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     18c:	c2 81       	ldd	r28, Z+2	; 0x02
     18e:	d3 81       	ldd	r29, Z+3	; 0x03
     190:	84 81       	ldd	r24, Z+4	; 0x04
     192:	95 81       	ldd	r25, Z+5	; 0x05
     194:	9d 83       	std	Y+5, r25	; 0x05
     196:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     198:	c4 81       	ldd	r28, Z+4	; 0x04
     19a:	d5 81       	ldd	r29, Z+5	; 0x05
     19c:	82 81       	ldd	r24, Z+2	; 0x02
     19e:	93 81       	ldd	r25, Z+3	; 0x03
     1a0:	9b 83       	std	Y+3, r25	; 0x03
     1a2:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     1a4:	11 96       	adiw	r26, 0x01	; 1
     1a6:	8d 91       	ld	r24, X+
     1a8:	9c 91       	ld	r25, X
     1aa:	12 97       	sbiw	r26, 0x02	; 2
     1ac:	e8 17       	cp	r30, r24
     1ae:	f9 07       	cpc	r31, r25
     1b0:	31 f4       	brne	.+12     	; 0x1be <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     1b2:	84 81       	ldd	r24, Z+4	; 0x04
     1b4:	95 81       	ldd	r25, Z+5	; 0x05
     1b6:	12 96       	adiw	r26, 0x02	; 2
     1b8:	9c 93       	st	X, r25
     1ba:	8e 93       	st	-X, r24
     1bc:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     1be:	11 86       	std	Z+9, r1	; 0x09
     1c0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     1c2:	8c 91       	ld	r24, X
     1c4:	81 50       	subi	r24, 0x01	; 1
     1c6:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     1c8:	df 91       	pop	r29
     1ca:	cf 91       	pop	r28
     1cc:	08 95       	ret

000001ce <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     1ce:	cf 93       	push	r28
     1d0:	df 93       	push	r29
     1d2:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     1d4:	0e 94 55 07 	call	0xeaa	; 0xeaa <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     1d8:	80 91 ae 01 	lds	r24, 0x01AE	; 0x8001ae <__data_end>
     1dc:	90 91 af 01 	lds	r25, 0x01AF	; 0x8001af <__data_end+0x1>
     1e0:	89 2b       	or	r24, r25
     1e2:	31 f4       	brne	.+12     	; 0x1f0 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     1e4:	83 eb       	ldi	r24, 0xB3	; 179
     1e6:	91 e0       	ldi	r25, 0x01	; 1
     1e8:	90 93 af 01 	sts	0x01AF, r25	; 0x8001af <__data_end+0x1>
     1ec:	80 93 ae 01 	sts	0x01AE, r24	; 0x8001ae <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     1f0:	20 91 b0 01 	lds	r18, 0x01B0	; 0x8001b0 <xNextFreeByte>
     1f4:	30 91 b1 01 	lds	r19, 0x01B1	; 0x8001b1 <xNextFreeByte+0x1>
     1f8:	c9 01       	movw	r24, r18
     1fa:	8c 0f       	add	r24, r28
     1fc:	9d 1f       	adc	r25, r29
     1fe:	8b 3d       	cpi	r24, 0xDB	; 219
     200:	45 e0       	ldi	r20, 0x05	; 5
     202:	94 07       	cpc	r25, r20
     204:	70 f4       	brcc	.+28     	; 0x222 <pvPortMalloc+0x54>
     206:	28 17       	cp	r18, r24
     208:	39 07       	cpc	r19, r25
     20a:	70 f4       	brcc	.+28     	; 0x228 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     20c:	c0 91 ae 01 	lds	r28, 0x01AE	; 0x8001ae <__data_end>
     210:	d0 91 af 01 	lds	r29, 0x01AF	; 0x8001af <__data_end+0x1>
     214:	c2 0f       	add	r28, r18
     216:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     218:	90 93 b1 01 	sts	0x01B1, r25	; 0x8001b1 <xNextFreeByte+0x1>
     21c:	80 93 b0 01 	sts	0x01B0, r24	; 0x8001b0 <xNextFreeByte>
     220:	05 c0       	rjmp	.+10     	; 0x22c <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     222:	c0 e0       	ldi	r28, 0x00	; 0
     224:	d0 e0       	ldi	r29, 0x00	; 0
     226:	02 c0       	rjmp	.+4      	; 0x22c <pvPortMalloc+0x5e>
     228:	c0 e0       	ldi	r28, 0x00	; 0
     22a:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     22c:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     230:	ce 01       	movw	r24, r28
     232:	df 91       	pop	r29
     234:	cf 91       	pop	r28
     236:	08 95       	ret

00000238 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     238:	08 95       	ret

0000023a <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     23a:	31 e1       	ldi	r19, 0x11	; 17
     23c:	fc 01       	movw	r30, r24
     23e:	30 83       	st	Z, r19
     240:	31 97       	sbiw	r30, 0x01	; 1
     242:	22 e2       	ldi	r18, 0x22	; 34
     244:	20 83       	st	Z, r18
     246:	31 97       	sbiw	r30, 0x01	; 1
     248:	a3 e3       	ldi	r26, 0x33	; 51
     24a:	a0 83       	st	Z, r26
     24c:	31 97       	sbiw	r30, 0x01	; 1
     24e:	60 83       	st	Z, r22
     250:	31 97       	sbiw	r30, 0x01	; 1
     252:	70 83       	st	Z, r23
     254:	31 97       	sbiw	r30, 0x01	; 1
     256:	10 82       	st	Z, r1
     258:	31 97       	sbiw	r30, 0x01	; 1
     25a:	60 e8       	ldi	r22, 0x80	; 128
     25c:	60 83       	st	Z, r22
     25e:	31 97       	sbiw	r30, 0x01	; 1
     260:	10 82       	st	Z, r1
     262:	31 97       	sbiw	r30, 0x01	; 1
     264:	62 e0       	ldi	r22, 0x02	; 2
     266:	60 83       	st	Z, r22
     268:	31 97       	sbiw	r30, 0x01	; 1
     26a:	63 e0       	ldi	r22, 0x03	; 3
     26c:	60 83       	st	Z, r22
     26e:	31 97       	sbiw	r30, 0x01	; 1
     270:	64 e0       	ldi	r22, 0x04	; 4
     272:	60 83       	st	Z, r22
     274:	31 97       	sbiw	r30, 0x01	; 1
     276:	65 e0       	ldi	r22, 0x05	; 5
     278:	60 83       	st	Z, r22
     27a:	31 97       	sbiw	r30, 0x01	; 1
     27c:	66 e0       	ldi	r22, 0x06	; 6
     27e:	60 83       	st	Z, r22
     280:	31 97       	sbiw	r30, 0x01	; 1
     282:	67 e0       	ldi	r22, 0x07	; 7
     284:	60 83       	st	Z, r22
     286:	31 97       	sbiw	r30, 0x01	; 1
     288:	68 e0       	ldi	r22, 0x08	; 8
     28a:	60 83       	st	Z, r22
     28c:	31 97       	sbiw	r30, 0x01	; 1
     28e:	69 e0       	ldi	r22, 0x09	; 9
     290:	60 83       	st	Z, r22
     292:	31 97       	sbiw	r30, 0x01	; 1
     294:	60 e1       	ldi	r22, 0x10	; 16
     296:	60 83       	st	Z, r22
     298:	31 97       	sbiw	r30, 0x01	; 1
     29a:	30 83       	st	Z, r19
     29c:	31 97       	sbiw	r30, 0x01	; 1
     29e:	32 e1       	ldi	r19, 0x12	; 18
     2a0:	30 83       	st	Z, r19
     2a2:	31 97       	sbiw	r30, 0x01	; 1
     2a4:	33 e1       	ldi	r19, 0x13	; 19
     2a6:	30 83       	st	Z, r19
     2a8:	31 97       	sbiw	r30, 0x01	; 1
     2aa:	34 e1       	ldi	r19, 0x14	; 20
     2ac:	30 83       	st	Z, r19
     2ae:	31 97       	sbiw	r30, 0x01	; 1
     2b0:	35 e1       	ldi	r19, 0x15	; 21
     2b2:	30 83       	st	Z, r19
     2b4:	31 97       	sbiw	r30, 0x01	; 1
     2b6:	36 e1       	ldi	r19, 0x16	; 22
     2b8:	30 83       	st	Z, r19
     2ba:	31 97       	sbiw	r30, 0x01	; 1
     2bc:	37 e1       	ldi	r19, 0x17	; 23
     2be:	30 83       	st	Z, r19
     2c0:	31 97       	sbiw	r30, 0x01	; 1
     2c2:	38 e1       	ldi	r19, 0x18	; 24
     2c4:	30 83       	st	Z, r19
     2c6:	31 97       	sbiw	r30, 0x01	; 1
     2c8:	39 e1       	ldi	r19, 0x19	; 25
     2ca:	30 83       	st	Z, r19
     2cc:	31 97       	sbiw	r30, 0x01	; 1
     2ce:	30 e2       	ldi	r19, 0x20	; 32
     2d0:	30 83       	st	Z, r19
     2d2:	31 97       	sbiw	r30, 0x01	; 1
     2d4:	31 e2       	ldi	r19, 0x21	; 33
     2d6:	30 83       	st	Z, r19
     2d8:	31 97       	sbiw	r30, 0x01	; 1
     2da:	20 83       	st	Z, r18
     2dc:	31 97       	sbiw	r30, 0x01	; 1
     2de:	23 e2       	ldi	r18, 0x23	; 35
     2e0:	20 83       	st	Z, r18
     2e2:	31 97       	sbiw	r30, 0x01	; 1
     2e4:	40 83       	st	Z, r20
     2e6:	31 97       	sbiw	r30, 0x01	; 1
     2e8:	50 83       	st	Z, r21
     2ea:	31 97       	sbiw	r30, 0x01	; 1
     2ec:	26 e2       	ldi	r18, 0x26	; 38
     2ee:	20 83       	st	Z, r18
     2f0:	31 97       	sbiw	r30, 0x01	; 1
     2f2:	27 e2       	ldi	r18, 0x27	; 39
     2f4:	20 83       	st	Z, r18
     2f6:	31 97       	sbiw	r30, 0x01	; 1
     2f8:	28 e2       	ldi	r18, 0x28	; 40
     2fa:	20 83       	st	Z, r18
     2fc:	31 97       	sbiw	r30, 0x01	; 1
     2fe:	29 e2       	ldi	r18, 0x29	; 41
     300:	20 83       	st	Z, r18
     302:	31 97       	sbiw	r30, 0x01	; 1
     304:	20 e3       	ldi	r18, 0x30	; 48
     306:	20 83       	st	Z, r18
     308:	31 97       	sbiw	r30, 0x01	; 1
     30a:	21 e3       	ldi	r18, 0x31	; 49
     30c:	20 83       	st	Z, r18
     30e:	86 97       	sbiw	r24, 0x26	; 38
     310:	08 95       	ret

00000312 <xPortStartScheduler>:
     312:	89 ef       	ldi	r24, 0xF9	; 249
     314:	90 e0       	ldi	r25, 0x00	; 0
     316:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
     31a:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
     31e:	e0 e8       	ldi	r30, 0x80	; 128
     320:	f0 e0       	ldi	r31, 0x00	; 0
     322:	80 81       	ld	r24, Z
     324:	8c 7f       	andi	r24, 0xFC	; 252
     326:	80 83       	st	Z, r24
     328:	8b e0       	ldi	r24, 0x0B	; 11
     32a:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
     32e:	ef e6       	ldi	r30, 0x6F	; 111
     330:	f0 e0       	ldi	r31, 0x00	; 0
     332:	80 81       	ld	r24, Z
     334:	82 60       	ori	r24, 0x02	; 2
     336:	80 83       	st	Z, r24
     338:	a0 91 f2 07 	lds	r26, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     33c:	b0 91 f3 07 	lds	r27, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     340:	cd 91       	ld	r28, X+
     342:	cd bf       	out	0x3d, r28	; 61
     344:	dd 91       	ld	r29, X+
     346:	de bf       	out	0x3e, r29	; 62
     348:	ff 91       	pop	r31
     34a:	ef 91       	pop	r30
     34c:	df 91       	pop	r29
     34e:	cf 91       	pop	r28
     350:	bf 91       	pop	r27
     352:	af 91       	pop	r26
     354:	9f 91       	pop	r25
     356:	8f 91       	pop	r24
     358:	7f 91       	pop	r23
     35a:	6f 91       	pop	r22
     35c:	5f 91       	pop	r21
     35e:	4f 91       	pop	r20
     360:	3f 91       	pop	r19
     362:	2f 91       	pop	r18
     364:	1f 91       	pop	r17
     366:	0f 91       	pop	r16
     368:	ff 90       	pop	r15
     36a:	ef 90       	pop	r14
     36c:	df 90       	pop	r13
     36e:	cf 90       	pop	r12
     370:	bf 90       	pop	r11
     372:	af 90       	pop	r10
     374:	9f 90       	pop	r9
     376:	8f 90       	pop	r8
     378:	7f 90       	pop	r7
     37a:	6f 90       	pop	r6
     37c:	5f 90       	pop	r5
     37e:	4f 90       	pop	r4
     380:	3f 90       	pop	r3
     382:	2f 90       	pop	r2
     384:	1f 90       	pop	r1
     386:	0f 90       	pop	r0
     388:	0f be       	out	0x3f, r0	; 63
     38a:	0f 90       	pop	r0
     38c:	08 95       	ret
     38e:	81 e0       	ldi	r24, 0x01	; 1
     390:	08 95       	ret

00000392 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     392:	0f 92       	push	r0
     394:	0f b6       	in	r0, 0x3f	; 63
     396:	f8 94       	cli
     398:	0f 92       	push	r0
     39a:	1f 92       	push	r1
     39c:	11 24       	eor	r1, r1
     39e:	2f 92       	push	r2
     3a0:	3f 92       	push	r3
     3a2:	4f 92       	push	r4
     3a4:	5f 92       	push	r5
     3a6:	6f 92       	push	r6
     3a8:	7f 92       	push	r7
     3aa:	8f 92       	push	r8
     3ac:	9f 92       	push	r9
     3ae:	af 92       	push	r10
     3b0:	bf 92       	push	r11
     3b2:	cf 92       	push	r12
     3b4:	df 92       	push	r13
     3b6:	ef 92       	push	r14
     3b8:	ff 92       	push	r15
     3ba:	0f 93       	push	r16
     3bc:	1f 93       	push	r17
     3be:	2f 93       	push	r18
     3c0:	3f 93       	push	r19
     3c2:	4f 93       	push	r20
     3c4:	5f 93       	push	r21
     3c6:	6f 93       	push	r22
     3c8:	7f 93       	push	r23
     3ca:	8f 93       	push	r24
     3cc:	9f 93       	push	r25
     3ce:	af 93       	push	r26
     3d0:	bf 93       	push	r27
     3d2:	cf 93       	push	r28
     3d4:	df 93       	push	r29
     3d6:	ef 93       	push	r30
     3d8:	ff 93       	push	r31
     3da:	a0 91 f2 07 	lds	r26, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     3de:	b0 91 f3 07 	lds	r27, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     3e2:	0d b6       	in	r0, 0x3d	; 61
     3e4:	0d 92       	st	X+, r0
     3e6:	0e b6       	in	r0, 0x3e	; 62
     3e8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     3ea:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     3ee:	a0 91 f2 07 	lds	r26, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     3f2:	b0 91 f3 07 	lds	r27, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     3f6:	cd 91       	ld	r28, X+
     3f8:	cd bf       	out	0x3d, r28	; 61
     3fa:	dd 91       	ld	r29, X+
     3fc:	de bf       	out	0x3e, r29	; 62
     3fe:	ff 91       	pop	r31
     400:	ef 91       	pop	r30
     402:	df 91       	pop	r29
     404:	cf 91       	pop	r28
     406:	bf 91       	pop	r27
     408:	af 91       	pop	r26
     40a:	9f 91       	pop	r25
     40c:	8f 91       	pop	r24
     40e:	7f 91       	pop	r23
     410:	6f 91       	pop	r22
     412:	5f 91       	pop	r21
     414:	4f 91       	pop	r20
     416:	3f 91       	pop	r19
     418:	2f 91       	pop	r18
     41a:	1f 91       	pop	r17
     41c:	0f 91       	pop	r16
     41e:	ff 90       	pop	r15
     420:	ef 90       	pop	r14
     422:	df 90       	pop	r13
     424:	cf 90       	pop	r12
     426:	bf 90       	pop	r11
     428:	af 90       	pop	r10
     42a:	9f 90       	pop	r9
     42c:	8f 90       	pop	r8
     42e:	7f 90       	pop	r7
     430:	6f 90       	pop	r6
     432:	5f 90       	pop	r5
     434:	4f 90       	pop	r4
     436:	3f 90       	pop	r3
     438:	2f 90       	pop	r2
     43a:	1f 90       	pop	r1
     43c:	0f 90       	pop	r0
     43e:	0f be       	out	0x3f, r0	; 63
     440:	0f 90       	pop	r0

	asm volatile ( "ret" );
     442:	08 95       	ret

00000444 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     444:	0f 92       	push	r0
     446:	0f b6       	in	r0, 0x3f	; 63
     448:	f8 94       	cli
     44a:	0f 92       	push	r0
     44c:	1f 92       	push	r1
     44e:	11 24       	eor	r1, r1
     450:	2f 92       	push	r2
     452:	3f 92       	push	r3
     454:	4f 92       	push	r4
     456:	5f 92       	push	r5
     458:	6f 92       	push	r6
     45a:	7f 92       	push	r7
     45c:	8f 92       	push	r8
     45e:	9f 92       	push	r9
     460:	af 92       	push	r10
     462:	bf 92       	push	r11
     464:	cf 92       	push	r12
     466:	df 92       	push	r13
     468:	ef 92       	push	r14
     46a:	ff 92       	push	r15
     46c:	0f 93       	push	r16
     46e:	1f 93       	push	r17
     470:	2f 93       	push	r18
     472:	3f 93       	push	r19
     474:	4f 93       	push	r20
     476:	5f 93       	push	r21
     478:	6f 93       	push	r22
     47a:	7f 93       	push	r23
     47c:	8f 93       	push	r24
     47e:	9f 93       	push	r25
     480:	af 93       	push	r26
     482:	bf 93       	push	r27
     484:	cf 93       	push	r28
     486:	df 93       	push	r29
     488:	ef 93       	push	r30
     48a:	ff 93       	push	r31
     48c:	a0 91 f2 07 	lds	r26, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     490:	b0 91 f3 07 	lds	r27, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     494:	0d b6       	in	r0, 0x3d	; 61
     496:	0d 92       	st	X+, r0
     498:	0e b6       	in	r0, 0x3e	; 62
     49a:	0d 92       	st	X+, r0
	xTaskIncrementTick();
     49c:	0e 94 65 07 	call	0xeca	; 0xeca <xTaskIncrementTick>
	vTaskSwitchContext();
     4a0:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     4a4:	a0 91 f2 07 	lds	r26, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     4a8:	b0 91 f3 07 	lds	r27, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     4ac:	cd 91       	ld	r28, X+
     4ae:	cd bf       	out	0x3d, r28	; 61
     4b0:	dd 91       	ld	r29, X+
     4b2:	de bf       	out	0x3e, r29	; 62
     4b4:	ff 91       	pop	r31
     4b6:	ef 91       	pop	r30
     4b8:	df 91       	pop	r29
     4ba:	cf 91       	pop	r28
     4bc:	bf 91       	pop	r27
     4be:	af 91       	pop	r26
     4c0:	9f 91       	pop	r25
     4c2:	8f 91       	pop	r24
     4c4:	7f 91       	pop	r23
     4c6:	6f 91       	pop	r22
     4c8:	5f 91       	pop	r21
     4ca:	4f 91       	pop	r20
     4cc:	3f 91       	pop	r19
     4ce:	2f 91       	pop	r18
     4d0:	1f 91       	pop	r17
     4d2:	0f 91       	pop	r16
     4d4:	ff 90       	pop	r15
     4d6:	ef 90       	pop	r14
     4d8:	df 90       	pop	r13
     4da:	cf 90       	pop	r12
     4dc:	bf 90       	pop	r11
     4de:	af 90       	pop	r10
     4e0:	9f 90       	pop	r9
     4e2:	8f 90       	pop	r8
     4e4:	7f 90       	pop	r7
     4e6:	6f 90       	pop	r6
     4e8:	5f 90       	pop	r5
     4ea:	4f 90       	pop	r4
     4ec:	3f 90       	pop	r3
     4ee:	2f 90       	pop	r2
     4f0:	1f 90       	pop	r1
     4f2:	0f 90       	pop	r0
     4f4:	0f be       	out	0x3f, r0	; 63
     4f6:	0f 90       	pop	r0

	asm volatile ( "ret" );
     4f8:	08 95       	ret

000004fa <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     4fa:	0e 94 22 02 	call	0x444	; 0x444 <vPortYieldFromTick>
		asm volatile ( "reti" );
     4fe:	18 95       	reti

00000500 <prvCopyDataToQueue>:
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
     500:	0f 93       	push	r16
     502:	1f 93       	push	r17
     504:	cf 93       	push	r28
     506:	df 93       	push	r29
     508:	ec 01       	movw	r28, r24
     50a:	04 2f       	mov	r16, r20
     50c:	1a 8d       	ldd	r17, Y+26	; 0x1a
     50e:	4c 8d       	ldd	r20, Y+28	; 0x1c
     510:	44 23       	and	r20, r20
     512:	b9 f1       	breq	.+110    	; 0x582 <prvCopyDataToQueue+0x82>
     514:	01 11       	cpse	r16, r1
     516:	16 c0       	rjmp	.+44     	; 0x544 <prvCopyDataToQueue+0x44>
     518:	50 e0       	ldi	r21, 0x00	; 0
     51a:	8c 81       	ldd	r24, Y+4	; 0x04
     51c:	9d 81       	ldd	r25, Y+5	; 0x05
     51e:	0e 94 e9 15 	call	0x2bd2	; 0x2bd2 <memcpy>
     522:	2c 8d       	ldd	r18, Y+28	; 0x1c
     524:	8c 81       	ldd	r24, Y+4	; 0x04
     526:	9d 81       	ldd	r25, Y+5	; 0x05
     528:	82 0f       	add	r24, r18
     52a:	91 1d       	adc	r25, r1
     52c:	9d 83       	std	Y+5, r25	; 0x05
     52e:	8c 83       	std	Y+4, r24	; 0x04
     530:	2a 81       	ldd	r18, Y+2	; 0x02
     532:	3b 81       	ldd	r19, Y+3	; 0x03
     534:	82 17       	cp	r24, r18
     536:	93 07       	cpc	r25, r19
     538:	20 f1       	brcs	.+72     	; 0x582 <prvCopyDataToQueue+0x82>
     53a:	88 81       	ld	r24, Y
     53c:	99 81       	ldd	r25, Y+1	; 0x01
     53e:	9d 83       	std	Y+5, r25	; 0x05
     540:	8c 83       	std	Y+4, r24	; 0x04
     542:	1f c0       	rjmp	.+62     	; 0x582 <prvCopyDataToQueue+0x82>
     544:	50 e0       	ldi	r21, 0x00	; 0
     546:	8e 81       	ldd	r24, Y+6	; 0x06
     548:	9f 81       	ldd	r25, Y+7	; 0x07
     54a:	0e 94 e9 15 	call	0x2bd2	; 0x2bd2 <memcpy>
     54e:	8c 8d       	ldd	r24, Y+28	; 0x1c
     550:	90 e0       	ldi	r25, 0x00	; 0
     552:	91 95       	neg	r25
     554:	81 95       	neg	r24
     556:	91 09       	sbc	r25, r1
     558:	2e 81       	ldd	r18, Y+6	; 0x06
     55a:	3f 81       	ldd	r19, Y+7	; 0x07
     55c:	28 0f       	add	r18, r24
     55e:	39 1f       	adc	r19, r25
     560:	3f 83       	std	Y+7, r19	; 0x07
     562:	2e 83       	std	Y+6, r18	; 0x06
     564:	48 81       	ld	r20, Y
     566:	59 81       	ldd	r21, Y+1	; 0x01
     568:	24 17       	cp	r18, r20
     56a:	35 07       	cpc	r19, r21
     56c:	30 f4       	brcc	.+12     	; 0x57a <prvCopyDataToQueue+0x7a>
     56e:	2a 81       	ldd	r18, Y+2	; 0x02
     570:	3b 81       	ldd	r19, Y+3	; 0x03
     572:	82 0f       	add	r24, r18
     574:	93 1f       	adc	r25, r19
     576:	9f 83       	std	Y+7, r25	; 0x07
     578:	8e 83       	std	Y+6, r24	; 0x06
     57a:	02 30       	cpi	r16, 0x02	; 2
     57c:	11 f4       	brne	.+4      	; 0x582 <prvCopyDataToQueue+0x82>
     57e:	11 11       	cpse	r17, r1
     580:	11 50       	subi	r17, 0x01	; 1
     582:	1f 5f       	subi	r17, 0xFF	; 255
     584:	1a 8f       	std	Y+26, r17	; 0x1a
     586:	80 e0       	ldi	r24, 0x00	; 0
     588:	df 91       	pop	r29
     58a:	cf 91       	pop	r28
     58c:	1f 91       	pop	r17
     58e:	0f 91       	pop	r16
     590:	08 95       	ret

00000592 <prvCopyDataFromQueue>:
     592:	fc 01       	movw	r30, r24
     594:	44 8d       	ldd	r20, Z+28	; 0x1c
     596:	44 23       	and	r20, r20
     598:	a9 f0       	breq	.+42     	; 0x5c4 <prvCopyDataFromQueue+0x32>
     59a:	50 e0       	ldi	r21, 0x00	; 0
     59c:	26 81       	ldd	r18, Z+6	; 0x06
     59e:	37 81       	ldd	r19, Z+7	; 0x07
     5a0:	24 0f       	add	r18, r20
     5a2:	35 1f       	adc	r19, r21
     5a4:	37 83       	std	Z+7, r19	; 0x07
     5a6:	26 83       	std	Z+6, r18	; 0x06
     5a8:	82 81       	ldd	r24, Z+2	; 0x02
     5aa:	93 81       	ldd	r25, Z+3	; 0x03
     5ac:	28 17       	cp	r18, r24
     5ae:	39 07       	cpc	r19, r25
     5b0:	20 f0       	brcs	.+8      	; 0x5ba <prvCopyDataFromQueue+0x28>
     5b2:	80 81       	ld	r24, Z
     5b4:	91 81       	ldd	r25, Z+1	; 0x01
     5b6:	97 83       	std	Z+7, r25	; 0x07
     5b8:	86 83       	std	Z+6, r24	; 0x06
     5ba:	cb 01       	movw	r24, r22
     5bc:	66 81       	ldd	r22, Z+6	; 0x06
     5be:	77 81       	ldd	r23, Z+7	; 0x07
     5c0:	0e 94 e9 15 	call	0x2bd2	; 0x2bd2 <memcpy>
     5c4:	08 95       	ret

000005c6 <prvUnlockQueue>:
     5c6:	ef 92       	push	r14
     5c8:	ff 92       	push	r15
     5ca:	0f 93       	push	r16
     5cc:	1f 93       	push	r17
     5ce:	cf 93       	push	r28
     5d0:	8c 01       	movw	r16, r24
     5d2:	0f b6       	in	r0, 0x3f	; 63
     5d4:	f8 94       	cli
     5d6:	0f 92       	push	r0
     5d8:	fc 01       	movw	r30, r24
     5da:	c6 8d       	ldd	r28, Z+30	; 0x1e
     5dc:	1c 16       	cp	r1, r28
     5de:	ac f4       	brge	.+42     	; 0x60a <prvUnlockQueue+0x44>
     5e0:	81 89       	ldd	r24, Z+17	; 0x11
     5e2:	81 11       	cpse	r24, r1
     5e4:	06 c0       	rjmp	.+12     	; 0x5f2 <prvUnlockQueue+0x2c>
     5e6:	11 c0       	rjmp	.+34     	; 0x60a <prvUnlockQueue+0x44>
     5e8:	f8 01       	movw	r30, r16
     5ea:	81 89       	ldd	r24, Z+17	; 0x11
     5ec:	81 11       	cpse	r24, r1
     5ee:	05 c0       	rjmp	.+10     	; 0x5fa <prvUnlockQueue+0x34>
     5f0:	0c c0       	rjmp	.+24     	; 0x60a <prvUnlockQueue+0x44>
     5f2:	78 01       	movw	r14, r16
     5f4:	f1 e1       	ldi	r31, 0x11	; 17
     5f6:	ef 0e       	add	r14, r31
     5f8:	f1 1c       	adc	r15, r1
     5fa:	c7 01       	movw	r24, r14
     5fc:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <xTaskRemoveFromEventList>
     600:	81 11       	cpse	r24, r1
     602:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <vTaskMissedYield>
     606:	c1 50       	subi	r28, 0x01	; 1
     608:	79 f7       	brne	.-34     	; 0x5e8 <prvUnlockQueue+0x22>
     60a:	8f ef       	ldi	r24, 0xFF	; 255
     60c:	f8 01       	movw	r30, r16
     60e:	86 8f       	std	Z+30, r24	; 0x1e
     610:	0f 90       	pop	r0
     612:	0f be       	out	0x3f, r0	; 63
     614:	0f b6       	in	r0, 0x3f	; 63
     616:	f8 94       	cli
     618:	0f 92       	push	r0
     61a:	c5 8d       	ldd	r28, Z+29	; 0x1d
     61c:	1c 16       	cp	r1, r28
     61e:	ac f4       	brge	.+42     	; 0x64a <prvUnlockQueue+0x84>
     620:	80 85       	ldd	r24, Z+8	; 0x08
     622:	81 11       	cpse	r24, r1
     624:	06 c0       	rjmp	.+12     	; 0x632 <prvUnlockQueue+0x6c>
     626:	11 c0       	rjmp	.+34     	; 0x64a <prvUnlockQueue+0x84>
     628:	f8 01       	movw	r30, r16
     62a:	80 85       	ldd	r24, Z+8	; 0x08
     62c:	81 11       	cpse	r24, r1
     62e:	05 c0       	rjmp	.+10     	; 0x63a <prvUnlockQueue+0x74>
     630:	0c c0       	rjmp	.+24     	; 0x64a <prvUnlockQueue+0x84>
     632:	78 01       	movw	r14, r16
     634:	f8 e0       	ldi	r31, 0x08	; 8
     636:	ef 0e       	add	r14, r31
     638:	f1 1c       	adc	r15, r1
     63a:	c7 01       	movw	r24, r14
     63c:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <xTaskRemoveFromEventList>
     640:	81 11       	cpse	r24, r1
     642:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <vTaskMissedYield>
     646:	c1 50       	subi	r28, 0x01	; 1
     648:	79 f7       	brne	.-34     	; 0x628 <prvUnlockQueue+0x62>
     64a:	8f ef       	ldi	r24, 0xFF	; 255
     64c:	f8 01       	movw	r30, r16
     64e:	85 8f       	std	Z+29, r24	; 0x1d
     650:	0f 90       	pop	r0
     652:	0f be       	out	0x3f, r0	; 63
     654:	cf 91       	pop	r28
     656:	1f 91       	pop	r17
     658:	0f 91       	pop	r16
     65a:	ff 90       	pop	r15
     65c:	ef 90       	pop	r14
     65e:	08 95       	ret

00000660 <xQueueGenericReset>:
     660:	cf 93       	push	r28
     662:	df 93       	push	r29
     664:	ec 01       	movw	r28, r24
     666:	0f b6       	in	r0, 0x3f	; 63
     668:	f8 94       	cli
     66a:	0f 92       	push	r0
     66c:	48 81       	ld	r20, Y
     66e:	59 81       	ldd	r21, Y+1	; 0x01
     670:	2c 8d       	ldd	r18, Y+28	; 0x1c
     672:	30 e0       	ldi	r19, 0x00	; 0
     674:	7b 8d       	ldd	r23, Y+27	; 0x1b
     676:	72 9f       	mul	r23, r18
     678:	c0 01       	movw	r24, r0
     67a:	73 9f       	mul	r23, r19
     67c:	90 0d       	add	r25, r0
     67e:	11 24       	eor	r1, r1
     680:	fa 01       	movw	r30, r20
     682:	e8 0f       	add	r30, r24
     684:	f9 1f       	adc	r31, r25
     686:	fb 83       	std	Y+3, r31	; 0x03
     688:	ea 83       	std	Y+2, r30	; 0x02
     68a:	1a 8e       	std	Y+26, r1	; 0x1a
     68c:	5d 83       	std	Y+5, r21	; 0x05
     68e:	4c 83       	std	Y+4, r20	; 0x04
     690:	82 1b       	sub	r24, r18
     692:	93 0b       	sbc	r25, r19
     694:	84 0f       	add	r24, r20
     696:	95 1f       	adc	r25, r21
     698:	9f 83       	std	Y+7, r25	; 0x07
     69a:	8e 83       	std	Y+6, r24	; 0x06
     69c:	8f ef       	ldi	r24, 0xFF	; 255
     69e:	8d 8f       	std	Y+29, r24	; 0x1d
     6a0:	8e 8f       	std	Y+30, r24	; 0x1e
     6a2:	61 11       	cpse	r22, r1
     6a4:	0c c0       	rjmp	.+24     	; 0x6be <xQueueGenericReset+0x5e>
     6a6:	88 85       	ldd	r24, Y+8	; 0x08
     6a8:	88 23       	and	r24, r24
     6aa:	89 f0       	breq	.+34     	; 0x6ce <xQueueGenericReset+0x6e>
     6ac:	ce 01       	movw	r24, r28
     6ae:	08 96       	adiw	r24, 0x08	; 8
     6b0:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <xTaskRemoveFromEventList>
     6b4:	88 23       	and	r24, r24
     6b6:	59 f0       	breq	.+22     	; 0x6ce <xQueueGenericReset+0x6e>
     6b8:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     6bc:	08 c0       	rjmp	.+16     	; 0x6ce <xQueueGenericReset+0x6e>
     6be:	ce 01       	movw	r24, r28
     6c0:	08 96       	adiw	r24, 0x08	; 8
     6c2:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     6c6:	ce 01       	movw	r24, r28
     6c8:	41 96       	adiw	r24, 0x11	; 17
     6ca:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     6ce:	0f 90       	pop	r0
     6d0:	0f be       	out	0x3f, r0	; 63
     6d2:	81 e0       	ldi	r24, 0x01	; 1
     6d4:	df 91       	pop	r29
     6d6:	cf 91       	pop	r28
     6d8:	08 95       	ret

000006da <xQueueGenericCreate>:
     6da:	0f 93       	push	r16
     6dc:	1f 93       	push	r17
     6de:	cf 93       	push	r28
     6e0:	df 93       	push	r29
     6e2:	08 2f       	mov	r16, r24
     6e4:	16 2f       	mov	r17, r22
     6e6:	66 23       	and	r22, r22
     6e8:	c1 f0       	breq	.+48     	; 0x71a <xQueueGenericCreate+0x40>
     6ea:	86 9f       	mul	r24, r22
     6ec:	c0 01       	movw	r24, r0
     6ee:	11 24       	eor	r1, r1
     6f0:	4f 96       	adiw	r24, 0x1f	; 31
     6f2:	0e 94 e7 00 	call	0x1ce	; 0x1ce <pvPortMalloc>
     6f6:	ec 01       	movw	r28, r24
     6f8:	00 97       	sbiw	r24, 0x00	; 0
     6fa:	41 f4       	brne	.+16     	; 0x70c <xQueueGenericCreate+0x32>
     6fc:	15 c0       	rjmp	.+42     	; 0x728 <xQueueGenericCreate+0x4e>
     6fe:	0b 8f       	std	Y+27, r16	; 0x1b
     700:	1c 8f       	std	Y+28, r17	; 0x1c
     702:	61 e0       	ldi	r22, 0x01	; 1
     704:	ce 01       	movw	r24, r28
     706:	0e 94 30 03 	call	0x660	; 0x660 <xQueueGenericReset>
     70a:	0e c0       	rjmp	.+28     	; 0x728 <xQueueGenericCreate+0x4e>
     70c:	4f 96       	adiw	r24, 0x1f	; 31
     70e:	99 83       	std	Y+1, r25	; 0x01
     710:	88 83       	st	Y, r24
     712:	f5 cf       	rjmp	.-22     	; 0x6fe <xQueueGenericCreate+0x24>
     714:	d9 83       	std	Y+1, r29	; 0x01
     716:	c8 83       	st	Y, r28
     718:	f2 cf       	rjmp	.-28     	; 0x6fe <xQueueGenericCreate+0x24>
     71a:	8f e1       	ldi	r24, 0x1F	; 31
     71c:	90 e0       	ldi	r25, 0x00	; 0
     71e:	0e 94 e7 00 	call	0x1ce	; 0x1ce <pvPortMalloc>
     722:	ec 01       	movw	r28, r24
     724:	89 2b       	or	r24, r25
     726:	b1 f7       	brne	.-20     	; 0x714 <xQueueGenericCreate+0x3a>
     728:	ce 01       	movw	r24, r28
     72a:	df 91       	pop	r29
     72c:	cf 91       	pop	r28
     72e:	1f 91       	pop	r17
     730:	0f 91       	pop	r16
     732:	08 95       	ret

00000734 <xQueueGenericSend>:
     734:	9f 92       	push	r9
     736:	af 92       	push	r10
     738:	bf 92       	push	r11
     73a:	cf 92       	push	r12
     73c:	df 92       	push	r13
     73e:	ef 92       	push	r14
     740:	ff 92       	push	r15
     742:	0f 93       	push	r16
     744:	1f 93       	push	r17
     746:	cf 93       	push	r28
     748:	df 93       	push	r29
     74a:	00 d0       	rcall	.+0      	; 0x74c <xQueueGenericSend+0x18>
     74c:	00 d0       	rcall	.+0      	; 0x74e <xQueueGenericSend+0x1a>
     74e:	1f 92       	push	r1
     750:	cd b7       	in	r28, 0x3d	; 61
     752:	de b7       	in	r29, 0x3e	; 62
     754:	8c 01       	movw	r16, r24
     756:	6b 01       	movw	r12, r22
     758:	5d 83       	std	Y+5, r21	; 0x05
     75a:	4c 83       	std	Y+4, r20	; 0x04
     75c:	a2 2e       	mov	r10, r18
     75e:	b1 2c       	mov	r11, r1
     760:	99 24       	eor	r9, r9
     762:	93 94       	inc	r9
     764:	7c 01       	movw	r14, r24
     766:	88 e0       	ldi	r24, 0x08	; 8
     768:	e8 0e       	add	r14, r24
     76a:	f1 1c       	adc	r15, r1
     76c:	0f b6       	in	r0, 0x3f	; 63
     76e:	f8 94       	cli
     770:	0f 92       	push	r0
     772:	f8 01       	movw	r30, r16
     774:	92 8d       	ldd	r25, Z+26	; 0x1a
     776:	83 8d       	ldd	r24, Z+27	; 0x1b
     778:	98 17       	cp	r25, r24
     77a:	18 f0       	brcs	.+6      	; 0x782 <xQueueGenericSend+0x4e>
     77c:	f2 e0       	ldi	r31, 0x02	; 2
     77e:	af 12       	cpse	r10, r31
     780:	19 c0       	rjmp	.+50     	; 0x7b4 <xQueueGenericSend+0x80>
     782:	4a 2d       	mov	r20, r10
     784:	b6 01       	movw	r22, r12
     786:	c8 01       	movw	r24, r16
     788:	0e 94 80 02 	call	0x500	; 0x500 <prvCopyDataToQueue>
     78c:	f8 01       	movw	r30, r16
     78e:	91 89       	ldd	r25, Z+17	; 0x11
     790:	99 23       	and	r25, r25
     792:	49 f0       	breq	.+18     	; 0x7a6 <xQueueGenericSend+0x72>
     794:	c8 01       	movw	r24, r16
     796:	41 96       	adiw	r24, 0x11	; 17
     798:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <xTaskRemoveFromEventList>
     79c:	88 23       	and	r24, r24
     79e:	31 f0       	breq	.+12     	; 0x7ac <xQueueGenericSend+0x78>
     7a0:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     7a4:	03 c0       	rjmp	.+6      	; 0x7ac <xQueueGenericSend+0x78>
     7a6:	81 11       	cpse	r24, r1
     7a8:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     7ac:	0f 90       	pop	r0
     7ae:	0f be       	out	0x3f, r0	; 63
     7b0:	81 e0       	ldi	r24, 0x01	; 1
     7b2:	50 c0       	rjmp	.+160    	; 0x854 <xQueueGenericSend+0x120>
     7b4:	8c 81       	ldd	r24, Y+4	; 0x04
     7b6:	9d 81       	ldd	r25, Y+5	; 0x05
     7b8:	89 2b       	or	r24, r25
     7ba:	21 f4       	brne	.+8      	; 0x7c4 <xQueueGenericSend+0x90>
     7bc:	0f 90       	pop	r0
     7be:	0f be       	out	0x3f, r0	; 63
     7c0:	80 e0       	ldi	r24, 0x00	; 0
     7c2:	48 c0       	rjmp	.+144    	; 0x854 <xQueueGenericSend+0x120>
     7c4:	b1 10       	cpse	r11, r1
     7c6:	05 c0       	rjmp	.+10     	; 0x7d2 <xQueueGenericSend+0x9e>
     7c8:	ce 01       	movw	r24, r28
     7ca:	01 96       	adiw	r24, 0x01	; 1
     7cc:	0e 94 19 0a 	call	0x1432	; 0x1432 <vTaskSetTimeOutState>
     7d0:	b9 2c       	mov	r11, r9
     7d2:	0f 90       	pop	r0
     7d4:	0f be       	out	0x3f, r0	; 63
     7d6:	0e 94 55 07 	call	0xeaa	; 0xeaa <vTaskSuspendAll>
     7da:	0f b6       	in	r0, 0x3f	; 63
     7dc:	f8 94       	cli
     7de:	0f 92       	push	r0
     7e0:	f8 01       	movw	r30, r16
     7e2:	85 8d       	ldd	r24, Z+29	; 0x1d
     7e4:	8f 3f       	cpi	r24, 0xFF	; 255
     7e6:	09 f4       	brne	.+2      	; 0x7ea <xQueueGenericSend+0xb6>
     7e8:	15 8e       	std	Z+29, r1	; 0x1d
     7ea:	f8 01       	movw	r30, r16
     7ec:	86 8d       	ldd	r24, Z+30	; 0x1e
     7ee:	8f 3f       	cpi	r24, 0xFF	; 255
     7f0:	09 f4       	brne	.+2      	; 0x7f4 <xQueueGenericSend+0xc0>
     7f2:	16 8e       	std	Z+30, r1	; 0x1e
     7f4:	0f 90       	pop	r0
     7f6:	0f be       	out	0x3f, r0	; 63
     7f8:	be 01       	movw	r22, r28
     7fa:	6c 5f       	subi	r22, 0xFC	; 252
     7fc:	7f 4f       	sbci	r23, 0xFF	; 255
     7fe:	ce 01       	movw	r24, r28
     800:	01 96       	adiw	r24, 0x01	; 1
     802:	0e 94 24 0a 	call	0x1448	; 0x1448 <xTaskCheckForTimeOut>
     806:	81 11       	cpse	r24, r1
     808:	1f c0       	rjmp	.+62     	; 0x848 <xQueueGenericSend+0x114>
     80a:	0f b6       	in	r0, 0x3f	; 63
     80c:	f8 94       	cli
     80e:	0f 92       	push	r0
     810:	f8 01       	movw	r30, r16
     812:	92 8d       	ldd	r25, Z+26	; 0x1a
     814:	0f 90       	pop	r0
     816:	0f be       	out	0x3f, r0	; 63
     818:	83 8d       	ldd	r24, Z+27	; 0x1b
     81a:	98 13       	cpse	r25, r24
     81c:	0f c0       	rjmp	.+30     	; 0x83c <xQueueGenericSend+0x108>
     81e:	6c 81       	ldd	r22, Y+4	; 0x04
     820:	7d 81       	ldd	r23, Y+5	; 0x05
     822:	c7 01       	movw	r24, r14
     824:	0e 94 a6 09 	call	0x134c	; 0x134c <vTaskPlaceOnEventList>
     828:	c8 01       	movw	r24, r16
     82a:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <prvUnlockQueue>
     82e:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
     832:	81 11       	cpse	r24, r1
     834:	9b cf       	rjmp	.-202    	; 0x76c <xQueueGenericSend+0x38>
     836:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     83a:	98 cf       	rjmp	.-208    	; 0x76c <xQueueGenericSend+0x38>
     83c:	c8 01       	movw	r24, r16
     83e:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <prvUnlockQueue>
     842:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
     846:	92 cf       	rjmp	.-220    	; 0x76c <xQueueGenericSend+0x38>
     848:	c8 01       	movw	r24, r16
     84a:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <prvUnlockQueue>
     84e:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
     852:	80 e0       	ldi	r24, 0x00	; 0
     854:	0f 90       	pop	r0
     856:	0f 90       	pop	r0
     858:	0f 90       	pop	r0
     85a:	0f 90       	pop	r0
     85c:	0f 90       	pop	r0
     85e:	df 91       	pop	r29
     860:	cf 91       	pop	r28
     862:	1f 91       	pop	r17
     864:	0f 91       	pop	r16
     866:	ff 90       	pop	r15
     868:	ef 90       	pop	r14
     86a:	df 90       	pop	r13
     86c:	cf 90       	pop	r12
     86e:	bf 90       	pop	r11
     870:	af 90       	pop	r10
     872:	9f 90       	pop	r9
     874:	08 95       	ret

00000876 <xQueueGenericSendFromISR>:
     876:	ef 92       	push	r14
     878:	ff 92       	push	r15
     87a:	0f 93       	push	r16
     87c:	1f 93       	push	r17
     87e:	cf 93       	push	r28
     880:	df 93       	push	r29
     882:	8a 01       	movw	r16, r20
     884:	fc 01       	movw	r30, r24
     886:	52 8d       	ldd	r21, Z+26	; 0x1a
     888:	33 8d       	ldd	r19, Z+27	; 0x1b
     88a:	53 17       	cp	r21, r19
     88c:	10 f0       	brcs	.+4      	; 0x892 <xQueueGenericSendFromISR+0x1c>
     88e:	22 30       	cpi	r18, 0x02	; 2
     890:	f1 f4       	brne	.+60     	; 0x8ce <xQueueGenericSendFromISR+0x58>
     892:	42 2f       	mov	r20, r18
     894:	78 01       	movw	r14, r16
     896:	ec 01       	movw	r28, r24
     898:	1e 8d       	ldd	r17, Y+30	; 0x1e
     89a:	0e 94 80 02 	call	0x500	; 0x500 <prvCopyDataToQueue>
     89e:	1f 3f       	cpi	r17, 0xFF	; 255
     8a0:	81 f4       	brne	.+32     	; 0x8c2 <xQueueGenericSendFromISR+0x4c>
     8a2:	89 89       	ldd	r24, Y+17	; 0x11
     8a4:	88 23       	and	r24, r24
     8a6:	a9 f0       	breq	.+42     	; 0x8d2 <xQueueGenericSendFromISR+0x5c>
     8a8:	ce 01       	movw	r24, r28
     8aa:	41 96       	adiw	r24, 0x11	; 17
     8ac:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <xTaskRemoveFromEventList>
     8b0:	88 23       	and	r24, r24
     8b2:	89 f0       	breq	.+34     	; 0x8d6 <xQueueGenericSendFromISR+0x60>
     8b4:	e1 14       	cp	r14, r1
     8b6:	f1 04       	cpc	r15, r1
     8b8:	81 f0       	breq	.+32     	; 0x8da <xQueueGenericSendFromISR+0x64>
     8ba:	81 e0       	ldi	r24, 0x01	; 1
     8bc:	f7 01       	movw	r30, r14
     8be:	80 83       	st	Z, r24
     8c0:	0d c0       	rjmp	.+26     	; 0x8dc <xQueueGenericSendFromISR+0x66>
     8c2:	ff 24       	eor	r15, r15
     8c4:	f3 94       	inc	r15
     8c6:	f1 0e       	add	r15, r17
     8c8:	fe 8e       	std	Y+30, r15	; 0x1e
     8ca:	81 e0       	ldi	r24, 0x01	; 1
     8cc:	07 c0       	rjmp	.+14     	; 0x8dc <xQueueGenericSendFromISR+0x66>
     8ce:	80 e0       	ldi	r24, 0x00	; 0
     8d0:	05 c0       	rjmp	.+10     	; 0x8dc <xQueueGenericSendFromISR+0x66>
     8d2:	81 e0       	ldi	r24, 0x01	; 1
     8d4:	03 c0       	rjmp	.+6      	; 0x8dc <xQueueGenericSendFromISR+0x66>
     8d6:	81 e0       	ldi	r24, 0x01	; 1
     8d8:	01 c0       	rjmp	.+2      	; 0x8dc <xQueueGenericSendFromISR+0x66>
     8da:	81 e0       	ldi	r24, 0x01	; 1
     8dc:	df 91       	pop	r29
     8de:	cf 91       	pop	r28
     8e0:	1f 91       	pop	r17
     8e2:	0f 91       	pop	r16
     8e4:	ff 90       	pop	r15
     8e6:	ef 90       	pop	r14
     8e8:	08 95       	ret

000008ea <xQueueGenericReceive>:
     8ea:	8f 92       	push	r8
     8ec:	9f 92       	push	r9
     8ee:	af 92       	push	r10
     8f0:	bf 92       	push	r11
     8f2:	cf 92       	push	r12
     8f4:	df 92       	push	r13
     8f6:	ef 92       	push	r14
     8f8:	ff 92       	push	r15
     8fa:	0f 93       	push	r16
     8fc:	1f 93       	push	r17
     8fe:	cf 93       	push	r28
     900:	df 93       	push	r29
     902:	00 d0       	rcall	.+0      	; 0x904 <__stack+0x5>
     904:	00 d0       	rcall	.+0      	; 0x906 <__stack+0x7>
     906:	1f 92       	push	r1
     908:	cd b7       	in	r28, 0x3d	; 61
     90a:	de b7       	in	r29, 0x3e	; 62
     90c:	8c 01       	movw	r16, r24
     90e:	5b 01       	movw	r10, r22
     910:	5d 83       	std	Y+5, r21	; 0x05
     912:	4c 83       	std	Y+4, r20	; 0x04
     914:	82 2e       	mov	r8, r18
     916:	e1 2c       	mov	r14, r1
     918:	99 24       	eor	r9, r9
     91a:	93 94       	inc	r9
     91c:	6c 01       	movw	r12, r24
     91e:	81 e1       	ldi	r24, 0x11	; 17
     920:	c8 0e       	add	r12, r24
     922:	d1 1c       	adc	r13, r1
     924:	0f b6       	in	r0, 0x3f	; 63
     926:	f8 94       	cli
     928:	0f 92       	push	r0
     92a:	f8 01       	movw	r30, r16
     92c:	f2 8c       	ldd	r15, Z+26	; 0x1a
     92e:	ff 20       	and	r15, r15
     930:	41 f1       	breq	.+80     	; 0x982 <__stack+0x83>
     932:	c6 80       	ldd	r12, Z+6	; 0x06
     934:	d7 80       	ldd	r13, Z+7	; 0x07
     936:	b5 01       	movw	r22, r10
     938:	c8 01       	movw	r24, r16
     93a:	0e 94 c9 02 	call	0x592	; 0x592 <prvCopyDataFromQueue>
     93e:	81 10       	cpse	r8, r1
     940:	0f c0       	rjmp	.+30     	; 0x960 <__stack+0x61>
     942:	fa 94       	dec	r15
     944:	f8 01       	movw	r30, r16
     946:	f2 8e       	std	Z+26, r15	; 0x1a
     948:	80 85       	ldd	r24, Z+8	; 0x08
     94a:	88 23       	and	r24, r24
     94c:	b1 f0       	breq	.+44     	; 0x97a <__stack+0x7b>
     94e:	c8 01       	movw	r24, r16
     950:	08 96       	adiw	r24, 0x08	; 8
     952:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <xTaskRemoveFromEventList>
     956:	88 23       	and	r24, r24
     958:	81 f0       	breq	.+32     	; 0x97a <__stack+0x7b>
     95a:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     95e:	0d c0       	rjmp	.+26     	; 0x97a <__stack+0x7b>
     960:	f8 01       	movw	r30, r16
     962:	d7 82       	std	Z+7, r13	; 0x07
     964:	c6 82       	std	Z+6, r12	; 0x06
     966:	81 89       	ldd	r24, Z+17	; 0x11
     968:	88 23       	and	r24, r24
     96a:	39 f0       	breq	.+14     	; 0x97a <__stack+0x7b>
     96c:	c8 01       	movw	r24, r16
     96e:	41 96       	adiw	r24, 0x11	; 17
     970:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <xTaskRemoveFromEventList>
     974:	81 11       	cpse	r24, r1
     976:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     97a:	0f 90       	pop	r0
     97c:	0f be       	out	0x3f, r0	; 63
     97e:	81 e0       	ldi	r24, 0x01	; 1
     980:	57 c0       	rjmp	.+174    	; 0xa30 <__stack+0x131>
     982:	8c 81       	ldd	r24, Y+4	; 0x04
     984:	9d 81       	ldd	r25, Y+5	; 0x05
     986:	89 2b       	or	r24, r25
     988:	21 f4       	brne	.+8      	; 0x992 <__stack+0x93>
     98a:	0f 90       	pop	r0
     98c:	0f be       	out	0x3f, r0	; 63
     98e:	80 e0       	ldi	r24, 0x00	; 0
     990:	4f c0       	rjmp	.+158    	; 0xa30 <__stack+0x131>
     992:	e1 10       	cpse	r14, r1
     994:	05 c0       	rjmp	.+10     	; 0x9a0 <__stack+0xa1>
     996:	ce 01       	movw	r24, r28
     998:	01 96       	adiw	r24, 0x01	; 1
     99a:	0e 94 19 0a 	call	0x1432	; 0x1432 <vTaskSetTimeOutState>
     99e:	e9 2c       	mov	r14, r9
     9a0:	0f 90       	pop	r0
     9a2:	0f be       	out	0x3f, r0	; 63
     9a4:	0e 94 55 07 	call	0xeaa	; 0xeaa <vTaskSuspendAll>
     9a8:	0f b6       	in	r0, 0x3f	; 63
     9aa:	f8 94       	cli
     9ac:	0f 92       	push	r0
     9ae:	f8 01       	movw	r30, r16
     9b0:	85 8d       	ldd	r24, Z+29	; 0x1d
     9b2:	8f 3f       	cpi	r24, 0xFF	; 255
     9b4:	09 f4       	brne	.+2      	; 0x9b8 <__stack+0xb9>
     9b6:	15 8e       	std	Z+29, r1	; 0x1d
     9b8:	f8 01       	movw	r30, r16
     9ba:	86 8d       	ldd	r24, Z+30	; 0x1e
     9bc:	8f 3f       	cpi	r24, 0xFF	; 255
     9be:	09 f4       	brne	.+2      	; 0x9c2 <__stack+0xc3>
     9c0:	16 8e       	std	Z+30, r1	; 0x1e
     9c2:	0f 90       	pop	r0
     9c4:	0f be       	out	0x3f, r0	; 63
     9c6:	be 01       	movw	r22, r28
     9c8:	6c 5f       	subi	r22, 0xFC	; 252
     9ca:	7f 4f       	sbci	r23, 0xFF	; 255
     9cc:	ce 01       	movw	r24, r28
     9ce:	01 96       	adiw	r24, 0x01	; 1
     9d0:	0e 94 24 0a 	call	0x1448	; 0x1448 <xTaskCheckForTimeOut>
     9d4:	81 11       	cpse	r24, r1
     9d6:	1e c0       	rjmp	.+60     	; 0xa14 <__stack+0x115>
     9d8:	0f b6       	in	r0, 0x3f	; 63
     9da:	f8 94       	cli
     9dc:	0f 92       	push	r0
     9de:	f8 01       	movw	r30, r16
     9e0:	82 8d       	ldd	r24, Z+26	; 0x1a
     9e2:	0f 90       	pop	r0
     9e4:	0f be       	out	0x3f, r0	; 63
     9e6:	81 11       	cpse	r24, r1
     9e8:	0f c0       	rjmp	.+30     	; 0xa08 <__stack+0x109>
     9ea:	6c 81       	ldd	r22, Y+4	; 0x04
     9ec:	7d 81       	ldd	r23, Y+5	; 0x05
     9ee:	c6 01       	movw	r24, r12
     9f0:	0e 94 a6 09 	call	0x134c	; 0x134c <vTaskPlaceOnEventList>
     9f4:	c8 01       	movw	r24, r16
     9f6:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <prvUnlockQueue>
     9fa:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
     9fe:	81 11       	cpse	r24, r1
     a00:	91 cf       	rjmp	.-222    	; 0x924 <__stack+0x25>
     a02:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     a06:	8e cf       	rjmp	.-228    	; 0x924 <__stack+0x25>
     a08:	c8 01       	movw	r24, r16
     a0a:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <prvUnlockQueue>
     a0e:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
     a12:	88 cf       	rjmp	.-240    	; 0x924 <__stack+0x25>
     a14:	c8 01       	movw	r24, r16
     a16:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <prvUnlockQueue>
     a1a:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
     a1e:	0f b6       	in	r0, 0x3f	; 63
     a20:	f8 94       	cli
     a22:	0f 92       	push	r0
     a24:	f8 01       	movw	r30, r16
     a26:	82 8d       	ldd	r24, Z+26	; 0x1a
     a28:	0f 90       	pop	r0
     a2a:	0f be       	out	0x3f, r0	; 63
     a2c:	81 11       	cpse	r24, r1
     a2e:	7a cf       	rjmp	.-268    	; 0x924 <__stack+0x25>
     a30:	0f 90       	pop	r0
     a32:	0f 90       	pop	r0
     a34:	0f 90       	pop	r0
     a36:	0f 90       	pop	r0
     a38:	0f 90       	pop	r0
     a3a:	df 91       	pop	r29
     a3c:	cf 91       	pop	r28
     a3e:	1f 91       	pop	r17
     a40:	0f 91       	pop	r16
     a42:	ff 90       	pop	r15
     a44:	ef 90       	pop	r14
     a46:	df 90       	pop	r13
     a48:	cf 90       	pop	r12
     a4a:	bf 90       	pop	r11
     a4c:	af 90       	pop	r10
     a4e:	9f 90       	pop	r9
     a50:	8f 90       	pop	r8
     a52:	08 95       	ret

00000a54 <vQueueAddToRegistry>:
     a54:	20 91 7b 08 	lds	r18, 0x087B	; 0x80087b <xQueueRegistry>
     a58:	30 91 7c 08 	lds	r19, 0x087C	; 0x80087c <xQueueRegistry+0x1>
     a5c:	23 2b       	or	r18, r19
     a5e:	31 f4       	brne	.+12     	; 0xa6c <vQueueAddToRegistry+0x18>
     a60:	eb e7       	ldi	r30, 0x7B	; 123
     a62:	f8 e0       	ldi	r31, 0x08	; 8
     a64:	71 83       	std	Z+1, r23	; 0x01
     a66:	60 83       	st	Z, r22
     a68:	93 83       	std	Z+3, r25	; 0x03
     a6a:	82 83       	std	Z+2, r24	; 0x02
     a6c:	08 95       	ret

00000a6e <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
     a6e:	cf 93       	push	r28
     a70:	df 93       	push	r29
     a72:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
     a74:	0f b6       	in	r0, 0x3f	; 63
     a76:	f8 94       	cli
     a78:	0f 92       	push	r0
     a7a:	8d 8d       	ldd	r24, Y+29	; 0x1d
     a7c:	8f 3f       	cpi	r24, 0xFF	; 255
     a7e:	09 f4       	brne	.+2      	; 0xa82 <vQueueWaitForMessageRestricted+0x14>
     a80:	1d 8e       	std	Y+29, r1	; 0x1d
     a82:	8e 8d       	ldd	r24, Y+30	; 0x1e
     a84:	8f 3f       	cpi	r24, 0xFF	; 255
     a86:	09 f4       	brne	.+2      	; 0xa8a <vQueueWaitForMessageRestricted+0x1c>
     a88:	1e 8e       	std	Y+30, r1	; 0x1e
     a8a:	0f 90       	pop	r0
     a8c:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
     a8e:	8a 8d       	ldd	r24, Y+26	; 0x1a
     a90:	81 11       	cpse	r24, r1
     a92:	04 c0       	rjmp	.+8      	; 0xa9c <vQueueWaitForMessageRestricted+0x2e>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
     a94:	ce 01       	movw	r24, r28
     a96:	41 96       	adiw	r24, 0x11	; 17
     a98:	0e 94 b8 09 	call	0x1370	; 0x1370 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
     a9c:	ce 01       	movw	r24, r28
     a9e:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <prvUnlockQueue>
	}
     aa2:	df 91       	pop	r29
     aa4:	cf 91       	pop	r28
     aa6:	08 95       	ret

00000aa8 <prvResetNextTaskUnblockTime>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     aa8:	e0 91 ba 07 	lds	r30, 0x07BA	; 0x8007ba <pxDelayedTaskList>
     aac:	f0 91 bb 07 	lds	r31, 0x07BB	; 0x8007bb <pxDelayedTaskList+0x1>
     ab0:	80 81       	ld	r24, Z
     ab2:	81 11       	cpse	r24, r1
     ab4:	07 c0       	rjmp	.+14     	; 0xac4 <prvResetNextTaskUnblockTime+0x1c>
     ab6:	8f ef       	ldi	r24, 0xFF	; 255
     ab8:	9f ef       	ldi	r25, 0xFF	; 255
     aba:	90 93 92 07 	sts	0x0792, r25	; 0x800792 <xNextTaskUnblockTime+0x1>
     abe:	80 93 91 07 	sts	0x0791, r24	; 0x800791 <xNextTaskUnblockTime>
     ac2:	08 95       	ret
     ac4:	e0 91 ba 07 	lds	r30, 0x07BA	; 0x8007ba <pxDelayedTaskList>
     ac8:	f0 91 bb 07 	lds	r31, 0x07BB	; 0x8007bb <pxDelayedTaskList+0x1>
     acc:	05 80       	ldd	r0, Z+5	; 0x05
     ace:	f6 81       	ldd	r31, Z+6	; 0x06
     ad0:	e0 2d       	mov	r30, r0
     ad2:	06 80       	ldd	r0, Z+6	; 0x06
     ad4:	f7 81       	ldd	r31, Z+7	; 0x07
     ad6:	e0 2d       	mov	r30, r0
     ad8:	82 81       	ldd	r24, Z+2	; 0x02
     ada:	93 81       	ldd	r25, Z+3	; 0x03
     adc:	90 93 92 07 	sts	0x0792, r25	; 0x800792 <xNextTaskUnblockTime+0x1>
     ae0:	80 93 91 07 	sts	0x0791, r24	; 0x800791 <xNextTaskUnblockTime>
     ae4:	08 95       	ret

00000ae6 <prvAddCurrentTaskToDelayedList>:
     ae6:	ff 92       	push	r15
     ae8:	0f 93       	push	r16
     aea:	1f 93       	push	r17
     aec:	cf 93       	push	r28
     aee:	df 93       	push	r29
     af0:	ec 01       	movw	r28, r24
     af2:	f6 2e       	mov	r15, r22
     af4:	00 91 99 07 	lds	r16, 0x0799	; 0x800799 <xTickCount>
     af8:	10 91 9a 07 	lds	r17, 0x079A	; 0x80079a <xTickCount+0x1>
     afc:	80 91 f2 07 	lds	r24, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     b00:	90 91 f3 07 	lds	r25, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     b04:	02 96       	adiw	r24, 0x02	; 2
     b06:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
     b0a:	cf 3f       	cpi	r28, 0xFF	; 255
     b0c:	8f ef       	ldi	r24, 0xFF	; 255
     b0e:	d8 07       	cpc	r29, r24
     b10:	69 f4       	brne	.+26     	; 0xb2c <prvAddCurrentTaskToDelayedList+0x46>
     b12:	ff 20       	and	r15, r15
     b14:	59 f0       	breq	.+22     	; 0xb2c <prvAddCurrentTaskToDelayedList+0x46>
     b16:	60 91 f2 07 	lds	r22, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     b1a:	70 91 f3 07 	lds	r23, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     b1e:	6e 5f       	subi	r22, 0xFE	; 254
     b20:	7f 4f       	sbci	r23, 0xFF	; 255
     b22:	8c e9       	ldi	r24, 0x9C	; 156
     b24:	97 e0       	ldi	r25, 0x07	; 7
     b26:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
     b2a:	2f c0       	rjmp	.+94     	; 0xb8a <prvAddCurrentTaskToDelayedList+0xa4>
     b2c:	c0 0f       	add	r28, r16
     b2e:	d1 1f       	adc	r29, r17
     b30:	e0 91 f2 07 	lds	r30, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     b34:	f0 91 f3 07 	lds	r31, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     b38:	d3 83       	std	Z+3, r29	; 0x03
     b3a:	c2 83       	std	Z+2, r28	; 0x02
     b3c:	c0 17       	cp	r28, r16
     b3e:	d1 07       	cpc	r29, r17
     b40:	68 f4       	brcc	.+26     	; 0xb5c <prvAddCurrentTaskToDelayedList+0x76>
     b42:	60 91 f2 07 	lds	r22, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     b46:	70 91 f3 07 	lds	r23, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     b4a:	80 91 b8 07 	lds	r24, 0x07B8	; 0x8007b8 <pxOverflowDelayedTaskList>
     b4e:	90 91 b9 07 	lds	r25, 0x07B9	; 0x8007b9 <pxOverflowDelayedTaskList+0x1>
     b52:	6e 5f       	subi	r22, 0xFE	; 254
     b54:	7f 4f       	sbci	r23, 0xFF	; 255
     b56:	0e 94 90 00 	call	0x120	; 0x120 <vListInsert>
     b5a:	17 c0       	rjmp	.+46     	; 0xb8a <prvAddCurrentTaskToDelayedList+0xa4>
     b5c:	60 91 f2 07 	lds	r22, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     b60:	70 91 f3 07 	lds	r23, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     b64:	80 91 ba 07 	lds	r24, 0x07BA	; 0x8007ba <pxDelayedTaskList>
     b68:	90 91 bb 07 	lds	r25, 0x07BB	; 0x8007bb <pxDelayedTaskList+0x1>
     b6c:	6e 5f       	subi	r22, 0xFE	; 254
     b6e:	7f 4f       	sbci	r23, 0xFF	; 255
     b70:	0e 94 90 00 	call	0x120	; 0x120 <vListInsert>
     b74:	80 91 91 07 	lds	r24, 0x0791	; 0x800791 <xNextTaskUnblockTime>
     b78:	90 91 92 07 	lds	r25, 0x0792	; 0x800792 <xNextTaskUnblockTime+0x1>
     b7c:	c8 17       	cp	r28, r24
     b7e:	d9 07       	cpc	r29, r25
     b80:	20 f4       	brcc	.+8      	; 0xb8a <prvAddCurrentTaskToDelayedList+0xa4>
     b82:	d0 93 92 07 	sts	0x0792, r29	; 0x800792 <xNextTaskUnblockTime+0x1>
     b86:	c0 93 91 07 	sts	0x0791, r28	; 0x800791 <xNextTaskUnblockTime>
     b8a:	df 91       	pop	r29
     b8c:	cf 91       	pop	r28
     b8e:	1f 91       	pop	r17
     b90:	0f 91       	pop	r16
     b92:	ff 90       	pop	r15
     b94:	08 95       	ret

00000b96 <xTaskCreate>:
     b96:	4f 92       	push	r4
     b98:	5f 92       	push	r5
     b9a:	6f 92       	push	r6
     b9c:	7f 92       	push	r7
     b9e:	8f 92       	push	r8
     ba0:	9f 92       	push	r9
     ba2:	af 92       	push	r10
     ba4:	bf 92       	push	r11
     ba6:	cf 92       	push	r12
     ba8:	df 92       	push	r13
     baa:	ef 92       	push	r14
     bac:	ff 92       	push	r15
     bae:	0f 93       	push	r16
     bb0:	cf 93       	push	r28
     bb2:	df 93       	push	r29
     bb4:	4c 01       	movw	r8, r24
     bb6:	6b 01       	movw	r12, r22
     bb8:	5a 01       	movw	r10, r20
     bba:	29 01       	movw	r4, r18
     bbc:	ca 01       	movw	r24, r20
     bbe:	0e 94 e7 00 	call	0x1ce	; 0x1ce <pvPortMalloc>
     bc2:	3c 01       	movw	r6, r24
     bc4:	89 2b       	or	r24, r25
     bc6:	09 f4       	brne	.+2      	; 0xbca <xTaskCreate+0x34>
     bc8:	e2 c0       	rjmp	.+452    	; 0xd8e <xTaskCreate+0x1f8>
     bca:	86 e2       	ldi	r24, 0x26	; 38
     bcc:	90 e0       	ldi	r25, 0x00	; 0
     bce:	0e 94 e7 00 	call	0x1ce	; 0x1ce <pvPortMalloc>
     bd2:	ec 01       	movw	r28, r24
     bd4:	89 2b       	or	r24, r25
     bd6:	71 f0       	breq	.+28     	; 0xbf4 <xTaskCreate+0x5e>
     bd8:	78 8e       	std	Y+24, r7	; 0x18
     bda:	6f 8a       	std	Y+23, r6	; 0x17
     bdc:	81 e0       	ldi	r24, 0x01	; 1
     bde:	a8 1a       	sub	r10, r24
     be0:	b1 08       	sbc	r11, r1
     be2:	a6 0c       	add	r10, r6
     be4:	b7 1c       	adc	r11, r7
     be6:	d6 01       	movw	r26, r12
     be8:	8c 91       	ld	r24, X
     bea:	89 8f       	std	Y+25, r24	; 0x19
     bec:	8c 91       	ld	r24, X
     bee:	81 11       	cpse	r24, r1
     bf0:	05 c0       	rjmp	.+10     	; 0xbfc <xTaskCreate+0x66>
     bf2:	18 c0       	rjmp	.+48     	; 0xc24 <xTaskCreate+0x8e>
     bf4:	c3 01       	movw	r24, r6
     bf6:	0e 94 1c 01 	call	0x238	; 0x238 <vPortFree>
     bfa:	c9 c0       	rjmp	.+402    	; 0xd8e <xTaskCreate+0x1f8>
     bfc:	ae 01       	movw	r20, r28
     bfe:	46 5e       	subi	r20, 0xE6	; 230
     c00:	5f 4f       	sbci	r21, 0xFF	; 255
     c02:	f6 01       	movw	r30, r12
     c04:	31 96       	adiw	r30, 0x01	; 1
     c06:	b8 e0       	ldi	r27, 0x08	; 8
     c08:	cb 0e       	add	r12, r27
     c0a:	d1 1c       	adc	r13, r1
     c0c:	cf 01       	movw	r24, r30
     c0e:	21 91       	ld	r18, Z+
     c10:	da 01       	movw	r26, r20
     c12:	2d 93       	st	X+, r18
     c14:	ad 01       	movw	r20, r26
     c16:	dc 01       	movw	r26, r24
     c18:	8c 91       	ld	r24, X
     c1a:	88 23       	and	r24, r24
     c1c:	19 f0       	breq	.+6      	; 0xc24 <xTaskCreate+0x8e>
     c1e:	ec 15       	cp	r30, r12
     c20:	fd 05       	cpc	r31, r13
     c22:	a1 f7       	brne	.-24     	; 0xc0c <xTaskCreate+0x76>
     c24:	18 a2       	std	Y+32, r1	; 0x20
     c26:	04 30       	cpi	r16, 0x04	; 4
     c28:	08 f0       	brcs	.+2      	; 0xc2c <xTaskCreate+0x96>
     c2a:	03 e0       	ldi	r16, 0x03	; 3
     c2c:	0e 8b       	std	Y+22, r16	; 0x16
     c2e:	6e 01       	movw	r12, r28
     c30:	b2 e0       	ldi	r27, 0x02	; 2
     c32:	cb 0e       	add	r12, r27
     c34:	d1 1c       	adc	r13, r1
     c36:	c6 01       	movw	r24, r12
     c38:	0e 94 6b 00 	call	0xd6	; 0xd6 <vListInitialiseItem>
     c3c:	ce 01       	movw	r24, r28
     c3e:	0c 96       	adiw	r24, 0x0c	; 12
     c40:	0e 94 6b 00 	call	0xd6	; 0xd6 <vListInitialiseItem>
     c44:	d9 87       	std	Y+9, r29	; 0x09
     c46:	c8 87       	std	Y+8, r28	; 0x08
     c48:	84 e0       	ldi	r24, 0x04	; 4
     c4a:	90 e0       	ldi	r25, 0x00	; 0
     c4c:	80 1b       	sub	r24, r16
     c4e:	91 09       	sbc	r25, r1
     c50:	9d 87       	std	Y+13, r25	; 0x0d
     c52:	8c 87       	std	Y+12, r24	; 0x0c
     c54:	db 8b       	std	Y+19, r29	; 0x13
     c56:	ca 8b       	std	Y+18, r28	; 0x12
     c58:	19 a2       	std	Y+33, r1	; 0x21
     c5a:	1a a2       	std	Y+34, r1	; 0x22
     c5c:	1b a2       	std	Y+35, r1	; 0x23
     c5e:	1c a2       	std	Y+36, r1	; 0x24
     c60:	1d a2       	std	Y+37, r1	; 0x25
     c62:	a2 01       	movw	r20, r4
     c64:	b4 01       	movw	r22, r8
     c66:	c5 01       	movw	r24, r10
     c68:	0e 94 1d 01 	call	0x23a	; 0x23a <pxPortInitialiseStack>
     c6c:	99 83       	std	Y+1, r25	; 0x01
     c6e:	88 83       	st	Y, r24
     c70:	e1 14       	cp	r14, r1
     c72:	f1 04       	cpc	r15, r1
     c74:	19 f0       	breq	.+6      	; 0xc7c <xTaskCreate+0xe6>
     c76:	f7 01       	movw	r30, r14
     c78:	d1 83       	std	Z+1, r29	; 0x01
     c7a:	c0 83       	st	Z, r28
     c7c:	0f b6       	in	r0, 0x3f	; 63
     c7e:	f8 94       	cli
     c80:	0f 92       	push	r0
     c82:	80 91 9b 07 	lds	r24, 0x079B	; 0x80079b <uxCurrentNumberOfTasks>
     c86:	8f 5f       	subi	r24, 0xFF	; 255
     c88:	80 93 9b 07 	sts	0x079B, r24	; 0x80079b <uxCurrentNumberOfTasks>
     c8c:	80 91 f2 07 	lds	r24, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     c90:	90 91 f3 07 	lds	r25, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     c94:	89 2b       	or	r24, r25
     c96:	d1 f5       	brne	.+116    	; 0xd0c <xTaskCreate+0x176>
     c98:	d0 93 f3 07 	sts	0x07F3, r29	; 0x8007f3 <pxCurrentTCB+0x1>
     c9c:	c0 93 f2 07 	sts	0x07F2, r28	; 0x8007f2 <pxCurrentTCB>
     ca0:	80 91 9b 07 	lds	r24, 0x079B	; 0x80079b <uxCurrentNumberOfTasks>
     ca4:	81 30       	cpi	r24, 0x01	; 1
     ca6:	09 f0       	breq	.+2      	; 0xcaa <xTaskCreate+0x114>
     ca8:	41 c0       	rjmp	.+130    	; 0xd2c <xTaskCreate+0x196>
     caa:	8e ec       	ldi	r24, 0xCE	; 206
     cac:	97 e0       	ldi	r25, 0x07	; 7
     cae:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     cb2:	87 ed       	ldi	r24, 0xD7	; 215
     cb4:	97 e0       	ldi	r25, 0x07	; 7
     cb6:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     cba:	80 ee       	ldi	r24, 0xE0	; 224
     cbc:	97 e0       	ldi	r25, 0x07	; 7
     cbe:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     cc2:	89 ee       	ldi	r24, 0xE9	; 233
     cc4:	97 e0       	ldi	r25, 0x07	; 7
     cc6:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     cca:	85 ec       	ldi	r24, 0xC5	; 197
     ccc:	97 e0       	ldi	r25, 0x07	; 7
     cce:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     cd2:	8c eb       	ldi	r24, 0xBC	; 188
     cd4:	97 e0       	ldi	r25, 0x07	; 7
     cd6:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     cda:	8f ea       	ldi	r24, 0xAF	; 175
     cdc:	97 e0       	ldi	r25, 0x07	; 7
     cde:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     ce2:	86 ea       	ldi	r24, 0xA6	; 166
     ce4:	97 e0       	ldi	r25, 0x07	; 7
     ce6:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     cea:	8c e9       	ldi	r24, 0x9C	; 156
     cec:	97 e0       	ldi	r25, 0x07	; 7
     cee:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     cf2:	85 ec       	ldi	r24, 0xC5	; 197
     cf4:	97 e0       	ldi	r25, 0x07	; 7
     cf6:	90 93 bb 07 	sts	0x07BB, r25	; 0x8007bb <pxDelayedTaskList+0x1>
     cfa:	80 93 ba 07 	sts	0x07BA, r24	; 0x8007ba <pxDelayedTaskList>
     cfe:	8c eb       	ldi	r24, 0xBC	; 188
     d00:	97 e0       	ldi	r25, 0x07	; 7
     d02:	90 93 b9 07 	sts	0x07B9, r25	; 0x8007b9 <pxOverflowDelayedTaskList+0x1>
     d06:	80 93 b8 07 	sts	0x07B8, r24	; 0x8007b8 <pxOverflowDelayedTaskList>
     d0a:	10 c0       	rjmp	.+32     	; 0xd2c <xTaskCreate+0x196>
     d0c:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <xSchedulerRunning>
     d10:	81 11       	cpse	r24, r1
     d12:	0c c0       	rjmp	.+24     	; 0xd2c <xTaskCreate+0x196>
     d14:	e0 91 f2 07 	lds	r30, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     d18:	f0 91 f3 07 	lds	r31, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     d1c:	96 89       	ldd	r25, Z+22	; 0x16
     d1e:	8e 89       	ldd	r24, Y+22	; 0x16
     d20:	89 17       	cp	r24, r25
     d22:	20 f0       	brcs	.+8      	; 0xd2c <xTaskCreate+0x196>
     d24:	d0 93 f3 07 	sts	0x07F3, r29	; 0x8007f3 <pxCurrentTCB+0x1>
     d28:	c0 93 f2 07 	sts	0x07F2, r28	; 0x8007f2 <pxCurrentTCB>
     d2c:	80 91 93 07 	lds	r24, 0x0793	; 0x800793 <uxTaskNumber>
     d30:	8f 5f       	subi	r24, 0xFF	; 255
     d32:	80 93 93 07 	sts	0x0793, r24	; 0x800793 <uxTaskNumber>
     d36:	8e 89       	ldd	r24, Y+22	; 0x16
     d38:	90 91 98 07 	lds	r25, 0x0798	; 0x800798 <uxTopReadyPriority>
     d3c:	98 17       	cp	r25, r24
     d3e:	10 f4       	brcc	.+4      	; 0xd44 <xTaskCreate+0x1ae>
     d40:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <uxTopReadyPriority>
     d44:	90 e0       	ldi	r25, 0x00	; 0
     d46:	9c 01       	movw	r18, r24
     d48:	22 0f       	add	r18, r18
     d4a:	33 1f       	adc	r19, r19
     d4c:	22 0f       	add	r18, r18
     d4e:	33 1f       	adc	r19, r19
     d50:	22 0f       	add	r18, r18
     d52:	33 1f       	adc	r19, r19
     d54:	82 0f       	add	r24, r18
     d56:	93 1f       	adc	r25, r19
     d58:	b6 01       	movw	r22, r12
     d5a:	82 53       	subi	r24, 0x32	; 50
     d5c:	98 4f       	sbci	r25, 0xF8	; 248
     d5e:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
     d62:	0f 90       	pop	r0
     d64:	0f be       	out	0x3f, r0	; 63
     d66:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <xSchedulerRunning>
     d6a:	88 23       	and	r24, r24
     d6c:	61 f0       	breq	.+24     	; 0xd86 <xTaskCreate+0x1f0>
     d6e:	e0 91 f2 07 	lds	r30, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     d72:	f0 91 f3 07 	lds	r31, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     d76:	96 89       	ldd	r25, Z+22	; 0x16
     d78:	8e 89       	ldd	r24, Y+22	; 0x16
     d7a:	98 17       	cp	r25, r24
     d7c:	30 f4       	brcc	.+12     	; 0xd8a <xTaskCreate+0x1f4>
     d7e:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     d82:	81 e0       	ldi	r24, 0x01	; 1
     d84:	05 c0       	rjmp	.+10     	; 0xd90 <xTaskCreate+0x1fa>
     d86:	81 e0       	ldi	r24, 0x01	; 1
     d88:	03 c0       	rjmp	.+6      	; 0xd90 <xTaskCreate+0x1fa>
     d8a:	81 e0       	ldi	r24, 0x01	; 1
     d8c:	01 c0       	rjmp	.+2      	; 0xd90 <xTaskCreate+0x1fa>
     d8e:	8f ef       	ldi	r24, 0xFF	; 255
     d90:	df 91       	pop	r29
     d92:	cf 91       	pop	r28
     d94:	0f 91       	pop	r16
     d96:	ff 90       	pop	r15
     d98:	ef 90       	pop	r14
     d9a:	df 90       	pop	r13
     d9c:	cf 90       	pop	r12
     d9e:	bf 90       	pop	r11
     da0:	af 90       	pop	r10
     da2:	9f 90       	pop	r9
     da4:	8f 90       	pop	r8
     da6:	7f 90       	pop	r7
     da8:	6f 90       	pop	r6
     daa:	5f 90       	pop	r5
     dac:	4f 90       	pop	r4
     dae:	08 95       	ret

00000db0 <vTaskResume>:
     db0:	0f 93       	push	r16
     db2:	1f 93       	push	r17
     db4:	cf 93       	push	r28
     db6:	df 93       	push	r29
     db8:	00 97       	sbiw	r24, 0x00	; 0
     dba:	09 f4       	brne	.+2      	; 0xdbe <vTaskResume+0xe>
     dbc:	43 c0       	rjmp	.+134    	; 0xe44 <vTaskResume+0x94>
     dbe:	20 91 f2 07 	lds	r18, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     dc2:	30 91 f3 07 	lds	r19, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     dc6:	82 17       	cp	r24, r18
     dc8:	93 07       	cpc	r25, r19
     dca:	09 f4       	brne	.+2      	; 0xdce <vTaskResume+0x1e>
     dcc:	3b c0       	rjmp	.+118    	; 0xe44 <vTaskResume+0x94>
     dce:	0f b6       	in	r0, 0x3f	; 63
     dd0:	f8 94       	cli
     dd2:	0f 92       	push	r0
     dd4:	fc 01       	movw	r30, r24
     dd6:	22 85       	ldd	r18, Z+10	; 0x0a
     dd8:	33 85       	ldd	r19, Z+11	; 0x0b
     dda:	2c 59       	subi	r18, 0x9C	; 156
     ddc:	37 40       	sbci	r19, 0x07	; 7
     dde:	81 f5       	brne	.+96     	; 0xe40 <vTaskResume+0x90>
     de0:	fc 01       	movw	r30, r24
     de2:	24 89       	ldd	r18, Z+20	; 0x14
     de4:	35 89       	ldd	r19, Z+21	; 0x15
     de6:	f7 e0       	ldi	r31, 0x07	; 7
     de8:	2f 3a       	cpi	r18, 0xAF	; 175
     dea:	3f 07       	cpc	r19, r31
     dec:	49 f1       	breq	.+82     	; 0xe40 <vTaskResume+0x90>
     dee:	23 2b       	or	r18, r19
     df0:	39 f5       	brne	.+78     	; 0xe40 <vTaskResume+0x90>
     df2:	ec 01       	movw	r28, r24
     df4:	8c 01       	movw	r16, r24
     df6:	0e 5f       	subi	r16, 0xFE	; 254
     df8:	1f 4f       	sbci	r17, 0xFF	; 255
     dfa:	c8 01       	movw	r24, r16
     dfc:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
     e00:	8e 89       	ldd	r24, Y+22	; 0x16
     e02:	90 91 98 07 	lds	r25, 0x0798	; 0x800798 <uxTopReadyPriority>
     e06:	98 17       	cp	r25, r24
     e08:	10 f4       	brcc	.+4      	; 0xe0e <vTaskResume+0x5e>
     e0a:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <uxTopReadyPriority>
     e0e:	90 e0       	ldi	r25, 0x00	; 0
     e10:	9c 01       	movw	r18, r24
     e12:	22 0f       	add	r18, r18
     e14:	33 1f       	adc	r19, r19
     e16:	22 0f       	add	r18, r18
     e18:	33 1f       	adc	r19, r19
     e1a:	22 0f       	add	r18, r18
     e1c:	33 1f       	adc	r19, r19
     e1e:	82 0f       	add	r24, r18
     e20:	93 1f       	adc	r25, r19
     e22:	b8 01       	movw	r22, r16
     e24:	82 53       	subi	r24, 0x32	; 50
     e26:	98 4f       	sbci	r25, 0xF8	; 248
     e28:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
     e2c:	e0 91 f2 07 	lds	r30, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     e30:	f0 91 f3 07 	lds	r31, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     e34:	9e 89       	ldd	r25, Y+22	; 0x16
     e36:	86 89       	ldd	r24, Z+22	; 0x16
     e38:	98 17       	cp	r25, r24
     e3a:	10 f0       	brcs	.+4      	; 0xe40 <vTaskResume+0x90>
     e3c:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     e40:	0f 90       	pop	r0
     e42:	0f be       	out	0x3f, r0	; 63
     e44:	df 91       	pop	r29
     e46:	cf 91       	pop	r28
     e48:	1f 91       	pop	r17
     e4a:	0f 91       	pop	r16
     e4c:	08 95       	ret

00000e4e <vTaskStartScheduler>:
     e4e:	ef 92       	push	r14
     e50:	ff 92       	push	r15
     e52:	0f 93       	push	r16
     e54:	0f 2e       	mov	r0, r31
     e56:	ff e8       	ldi	r31, 0x8F	; 143
     e58:	ef 2e       	mov	r14, r31
     e5a:	f7 e0       	ldi	r31, 0x07	; 7
     e5c:	ff 2e       	mov	r15, r31
     e5e:	f0 2d       	mov	r31, r0
     e60:	00 e0       	ldi	r16, 0x00	; 0
     e62:	20 e0       	ldi	r18, 0x00	; 0
     e64:	30 e0       	ldi	r19, 0x00	; 0
     e66:	45 e5       	ldi	r20, 0x55	; 85
     e68:	50 e0       	ldi	r21, 0x00	; 0
     e6a:	60 e0       	ldi	r22, 0x00	; 0
     e6c:	71 e0       	ldi	r23, 0x01	; 1
     e6e:	83 eb       	ldi	r24, 0xB3	; 179
     e70:	98 e0       	ldi	r25, 0x08	; 8
     e72:	0e 94 cb 05 	call	0xb96	; 0xb96 <xTaskCreate>
     e76:	81 30       	cpi	r24, 0x01	; 1
     e78:	a1 f4       	brne	.+40     	; 0xea2 <vTaskStartScheduler+0x54>
     e7a:	0e 94 cd 0a 	call	0x159a	; 0x159a <xTimerCreateTimerTask>
     e7e:	81 30       	cpi	r24, 0x01	; 1
     e80:	81 f4       	brne	.+32     	; 0xea2 <vTaskStartScheduler+0x54>
     e82:	f8 94       	cli
     e84:	8f ef       	ldi	r24, 0xFF	; 255
     e86:	9f ef       	ldi	r25, 0xFF	; 255
     e88:	90 93 92 07 	sts	0x0792, r25	; 0x800792 <xNextTaskUnblockTime+0x1>
     e8c:	80 93 91 07 	sts	0x0791, r24	; 0x800791 <xNextTaskUnblockTime>
     e90:	81 e0       	ldi	r24, 0x01	; 1
     e92:	80 93 97 07 	sts	0x0797, r24	; 0x800797 <xSchedulerRunning>
     e96:	10 92 9a 07 	sts	0x079A, r1	; 0x80079a <xTickCount+0x1>
     e9a:	10 92 99 07 	sts	0x0799, r1	; 0x800799 <xTickCount>
     e9e:	0e 94 89 01 	call	0x312	; 0x312 <xPortStartScheduler>
     ea2:	0f 91       	pop	r16
     ea4:	ff 90       	pop	r15
     ea6:	ef 90       	pop	r14
     ea8:	08 95       	ret

00000eaa <vTaskSuspendAll>:
     eaa:	80 91 8e 07 	lds	r24, 0x078E	; 0x80078e <uxSchedulerSuspended>
     eae:	8f 5f       	subi	r24, 0xFF	; 255
     eb0:	80 93 8e 07 	sts	0x078E, r24	; 0x80078e <uxSchedulerSuspended>
     eb4:	08 95       	ret

00000eb6 <xTaskGetTickCount>:
     eb6:	0f b6       	in	r0, 0x3f	; 63
     eb8:	f8 94       	cli
     eba:	0f 92       	push	r0
     ebc:	80 91 99 07 	lds	r24, 0x0799	; 0x800799 <xTickCount>
     ec0:	90 91 9a 07 	lds	r25, 0x079A	; 0x80079a <xTickCount+0x1>
     ec4:	0f 90       	pop	r0
     ec6:	0f be       	out	0x3f, r0	; 63
     ec8:	08 95       	ret

00000eca <xTaskIncrementTick>:
     eca:	cf 92       	push	r12
     ecc:	df 92       	push	r13
     ece:	ef 92       	push	r14
     ed0:	ff 92       	push	r15
     ed2:	0f 93       	push	r16
     ed4:	1f 93       	push	r17
     ed6:	cf 93       	push	r28
     ed8:	df 93       	push	r29
     eda:	80 91 8e 07 	lds	r24, 0x078E	; 0x80078e <uxSchedulerSuspended>
     ede:	81 11       	cpse	r24, r1
     ee0:	99 c0       	rjmp	.+306    	; 0x1014 <xTaskIncrementTick+0x14a>
     ee2:	e0 90 99 07 	lds	r14, 0x0799	; 0x800799 <xTickCount>
     ee6:	f0 90 9a 07 	lds	r15, 0x079A	; 0x80079a <xTickCount+0x1>
     eea:	8f ef       	ldi	r24, 0xFF	; 255
     eec:	e8 1a       	sub	r14, r24
     eee:	f8 0a       	sbc	r15, r24
     ef0:	f0 92 9a 07 	sts	0x079A, r15	; 0x80079a <xTickCount+0x1>
     ef4:	e0 92 99 07 	sts	0x0799, r14	; 0x800799 <xTickCount>
     ef8:	e1 14       	cp	r14, r1
     efa:	f1 04       	cpc	r15, r1
     efc:	b9 f4       	brne	.+46     	; 0xf2c <xTaskIncrementTick+0x62>
     efe:	80 91 ba 07 	lds	r24, 0x07BA	; 0x8007ba <pxDelayedTaskList>
     f02:	90 91 bb 07 	lds	r25, 0x07BB	; 0x8007bb <pxDelayedTaskList+0x1>
     f06:	20 91 b8 07 	lds	r18, 0x07B8	; 0x8007b8 <pxOverflowDelayedTaskList>
     f0a:	30 91 b9 07 	lds	r19, 0x07B9	; 0x8007b9 <pxOverflowDelayedTaskList+0x1>
     f0e:	30 93 bb 07 	sts	0x07BB, r19	; 0x8007bb <pxDelayedTaskList+0x1>
     f12:	20 93 ba 07 	sts	0x07BA, r18	; 0x8007ba <pxDelayedTaskList>
     f16:	90 93 b9 07 	sts	0x07B9, r25	; 0x8007b9 <pxOverflowDelayedTaskList+0x1>
     f1a:	80 93 b8 07 	sts	0x07B8, r24	; 0x8007b8 <pxOverflowDelayedTaskList>
     f1e:	80 91 94 07 	lds	r24, 0x0794	; 0x800794 <xNumOfOverflows>
     f22:	8f 5f       	subi	r24, 0xFF	; 255
     f24:	80 93 94 07 	sts	0x0794, r24	; 0x800794 <xNumOfOverflows>
     f28:	0e 94 54 05 	call	0xaa8	; 0xaa8 <prvResetNextTaskUnblockTime>
     f2c:	80 91 91 07 	lds	r24, 0x0791	; 0x800791 <xNextTaskUnblockTime>
     f30:	90 91 92 07 	lds	r25, 0x0792	; 0x800792 <xNextTaskUnblockTime+0x1>
     f34:	e8 16       	cp	r14, r24
     f36:	f9 06       	cpc	r15, r25
     f38:	10 f4       	brcc	.+4      	; 0xf3e <xTaskIncrementTick+0x74>
     f3a:	d1 2c       	mov	r13, r1
     f3c:	53 c0       	rjmp	.+166    	; 0xfe4 <xTaskIncrementTick+0x11a>
     f3e:	d1 2c       	mov	r13, r1
     f40:	cc 24       	eor	r12, r12
     f42:	c3 94       	inc	r12
     f44:	e0 91 ba 07 	lds	r30, 0x07BA	; 0x8007ba <pxDelayedTaskList>
     f48:	f0 91 bb 07 	lds	r31, 0x07BB	; 0x8007bb <pxDelayedTaskList+0x1>
     f4c:	80 81       	ld	r24, Z
     f4e:	81 11       	cpse	r24, r1
     f50:	07 c0       	rjmp	.+14     	; 0xf60 <xTaskIncrementTick+0x96>
     f52:	8f ef       	ldi	r24, 0xFF	; 255
     f54:	9f ef       	ldi	r25, 0xFF	; 255
     f56:	90 93 92 07 	sts	0x0792, r25	; 0x800792 <xNextTaskUnblockTime+0x1>
     f5a:	80 93 91 07 	sts	0x0791, r24	; 0x800791 <xNextTaskUnblockTime>
     f5e:	42 c0       	rjmp	.+132    	; 0xfe4 <xTaskIncrementTick+0x11a>
     f60:	e0 91 ba 07 	lds	r30, 0x07BA	; 0x8007ba <pxDelayedTaskList>
     f64:	f0 91 bb 07 	lds	r31, 0x07BB	; 0x8007bb <pxDelayedTaskList+0x1>
     f68:	05 80       	ldd	r0, Z+5	; 0x05
     f6a:	f6 81       	ldd	r31, Z+6	; 0x06
     f6c:	e0 2d       	mov	r30, r0
     f6e:	c6 81       	ldd	r28, Z+6	; 0x06
     f70:	d7 81       	ldd	r29, Z+7	; 0x07
     f72:	8a 81       	ldd	r24, Y+2	; 0x02
     f74:	9b 81       	ldd	r25, Y+3	; 0x03
     f76:	e8 16       	cp	r14, r24
     f78:	f9 06       	cpc	r15, r25
     f7a:	28 f4       	brcc	.+10     	; 0xf86 <xTaskIncrementTick+0xbc>
     f7c:	90 93 92 07 	sts	0x0792, r25	; 0x800792 <xNextTaskUnblockTime+0x1>
     f80:	80 93 91 07 	sts	0x0791, r24	; 0x800791 <xNextTaskUnblockTime>
     f84:	2f c0       	rjmp	.+94     	; 0xfe4 <xTaskIncrementTick+0x11a>
     f86:	8e 01       	movw	r16, r28
     f88:	0e 5f       	subi	r16, 0xFE	; 254
     f8a:	1f 4f       	sbci	r17, 0xFF	; 255
     f8c:	c8 01       	movw	r24, r16
     f8e:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
     f92:	8c 89       	ldd	r24, Y+20	; 0x14
     f94:	9d 89       	ldd	r25, Y+21	; 0x15
     f96:	89 2b       	or	r24, r25
     f98:	21 f0       	breq	.+8      	; 0xfa2 <xTaskIncrementTick+0xd8>
     f9a:	ce 01       	movw	r24, r28
     f9c:	0c 96       	adiw	r24, 0x0c	; 12
     f9e:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
     fa2:	8e 89       	ldd	r24, Y+22	; 0x16
     fa4:	90 91 98 07 	lds	r25, 0x0798	; 0x800798 <uxTopReadyPriority>
     fa8:	98 17       	cp	r25, r24
     faa:	10 f4       	brcc	.+4      	; 0xfb0 <xTaskIncrementTick+0xe6>
     fac:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <uxTopReadyPriority>
     fb0:	90 e0       	ldi	r25, 0x00	; 0
     fb2:	9c 01       	movw	r18, r24
     fb4:	22 0f       	add	r18, r18
     fb6:	33 1f       	adc	r19, r19
     fb8:	22 0f       	add	r18, r18
     fba:	33 1f       	adc	r19, r19
     fbc:	22 0f       	add	r18, r18
     fbe:	33 1f       	adc	r19, r19
     fc0:	82 0f       	add	r24, r18
     fc2:	93 1f       	adc	r25, r19
     fc4:	b8 01       	movw	r22, r16
     fc6:	82 53       	subi	r24, 0x32	; 50
     fc8:	98 4f       	sbci	r25, 0xF8	; 248
     fca:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
     fce:	e0 91 f2 07 	lds	r30, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     fd2:	f0 91 f3 07 	lds	r31, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     fd6:	9e 89       	ldd	r25, Y+22	; 0x16
     fd8:	86 89       	ldd	r24, Z+22	; 0x16
     fda:	98 17       	cp	r25, r24
     fdc:	08 f4       	brcc	.+2      	; 0xfe0 <xTaskIncrementTick+0x116>
     fde:	b2 cf       	rjmp	.-156    	; 0xf44 <xTaskIncrementTick+0x7a>
     fe0:	dc 2c       	mov	r13, r12
     fe2:	b0 cf       	rjmp	.-160    	; 0xf44 <xTaskIncrementTick+0x7a>
     fe4:	e0 91 f2 07 	lds	r30, 0x07F2	; 0x8007f2 <pxCurrentTCB>
     fe8:	f0 91 f3 07 	lds	r31, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
     fec:	86 89       	ldd	r24, Z+22	; 0x16
     fee:	90 e0       	ldi	r25, 0x00	; 0
     ff0:	fc 01       	movw	r30, r24
     ff2:	ee 0f       	add	r30, r30
     ff4:	ff 1f       	adc	r31, r31
     ff6:	ee 0f       	add	r30, r30
     ff8:	ff 1f       	adc	r31, r31
     ffa:	ee 0f       	add	r30, r30
     ffc:	ff 1f       	adc	r31, r31
     ffe:	8e 0f       	add	r24, r30
    1000:	9f 1f       	adc	r25, r31
    1002:	fc 01       	movw	r30, r24
    1004:	e2 53       	subi	r30, 0x32	; 50
    1006:	f8 4f       	sbci	r31, 0xF8	; 248
    1008:	80 81       	ld	r24, Z
    100a:	82 30       	cpi	r24, 0x02	; 2
    100c:	48 f0       	brcs	.+18     	; 0x1020 <xTaskIncrementTick+0x156>
    100e:	dd 24       	eor	r13, r13
    1010:	d3 94       	inc	r13
    1012:	06 c0       	rjmp	.+12     	; 0x1020 <xTaskIncrementTick+0x156>
    1014:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <uxPendedTicks>
    1018:	8f 5f       	subi	r24, 0xFF	; 255
    101a:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <uxPendedTicks>
    101e:	d1 2c       	mov	r13, r1
    1020:	80 91 95 07 	lds	r24, 0x0795	; 0x800795 <xYieldPending>
    1024:	88 23       	and	r24, r24
    1026:	11 f0       	breq	.+4      	; 0x102c <xTaskIncrementTick+0x162>
    1028:	dd 24       	eor	r13, r13
    102a:	d3 94       	inc	r13
    102c:	8d 2d       	mov	r24, r13
    102e:	df 91       	pop	r29
    1030:	cf 91       	pop	r28
    1032:	1f 91       	pop	r17
    1034:	0f 91       	pop	r16
    1036:	ff 90       	pop	r15
    1038:	ef 90       	pop	r14
    103a:	df 90       	pop	r13
    103c:	cf 90       	pop	r12
    103e:	08 95       	ret

00001040 <xTaskResumeAll>:
    1040:	df 92       	push	r13
    1042:	ef 92       	push	r14
    1044:	ff 92       	push	r15
    1046:	0f 93       	push	r16
    1048:	1f 93       	push	r17
    104a:	cf 93       	push	r28
    104c:	df 93       	push	r29
    104e:	0f b6       	in	r0, 0x3f	; 63
    1050:	f8 94       	cli
    1052:	0f 92       	push	r0
    1054:	80 91 8e 07 	lds	r24, 0x078E	; 0x80078e <uxSchedulerSuspended>
    1058:	81 50       	subi	r24, 0x01	; 1
    105a:	80 93 8e 07 	sts	0x078E, r24	; 0x80078e <uxSchedulerSuspended>
    105e:	80 91 8e 07 	lds	r24, 0x078E	; 0x80078e <uxSchedulerSuspended>
    1062:	81 11       	cpse	r24, r1
    1064:	5f c0       	rjmp	.+190    	; 0x1124 <xTaskResumeAll+0xe4>
    1066:	80 91 9b 07 	lds	r24, 0x079B	; 0x80079b <uxCurrentNumberOfTasks>
    106a:	81 11       	cpse	r24, r1
    106c:	33 c0       	rjmp	.+102    	; 0x10d4 <xTaskResumeAll+0x94>
    106e:	5d c0       	rjmp	.+186    	; 0x112a <xTaskResumeAll+0xea>
    1070:	d7 01       	movw	r26, r14
    1072:	15 96       	adiw	r26, 0x05	; 5
    1074:	ed 91       	ld	r30, X+
    1076:	fc 91       	ld	r31, X
    1078:	16 97       	sbiw	r26, 0x06	; 6
    107a:	c6 81       	ldd	r28, Z+6	; 0x06
    107c:	d7 81       	ldd	r29, Z+7	; 0x07
    107e:	ce 01       	movw	r24, r28
    1080:	0c 96       	adiw	r24, 0x0c	; 12
    1082:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
    1086:	8e 01       	movw	r16, r28
    1088:	0e 5f       	subi	r16, 0xFE	; 254
    108a:	1f 4f       	sbci	r17, 0xFF	; 255
    108c:	c8 01       	movw	r24, r16
    108e:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
    1092:	8e 89       	ldd	r24, Y+22	; 0x16
    1094:	90 91 98 07 	lds	r25, 0x0798	; 0x800798 <uxTopReadyPriority>
    1098:	98 17       	cp	r25, r24
    109a:	10 f4       	brcc	.+4      	; 0x10a0 <xTaskResumeAll+0x60>
    109c:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <uxTopReadyPriority>
    10a0:	90 e0       	ldi	r25, 0x00	; 0
    10a2:	9c 01       	movw	r18, r24
    10a4:	22 0f       	add	r18, r18
    10a6:	33 1f       	adc	r19, r19
    10a8:	22 0f       	add	r18, r18
    10aa:	33 1f       	adc	r19, r19
    10ac:	22 0f       	add	r18, r18
    10ae:	33 1f       	adc	r19, r19
    10b0:	82 0f       	add	r24, r18
    10b2:	93 1f       	adc	r25, r19
    10b4:	b8 01       	movw	r22, r16
    10b6:	82 53       	subi	r24, 0x32	; 50
    10b8:	98 4f       	sbci	r25, 0xF8	; 248
    10ba:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
    10be:	e0 91 f2 07 	lds	r30, 0x07F2	; 0x8007f2 <pxCurrentTCB>
    10c2:	f0 91 f3 07 	lds	r31, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
    10c6:	9e 89       	ldd	r25, Y+22	; 0x16
    10c8:	86 89       	ldd	r24, Z+22	; 0x16
    10ca:	98 17       	cp	r25, r24
    10cc:	68 f0       	brcs	.+26     	; 0x10e8 <xTaskResumeAll+0xa8>
    10ce:	d0 92 95 07 	sts	0x0795, r13	; 0x800795 <xYieldPending>
    10d2:	0a c0       	rjmp	.+20     	; 0x10e8 <xTaskResumeAll+0xa8>
    10d4:	c0 e0       	ldi	r28, 0x00	; 0
    10d6:	d0 e0       	ldi	r29, 0x00	; 0
    10d8:	0f 2e       	mov	r0, r31
    10da:	ff ea       	ldi	r31, 0xAF	; 175
    10dc:	ef 2e       	mov	r14, r31
    10de:	f7 e0       	ldi	r31, 0x07	; 7
    10e0:	ff 2e       	mov	r15, r31
    10e2:	f0 2d       	mov	r31, r0
    10e4:	dd 24       	eor	r13, r13
    10e6:	d3 94       	inc	r13
    10e8:	f7 01       	movw	r30, r14
    10ea:	80 81       	ld	r24, Z
    10ec:	81 11       	cpse	r24, r1
    10ee:	c0 cf       	rjmp	.-128    	; 0x1070 <xTaskResumeAll+0x30>
    10f0:	cd 2b       	or	r28, r29
    10f2:	11 f0       	breq	.+4      	; 0x10f8 <xTaskResumeAll+0xb8>
    10f4:	0e 94 54 05 	call	0xaa8	; 0xaa8 <prvResetNextTaskUnblockTime>
    10f8:	c0 91 96 07 	lds	r28, 0x0796	; 0x800796 <uxPendedTicks>
    10fc:	cc 23       	and	r28, r28
    10fe:	51 f0       	breq	.+20     	; 0x1114 <xTaskResumeAll+0xd4>
    1100:	d1 e0       	ldi	r29, 0x01	; 1
    1102:	0e 94 65 07 	call	0xeca	; 0xeca <xTaskIncrementTick>
    1106:	81 11       	cpse	r24, r1
    1108:	d0 93 95 07 	sts	0x0795, r29	; 0x800795 <xYieldPending>
    110c:	c1 50       	subi	r28, 0x01	; 1
    110e:	c9 f7       	brne	.-14     	; 0x1102 <xTaskResumeAll+0xc2>
    1110:	10 92 96 07 	sts	0x0796, r1	; 0x800796 <uxPendedTicks>
    1114:	80 91 95 07 	lds	r24, 0x0795	; 0x800795 <xYieldPending>
    1118:	88 23       	and	r24, r24
    111a:	31 f0       	breq	.+12     	; 0x1128 <xTaskResumeAll+0xe8>
    111c:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
    1120:	81 e0       	ldi	r24, 0x01	; 1
    1122:	03 c0       	rjmp	.+6      	; 0x112a <xTaskResumeAll+0xea>
    1124:	80 e0       	ldi	r24, 0x00	; 0
    1126:	01 c0       	rjmp	.+2      	; 0x112a <xTaskResumeAll+0xea>
    1128:	80 e0       	ldi	r24, 0x00	; 0
    112a:	0f 90       	pop	r0
    112c:	0f be       	out	0x3f, r0	; 63
    112e:	df 91       	pop	r29
    1130:	cf 91       	pop	r28
    1132:	1f 91       	pop	r17
    1134:	0f 91       	pop	r16
    1136:	ff 90       	pop	r15
    1138:	ef 90       	pop	r14
    113a:	df 90       	pop	r13
    113c:	08 95       	ret

0000113e <vTaskDelay>:
    113e:	cf 93       	push	r28
    1140:	df 93       	push	r29
    1142:	ec 01       	movw	r28, r24
    1144:	89 2b       	or	r24, r25
    1146:	51 f0       	breq	.+20     	; 0x115c <vTaskDelay+0x1e>
    1148:	0e 94 55 07 	call	0xeaa	; 0xeaa <vTaskSuspendAll>
    114c:	60 e0       	ldi	r22, 0x00	; 0
    114e:	ce 01       	movw	r24, r28
    1150:	0e 94 73 05 	call	0xae6	; 0xae6 <prvAddCurrentTaskToDelayedList>
    1154:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
    1158:	81 11       	cpse	r24, r1
    115a:	02 c0       	rjmp	.+4      	; 0x1160 <vTaskDelay+0x22>
    115c:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
    1160:	df 91       	pop	r29
    1162:	cf 91       	pop	r28
    1164:	08 95       	ret

00001166 <prvIdleTask>:
    1166:	06 ea       	ldi	r16, 0xA6	; 166
    1168:	17 e0       	ldi	r17, 0x07	; 7
    116a:	0f 2e       	mov	r0, r31
    116c:	fe ec       	ldi	r31, 0xCE	; 206
    116e:	ef 2e       	mov	r14, r31
    1170:	f7 e0       	ldi	r31, 0x07	; 7
    1172:	ff 2e       	mov	r15, r31
    1174:	f0 2d       	mov	r31, r0
    1176:	29 c0       	rjmp	.+82     	; 0x11ca <prvIdleTask+0x64>
    1178:	0e 94 55 07 	call	0xeaa	; 0xeaa <vTaskSuspendAll>
    117c:	d8 01       	movw	r26, r16
    117e:	cc 91       	ld	r28, X
    1180:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
    1184:	cc 23       	and	r28, r28
    1186:	09 f1       	breq	.+66     	; 0x11ca <prvIdleTask+0x64>
    1188:	0f b6       	in	r0, 0x3f	; 63
    118a:	f8 94       	cli
    118c:	0f 92       	push	r0
    118e:	d8 01       	movw	r26, r16
    1190:	15 96       	adiw	r26, 0x05	; 5
    1192:	ed 91       	ld	r30, X+
    1194:	fc 91       	ld	r31, X
    1196:	16 97       	sbiw	r26, 0x06	; 6
    1198:	c6 81       	ldd	r28, Z+6	; 0x06
    119a:	d7 81       	ldd	r29, Z+7	; 0x07
    119c:	ce 01       	movw	r24, r28
    119e:	02 96       	adiw	r24, 0x02	; 2
    11a0:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
    11a4:	80 91 9b 07 	lds	r24, 0x079B	; 0x80079b <uxCurrentNumberOfTasks>
    11a8:	81 50       	subi	r24, 0x01	; 1
    11aa:	80 93 9b 07 	sts	0x079B, r24	; 0x80079b <uxCurrentNumberOfTasks>
    11ae:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <uxDeletedTasksWaitingCleanUp>
    11b2:	81 50       	subi	r24, 0x01	; 1
    11b4:	80 93 a5 07 	sts	0x07A5, r24	; 0x8007a5 <uxDeletedTasksWaitingCleanUp>
    11b8:	0f 90       	pop	r0
    11ba:	0f be       	out	0x3f, r0	; 63
    11bc:	8f 89       	ldd	r24, Y+23	; 0x17
    11be:	98 8d       	ldd	r25, Y+24	; 0x18
    11c0:	0e 94 1c 01 	call	0x238	; 0x238 <vPortFree>
    11c4:	ce 01       	movw	r24, r28
    11c6:	0e 94 1c 01 	call	0x238	; 0x238 <vPortFree>
    11ca:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <uxDeletedTasksWaitingCleanUp>
    11ce:	81 11       	cpse	r24, r1
    11d0:	d3 cf       	rjmp	.-90     	; 0x1178 <prvIdleTask+0x12>
    11d2:	f7 01       	movw	r30, r14
    11d4:	80 81       	ld	r24, Z
    11d6:	82 30       	cpi	r24, 0x02	; 2
    11d8:	10 f0       	brcs	.+4      	; 0x11de <prvIdleTask+0x78>
    11da:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
    11de:	0e 94 a1 13 	call	0x2742	; 0x2742 <vApplicationIdleHook>
    11e2:	f3 cf       	rjmp	.-26     	; 0x11ca <prvIdleTask+0x64>

000011e4 <vTaskSwitchContext>:
    11e4:	80 91 8e 07 	lds	r24, 0x078E	; 0x80078e <uxSchedulerSuspended>
    11e8:	88 23       	and	r24, r24
    11ea:	21 f0       	breq	.+8      	; 0x11f4 <vTaskSwitchContext+0x10>
    11ec:	81 e0       	ldi	r24, 0x01	; 1
    11ee:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <xYieldPending>
    11f2:	08 95       	ret
    11f4:	10 92 95 07 	sts	0x0795, r1	; 0x800795 <xYieldPending>
    11f8:	20 91 98 07 	lds	r18, 0x0798	; 0x800798 <uxTopReadyPriority>
    11fc:	82 2f       	mov	r24, r18
    11fe:	90 e0       	ldi	r25, 0x00	; 0
    1200:	fc 01       	movw	r30, r24
    1202:	ee 0f       	add	r30, r30
    1204:	ff 1f       	adc	r31, r31
    1206:	ee 0f       	add	r30, r30
    1208:	ff 1f       	adc	r31, r31
    120a:	ee 0f       	add	r30, r30
    120c:	ff 1f       	adc	r31, r31
    120e:	e8 0f       	add	r30, r24
    1210:	f9 1f       	adc	r31, r25
    1212:	e2 53       	subi	r30, 0x32	; 50
    1214:	f8 4f       	sbci	r31, 0xF8	; 248
    1216:	30 81       	ld	r19, Z
    1218:	31 11       	cpse	r19, r1
    121a:	11 c0       	rjmp	.+34     	; 0x123e <vTaskSwitchContext+0x5a>
    121c:	21 50       	subi	r18, 0x01	; 1
    121e:	82 2f       	mov	r24, r18
    1220:	90 e0       	ldi	r25, 0x00	; 0
    1222:	fc 01       	movw	r30, r24
    1224:	ee 0f       	add	r30, r30
    1226:	ff 1f       	adc	r31, r31
    1228:	ee 0f       	add	r30, r30
    122a:	ff 1f       	adc	r31, r31
    122c:	ee 0f       	add	r30, r30
    122e:	ff 1f       	adc	r31, r31
    1230:	e8 0f       	add	r30, r24
    1232:	f9 1f       	adc	r31, r25
    1234:	e2 53       	subi	r30, 0x32	; 50
    1236:	f8 4f       	sbci	r31, 0xF8	; 248
    1238:	30 81       	ld	r19, Z
    123a:	33 23       	and	r19, r19
    123c:	79 f3       	breq	.-34     	; 0x121c <vTaskSwitchContext+0x38>
    123e:	ac 01       	movw	r20, r24
    1240:	44 0f       	add	r20, r20
    1242:	55 1f       	adc	r21, r21
    1244:	44 0f       	add	r20, r20
    1246:	55 1f       	adc	r21, r21
    1248:	44 0f       	add	r20, r20
    124a:	55 1f       	adc	r21, r21
    124c:	48 0f       	add	r20, r24
    124e:	59 1f       	adc	r21, r25
    1250:	da 01       	movw	r26, r20
    1252:	a2 53       	subi	r26, 0x32	; 50
    1254:	b8 4f       	sbci	r27, 0xF8	; 248
    1256:	11 96       	adiw	r26, 0x01	; 1
    1258:	ed 91       	ld	r30, X+
    125a:	fc 91       	ld	r31, X
    125c:	12 97       	sbiw	r26, 0x02	; 2
    125e:	02 80       	ldd	r0, Z+2	; 0x02
    1260:	f3 81       	ldd	r31, Z+3	; 0x03
    1262:	e0 2d       	mov	r30, r0
    1264:	12 96       	adiw	r26, 0x02	; 2
    1266:	fc 93       	st	X, r31
    1268:	ee 93       	st	-X, r30
    126a:	11 97       	sbiw	r26, 0x01	; 1
    126c:	4f 52       	subi	r20, 0x2F	; 47
    126e:	58 4f       	sbci	r21, 0xF8	; 248
    1270:	e4 17       	cp	r30, r20
    1272:	f5 07       	cpc	r31, r21
    1274:	29 f4       	brne	.+10     	; 0x1280 <vTaskSwitchContext+0x9c>
    1276:	42 81       	ldd	r20, Z+2	; 0x02
    1278:	53 81       	ldd	r21, Z+3	; 0x03
    127a:	fd 01       	movw	r30, r26
    127c:	52 83       	std	Z+2, r21	; 0x02
    127e:	41 83       	std	Z+1, r20	; 0x01
    1280:	fc 01       	movw	r30, r24
    1282:	ee 0f       	add	r30, r30
    1284:	ff 1f       	adc	r31, r31
    1286:	ee 0f       	add	r30, r30
    1288:	ff 1f       	adc	r31, r31
    128a:	ee 0f       	add	r30, r30
    128c:	ff 1f       	adc	r31, r31
    128e:	8e 0f       	add	r24, r30
    1290:	9f 1f       	adc	r25, r31
    1292:	fc 01       	movw	r30, r24
    1294:	e2 53       	subi	r30, 0x32	; 50
    1296:	f8 4f       	sbci	r31, 0xF8	; 248
    1298:	01 80       	ldd	r0, Z+1	; 0x01
    129a:	f2 81       	ldd	r31, Z+2	; 0x02
    129c:	e0 2d       	mov	r30, r0
    129e:	86 81       	ldd	r24, Z+6	; 0x06
    12a0:	97 81       	ldd	r25, Z+7	; 0x07
    12a2:	90 93 f3 07 	sts	0x07F3, r25	; 0x8007f3 <pxCurrentTCB+0x1>
    12a6:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <pxCurrentTCB>
    12aa:	20 93 98 07 	sts	0x0798, r18	; 0x800798 <uxTopReadyPriority>
    12ae:	08 95       	ret

000012b0 <vTaskSuspend>:
    12b0:	0f 93       	push	r16
    12b2:	1f 93       	push	r17
    12b4:	cf 93       	push	r28
    12b6:	df 93       	push	r29
    12b8:	ec 01       	movw	r28, r24
    12ba:	0f b6       	in	r0, 0x3f	; 63
    12bc:	f8 94       	cli
    12be:	0f 92       	push	r0
    12c0:	89 2b       	or	r24, r25
    12c2:	21 f4       	brne	.+8      	; 0x12cc <vTaskSuspend+0x1c>
    12c4:	c0 91 f2 07 	lds	r28, 0x07F2	; 0x8007f2 <pxCurrentTCB>
    12c8:	d0 91 f3 07 	lds	r29, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
    12cc:	8e 01       	movw	r16, r28
    12ce:	0e 5f       	subi	r16, 0xFE	; 254
    12d0:	1f 4f       	sbci	r17, 0xFF	; 255
    12d2:	c8 01       	movw	r24, r16
    12d4:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
    12d8:	8c 89       	ldd	r24, Y+20	; 0x14
    12da:	9d 89       	ldd	r25, Y+21	; 0x15
    12dc:	89 2b       	or	r24, r25
    12de:	21 f0       	breq	.+8      	; 0x12e8 <vTaskSuspend+0x38>
    12e0:	ce 01       	movw	r24, r28
    12e2:	0c 96       	adiw	r24, 0x0c	; 12
    12e4:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
    12e8:	b8 01       	movw	r22, r16
    12ea:	8c e9       	ldi	r24, 0x9C	; 156
    12ec:	97 e0       	ldi	r25, 0x07	; 7
    12ee:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
    12f2:	0f 90       	pop	r0
    12f4:	0f be       	out	0x3f, r0	; 63
    12f6:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <xSchedulerRunning>
    12fa:	88 23       	and	r24, r24
    12fc:	39 f0       	breq	.+14     	; 0x130c <vTaskSuspend+0x5c>
    12fe:	0f b6       	in	r0, 0x3f	; 63
    1300:	f8 94       	cli
    1302:	0f 92       	push	r0
    1304:	0e 94 54 05 	call	0xaa8	; 0xaa8 <prvResetNextTaskUnblockTime>
    1308:	0f 90       	pop	r0
    130a:	0f be       	out	0x3f, r0	; 63
    130c:	80 91 f2 07 	lds	r24, 0x07F2	; 0x8007f2 <pxCurrentTCB>
    1310:	90 91 f3 07 	lds	r25, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
    1314:	c8 17       	cp	r28, r24
    1316:	d9 07       	cpc	r29, r25
    1318:	a1 f4       	brne	.+40     	; 0x1342 <vTaskSuspend+0x92>
    131a:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <xSchedulerRunning>
    131e:	88 23       	and	r24, r24
    1320:	19 f0       	breq	.+6      	; 0x1328 <vTaskSuspend+0x78>
    1322:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
    1326:	0d c0       	rjmp	.+26     	; 0x1342 <vTaskSuspend+0x92>
    1328:	80 91 9b 07 	lds	r24, 0x079B	; 0x80079b <uxCurrentNumberOfTasks>
    132c:	90 91 9c 07 	lds	r25, 0x079C	; 0x80079c <xSuspendedTaskList>
    1330:	98 13       	cpse	r25, r24
    1332:	05 c0       	rjmp	.+10     	; 0x133e <vTaskSuspend+0x8e>
    1334:	10 92 f3 07 	sts	0x07F3, r1	; 0x8007f3 <pxCurrentTCB+0x1>
    1338:	10 92 f2 07 	sts	0x07F2, r1	; 0x8007f2 <pxCurrentTCB>
    133c:	02 c0       	rjmp	.+4      	; 0x1342 <vTaskSuspend+0x92>
    133e:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <vTaskSwitchContext>
    1342:	df 91       	pop	r29
    1344:	cf 91       	pop	r28
    1346:	1f 91       	pop	r17
    1348:	0f 91       	pop	r16
    134a:	08 95       	ret

0000134c <vTaskPlaceOnEventList>:
    134c:	cf 93       	push	r28
    134e:	df 93       	push	r29
    1350:	eb 01       	movw	r28, r22
    1352:	60 91 f2 07 	lds	r22, 0x07F2	; 0x8007f2 <pxCurrentTCB>
    1356:	70 91 f3 07 	lds	r23, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
    135a:	64 5f       	subi	r22, 0xF4	; 244
    135c:	7f 4f       	sbci	r23, 0xFF	; 255
    135e:	0e 94 90 00 	call	0x120	; 0x120 <vListInsert>
    1362:	61 e0       	ldi	r22, 0x01	; 1
    1364:	ce 01       	movw	r24, r28
    1366:	0e 94 73 05 	call	0xae6	; 0xae6 <prvAddCurrentTaskToDelayedList>
    136a:	df 91       	pop	r29
    136c:	cf 91       	pop	r28
    136e:	08 95       	ret

00001370 <vTaskPlaceOnEventListRestricted>:
    1370:	0f 93       	push	r16
    1372:	1f 93       	push	r17
    1374:	cf 93       	push	r28
    1376:	8b 01       	movw	r16, r22
    1378:	c4 2f       	mov	r28, r20
    137a:	60 91 f2 07 	lds	r22, 0x07F2	; 0x8007f2 <pxCurrentTCB>
    137e:	70 91 f3 07 	lds	r23, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
    1382:	64 5f       	subi	r22, 0xF4	; 244
    1384:	7f 4f       	sbci	r23, 0xFF	; 255
    1386:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
    138a:	cc 23       	and	r28, r28
    138c:	11 f0       	breq	.+4      	; 0x1392 <vTaskPlaceOnEventListRestricted+0x22>
    138e:	0f ef       	ldi	r16, 0xFF	; 255
    1390:	1f ef       	ldi	r17, 0xFF	; 255
    1392:	6c 2f       	mov	r22, r28
    1394:	c8 01       	movw	r24, r16
    1396:	0e 94 73 05 	call	0xae6	; 0xae6 <prvAddCurrentTaskToDelayedList>
    139a:	cf 91       	pop	r28
    139c:	1f 91       	pop	r17
    139e:	0f 91       	pop	r16
    13a0:	08 95       	ret

000013a2 <xTaskRemoveFromEventList>:
    13a2:	0f 93       	push	r16
    13a4:	1f 93       	push	r17
    13a6:	cf 93       	push	r28
    13a8:	df 93       	push	r29
    13aa:	dc 01       	movw	r26, r24
    13ac:	15 96       	adiw	r26, 0x05	; 5
    13ae:	ed 91       	ld	r30, X+
    13b0:	fc 91       	ld	r31, X
    13b2:	16 97       	sbiw	r26, 0x06	; 6
    13b4:	c6 81       	ldd	r28, Z+6	; 0x06
    13b6:	d7 81       	ldd	r29, Z+7	; 0x07
    13b8:	8e 01       	movw	r16, r28
    13ba:	04 5f       	subi	r16, 0xF4	; 244
    13bc:	1f 4f       	sbci	r17, 0xFF	; 255
    13be:	c8 01       	movw	r24, r16
    13c0:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
    13c4:	80 91 8e 07 	lds	r24, 0x078E	; 0x80078e <uxSchedulerSuspended>
    13c8:	81 11       	cpse	r24, r1
    13ca:	1c c0       	rjmp	.+56     	; 0x1404 <xTaskRemoveFromEventList+0x62>
    13cc:	0a 50       	subi	r16, 0x0A	; 10
    13ce:	11 09       	sbc	r17, r1
    13d0:	c8 01       	movw	r24, r16
    13d2:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
    13d6:	8e 89       	ldd	r24, Y+22	; 0x16
    13d8:	90 91 98 07 	lds	r25, 0x0798	; 0x800798 <uxTopReadyPriority>
    13dc:	98 17       	cp	r25, r24
    13de:	10 f4       	brcc	.+4      	; 0x13e4 <xTaskRemoveFromEventList+0x42>
    13e0:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <uxTopReadyPriority>
    13e4:	90 e0       	ldi	r25, 0x00	; 0
    13e6:	9c 01       	movw	r18, r24
    13e8:	22 0f       	add	r18, r18
    13ea:	33 1f       	adc	r19, r19
    13ec:	22 0f       	add	r18, r18
    13ee:	33 1f       	adc	r19, r19
    13f0:	22 0f       	add	r18, r18
    13f2:	33 1f       	adc	r19, r19
    13f4:	82 0f       	add	r24, r18
    13f6:	93 1f       	adc	r25, r19
    13f8:	b8 01       	movw	r22, r16
    13fa:	82 53       	subi	r24, 0x32	; 50
    13fc:	98 4f       	sbci	r25, 0xF8	; 248
    13fe:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
    1402:	05 c0       	rjmp	.+10     	; 0x140e <xTaskRemoveFromEventList+0x6c>
    1404:	b8 01       	movw	r22, r16
    1406:	8f ea       	ldi	r24, 0xAF	; 175
    1408:	97 e0       	ldi	r25, 0x07	; 7
    140a:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
    140e:	e0 91 f2 07 	lds	r30, 0x07F2	; 0x8007f2 <pxCurrentTCB>
    1412:	f0 91 f3 07 	lds	r31, 0x07F3	; 0x8007f3 <pxCurrentTCB+0x1>
    1416:	9e 89       	ldd	r25, Y+22	; 0x16
    1418:	86 89       	ldd	r24, Z+22	; 0x16
    141a:	89 17       	cp	r24, r25
    141c:	20 f4       	brcc	.+8      	; 0x1426 <xTaskRemoveFromEventList+0x84>
    141e:	81 e0       	ldi	r24, 0x01	; 1
    1420:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <xYieldPending>
    1424:	01 c0       	rjmp	.+2      	; 0x1428 <xTaskRemoveFromEventList+0x86>
    1426:	80 e0       	ldi	r24, 0x00	; 0
    1428:	df 91       	pop	r29
    142a:	cf 91       	pop	r28
    142c:	1f 91       	pop	r17
    142e:	0f 91       	pop	r16
    1430:	08 95       	ret

00001432 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1432:	20 91 94 07 	lds	r18, 0x0794	; 0x800794 <xNumOfOverflows>
    1436:	fc 01       	movw	r30, r24
    1438:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    143a:	20 91 99 07 	lds	r18, 0x0799	; 0x800799 <xTickCount>
    143e:	30 91 9a 07 	lds	r19, 0x079A	; 0x80079a <xTickCount+0x1>
    1442:	32 83       	std	Z+2, r19	; 0x02
    1444:	21 83       	std	Z+1, r18	; 0x01
    1446:	08 95       	ret

00001448 <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1448:	0f b6       	in	r0, 0x3f	; 63
    144a:	f8 94       	cli
    144c:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    144e:	40 91 99 07 	lds	r20, 0x0799	; 0x800799 <xTickCount>
    1452:	50 91 9a 07 	lds	r21, 0x079A	; 0x80079a <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    1456:	db 01       	movw	r26, r22
    1458:	2d 91       	ld	r18, X+
    145a:	3c 91       	ld	r19, X
    145c:	2f 3f       	cpi	r18, 0xFF	; 255
    145e:	bf ef       	ldi	r27, 0xFF	; 255
    1460:	3b 07       	cpc	r19, r27
    1462:	19 f1       	breq	.+70     	; 0x14aa <xTaskCheckForTimeOut+0x62>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1464:	e0 91 94 07 	lds	r30, 0x0794	; 0x800794 <xNumOfOverflows>
    1468:	dc 01       	movw	r26, r24
    146a:	fc 91       	ld	r31, X
    146c:	fe 17       	cp	r31, r30
    146e:	39 f0       	breq	.+14     	; 0x147e <xTaskCheckForTimeOut+0x36>
    1470:	11 96       	adiw	r26, 0x01	; 1
    1472:	ed 91       	ld	r30, X+
    1474:	fc 91       	ld	r31, X
    1476:	12 97       	sbiw	r26, 0x02	; 2
    1478:	4e 17       	cp	r20, r30
    147a:	5f 07       	cpc	r21, r31
    147c:	c0 f4       	brcc	.+48     	; 0x14ae <xTaskCheckForTimeOut+0x66>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    147e:	dc 01       	movw	r26, r24
    1480:	11 96       	adiw	r26, 0x01	; 1
    1482:	ed 91       	ld	r30, X+
    1484:	fc 91       	ld	r31, X
    1486:	12 97       	sbiw	r26, 0x02	; 2
    1488:	da 01       	movw	r26, r20
    148a:	ae 1b       	sub	r26, r30
    148c:	bf 0b       	sbc	r27, r31
    148e:	a2 17       	cp	r26, r18
    1490:	b3 07       	cpc	r27, r19
    1492:	78 f4       	brcc	.+30     	; 0x14b2 <xTaskCheckForTimeOut+0x6a>
    1494:	db 01       	movw	r26, r22
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    1496:	e4 1b       	sub	r30, r20
    1498:	f5 0b       	sbc	r31, r21
    149a:	2e 0f       	add	r18, r30
    149c:	3f 1f       	adc	r19, r31
    149e:	2d 93       	st	X+, r18
    14a0:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    14a2:	0e 94 19 0a 	call	0x1432	; 0x1432 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    14a6:	80 e0       	ldi	r24, 0x00	; 0
    14a8:	05 c0       	rjmp	.+10     	; 0x14b4 <xTaskCheckForTimeOut+0x6c>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    14aa:	80 e0       	ldi	r24, 0x00	; 0
    14ac:	03 c0       	rjmp	.+6      	; 0x14b4 <xTaskCheckForTimeOut+0x6c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    14ae:	81 e0       	ldi	r24, 0x01	; 1
    14b0:	01 c0       	rjmp	.+2      	; 0x14b4 <xTaskCheckForTimeOut+0x6c>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    14b2:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    14b4:	0f 90       	pop	r0
    14b6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    14b8:	08 95       	ret

000014ba <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    14ba:	81 e0       	ldi	r24, 0x01	; 1
    14bc:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <xYieldPending>
    14c0:	08 95       	ret

000014c2 <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    14c2:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <xSchedulerRunning>
    14c6:	88 23       	and	r24, r24
    14c8:	31 f0       	breq	.+12     	; 0x14d6 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    14ca:	80 91 8e 07 	lds	r24, 0x078E	; 0x80078e <uxSchedulerSuspended>
    14ce:	88 23       	and	r24, r24
    14d0:	21 f0       	breq	.+8      	; 0x14da <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    14d2:	80 e0       	ldi	r24, 0x00	; 0
    14d4:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    14d6:	81 e0       	ldi	r24, 0x01	; 1
    14d8:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    14da:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    14dc:	08 95       	ret

000014de <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    14de:	fc 01       	movw	r30, r24
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    14e0:	73 83       	std	Z+3, r23	; 0x03
    14e2:	62 83       	std	Z+2, r22	; 0x02
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    14e4:	91 87       	std	Z+9, r25	; 0x09
    14e6:	80 87       	std	Z+8, r24	; 0x08

	if( xNextExpiryTime <= xTimeNow )
    14e8:	46 17       	cp	r20, r22
    14ea:	57 07       	cpc	r21, r23
    14ec:	90 f0       	brcs	.+36     	; 0x1512 <prvInsertTimerInActiveList+0x34>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    14ee:	42 1b       	sub	r20, r18
    14f0:	53 0b       	sbc	r21, r19
    14f2:	84 85       	ldd	r24, Z+12	; 0x0c
    14f4:	95 85       	ldd	r25, Z+13	; 0x0d
    14f6:	48 17       	cp	r20, r24
    14f8:	59 07       	cpc	r21, r25
    14fa:	e0 f4       	brcc	.+56     	; 0x1534 <prvInsertTimerInActiveList+0x56>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    14fc:	bf 01       	movw	r22, r30
    14fe:	6e 5f       	subi	r22, 0xFE	; 254
    1500:	7f 4f       	sbci	r23, 0xFF	; 255
    1502:	80 91 fa 07 	lds	r24, 0x07FA	; 0x8007fa <pxOverflowTimerList>
    1506:	90 91 fb 07 	lds	r25, 0x07FB	; 0x8007fb <pxOverflowTimerList+0x1>
    150a:	0e 94 90 00 	call	0x120	; 0x120 <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    150e:	80 e0       	ldi	r24, 0x00	; 0
    1510:	08 95       	ret
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    1512:	42 17       	cp	r20, r18
    1514:	53 07       	cpc	r21, r19
    1516:	18 f4       	brcc	.+6      	; 0x151e <prvInsertTimerInActiveList+0x40>
    1518:	62 17       	cp	r22, r18
    151a:	73 07       	cpc	r23, r19
    151c:	68 f4       	brcc	.+26     	; 0x1538 <prvInsertTimerInActiveList+0x5a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    151e:	bf 01       	movw	r22, r30
    1520:	6e 5f       	subi	r22, 0xFE	; 254
    1522:	7f 4f       	sbci	r23, 0xFF	; 255
    1524:	80 91 fc 07 	lds	r24, 0x07FC	; 0x8007fc <pxCurrentTimerList>
    1528:	90 91 fd 07 	lds	r25, 0x07FD	; 0x8007fd <pxCurrentTimerList+0x1>
    152c:	0e 94 90 00 	call	0x120	; 0x120 <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    1530:	80 e0       	ldi	r24, 0x00	; 0
    1532:	08 95       	ret
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    1534:	81 e0       	ldi	r24, 0x01	; 1
    1536:	08 95       	ret
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    1538:	81 e0       	ldi	r24, 0x01	; 1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
    153a:	08 95       	ret

0000153c <prvCheckForValidListAndQueue>:
static void prvCheckForValidListAndQueue( void )
{
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    153c:	0f b6       	in	r0, 0x3f	; 63
    153e:	f8 94       	cli
    1540:	0f 92       	push	r0
	{
		if( xTimerQueue == NULL )
    1542:	80 91 f8 07 	lds	r24, 0x07F8	; 0x8007f8 <xTimerQueue>
    1546:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <xTimerQueue+0x1>
    154a:	89 2b       	or	r24, r25
    154c:	19 f5       	brne	.+70     	; 0x1594 <prvCheckForValidListAndQueue+0x58>
		{
			vListInitialise( &xActiveTimerList1 );
    154e:	87 e0       	ldi	r24, 0x07	; 7
    1550:	98 e0       	ldi	r25, 0x08	; 8
    1552:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
    1556:	8e ef       	ldi	r24, 0xFE	; 254
    1558:	97 e0       	ldi	r25, 0x07	; 7
    155a:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
    155e:	87 e0       	ldi	r24, 0x07	; 7
    1560:	98 e0       	ldi	r25, 0x08	; 8
    1562:	90 93 fd 07 	sts	0x07FD, r25	; 0x8007fd <pxCurrentTimerList+0x1>
    1566:	80 93 fc 07 	sts	0x07FC, r24	; 0x8007fc <pxCurrentTimerList>
			pxOverflowTimerList = &xActiveTimerList2;
    156a:	8e ef       	ldi	r24, 0xFE	; 254
    156c:	97 e0       	ldi	r25, 0x07	; 7
    156e:	90 93 fb 07 	sts	0x07FB, r25	; 0x8007fb <pxOverflowTimerList+0x1>
    1572:	80 93 fa 07 	sts	0x07FA, r24	; 0x8007fa <pxOverflowTimerList>

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
			}
			#else
			{
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    1576:	40 e0       	ldi	r20, 0x00	; 0
    1578:	65 e0       	ldi	r22, 0x05	; 5
    157a:	85 e0       	ldi	r24, 0x05	; 5
    157c:	0e 94 6d 03 	call	0x6da	; 0x6da <xQueueGenericCreate>
    1580:	90 93 f9 07 	sts	0x07F9, r25	; 0x8007f9 <xTimerQueue+0x1>
    1584:	80 93 f8 07 	sts	0x07F8, r24	; 0x8007f8 <xTimerQueue>
			}
			#endif

			#if ( configQUEUE_REGISTRY_SIZE > 0 )
			{
				if( xTimerQueue != NULL )
    1588:	00 97       	sbiw	r24, 0x00	; 0
    158a:	21 f0       	breq	.+8      	; 0x1594 <prvCheckForValidListAndQueue+0x58>
				{
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
    158c:	65 e0       	ldi	r22, 0x05	; 5
    158e:	71 e0       	ldi	r23, 0x01	; 1
    1590:	0e 94 2a 05 	call	0xa54	; 0xa54 <vQueueAddToRegistry>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    1594:	0f 90       	pop	r0
    1596:	0f be       	out	0x3f, r0	; 63
    1598:	08 95       	ret

0000159a <xTimerCreateTimerTask>:
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
    159a:	ef 92       	push	r14
    159c:	ff 92       	push	r15
    159e:	0f 93       	push	r16

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
    15a0:	0e 94 9e 0a 	call	0x153c	; 0x153c <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
    15a4:	80 91 f8 07 	lds	r24, 0x07F8	; 0x8007f8 <xTimerQueue>
    15a8:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <xTimerQueue+0x1>
    15ac:	89 2b       	or	r24, r25
    15ae:	91 f0       	breq	.+36     	; 0x15d4 <xTimerCreateTimerTask+0x3a>
				xReturn = pdPASS;
			}
		}
		#else
		{
			xReturn = xTaskCreate(	prvTimerTask,
    15b0:	0f 2e       	mov	r0, r31
    15b2:	f6 ef       	ldi	r31, 0xF6	; 246
    15b4:	ef 2e       	mov	r14, r31
    15b6:	f7 e0       	ldi	r31, 0x07	; 7
    15b8:	ff 2e       	mov	r15, r31
    15ba:	f0 2d       	mov	r31, r0
    15bc:	02 e0       	ldi	r16, 0x02	; 2
    15be:	20 e0       	ldi	r18, 0x00	; 0
    15c0:	30 e0       	ldi	r19, 0x00	; 0
    15c2:	45 e5       	ldi	r20, 0x55	; 85
    15c4:	50 e0       	ldi	r21, 0x00	; 0
    15c6:	6a e0       	ldi	r22, 0x0A	; 10
    15c8:	71 e0       	ldi	r23, 0x01	; 1
    15ca:	89 ed       	ldi	r24, 0xD9	; 217
    15cc:	9b e0       	ldi	r25, 0x0B	; 11
    15ce:	0e 94 cb 05 	call	0xb96	; 0xb96 <xTaskCreate>
    15d2:	01 c0       	rjmp	.+2      	; 0x15d6 <xTimerCreateTimerTask+0x3c>
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
BaseType_t xReturn = pdFAIL;
    15d4:	80 e0       	ldi	r24, 0x00	; 0
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
	return xReturn;
}
    15d6:	0f 91       	pop	r16
    15d8:	ff 90       	pop	r15
    15da:	ef 90       	pop	r14
    15dc:	08 95       	ret

000015de <xTimerCreate>:
	TimerHandle_t xTimerCreate(	const char * const pcTimerName,
								const TickType_t xTimerPeriodInTicks,
								const UBaseType_t uxAutoReload,
								void * const pvTimerID,
								TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    15de:	9f 92       	push	r9
    15e0:	af 92       	push	r10
    15e2:	bf 92       	push	r11
    15e4:	cf 92       	push	r12
    15e6:	df 92       	push	r13
    15e8:	ef 92       	push	r14
    15ea:	ff 92       	push	r15
    15ec:	0f 93       	push	r16
    15ee:	1f 93       	push	r17
    15f0:	cf 93       	push	r28
    15f2:	df 93       	push	r29
    15f4:	5c 01       	movw	r10, r24
    15f6:	6b 01       	movw	r12, r22
    15f8:	94 2e       	mov	r9, r20
    15fa:	79 01       	movw	r14, r18
	Timer_t *pxNewTimer;

		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
    15fc:	83 e1       	ldi	r24, 0x13	; 19
    15fe:	90 e0       	ldi	r25, 0x00	; 0
    1600:	0e 94 e7 00 	call	0x1ce	; 0x1ce <pvPortMalloc>
    1604:	ec 01       	movw	r28, r24
									Timer_t *pxNewTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	if( pxNewTimer != NULL )
    1606:	89 2b       	or	r24, r25
    1608:	79 f0       	breq	.+30     	; 0x1628 <xTimerCreate+0x4a>
	{
		/* Ensure the infrastructure used by the timer service task has been
		created/initialised. */
		prvCheckForValidListAndQueue();
    160a:	0e 94 9e 0a 	call	0x153c	; 0x153c <prvCheckForValidListAndQueue>

		/* Initialise the timer structure members using the function
		parameters. */
		pxNewTimer->pcTimerName = pcTimerName;
    160e:	b9 82       	std	Y+1, r11	; 0x01
    1610:	a8 82       	st	Y, r10
		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    1612:	dd 86       	std	Y+13, r13	; 0x0d
    1614:	cc 86       	std	Y+12, r12	; 0x0c
		pxNewTimer->uxAutoReload = uxAutoReload;
    1616:	9e 86       	std	Y+14, r9	; 0x0e
		pxNewTimer->pvTimerID = pvTimerID;
    1618:	f8 8a       	std	Y+16, r15	; 0x10
    161a:	ef 86       	std	Y+15, r14	; 0x0f
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    161c:	1a 8b       	std	Y+18, r17	; 0x12
    161e:	09 8b       	std	Y+17, r16	; 0x11
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    1620:	ce 01       	movw	r24, r28
    1622:	02 96       	adiw	r24, 0x02	; 2
    1624:	0e 94 6b 00 	call	0xd6	; 0xd6 <vListInitialiseItem>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */
		}

		return pxNewTimer;
	}
    1628:	ce 01       	movw	r24, r28
    162a:	df 91       	pop	r29
    162c:	cf 91       	pop	r28
    162e:	1f 91       	pop	r17
    1630:	0f 91       	pop	r16
    1632:	ff 90       	pop	r15
    1634:	ef 90       	pop	r14
    1636:	df 90       	pop	r13
    1638:	cf 90       	pop	r12
    163a:	bf 90       	pop	r11
    163c:	af 90       	pop	r10
    163e:	9f 90       	pop	r9
    1640:	08 95       	ret

00001642 <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    1642:	0f 93       	push	r16
    1644:	1f 93       	push	r17
    1646:	cf 93       	push	r28
    1648:	df 93       	push	r29
    164a:	00 d0       	rcall	.+0      	; 0x164c <xTimerGenericCommand+0xa>
    164c:	00 d0       	rcall	.+0      	; 0x164e <xTimerGenericCommand+0xc>
    164e:	1f 92       	push	r1
    1650:	cd b7       	in	r28, 0x3d	; 61
    1652:	de b7       	in	r29, 0x3e	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    1654:	e0 91 f8 07 	lds	r30, 0x07F8	; 0x8007f8 <xTimerQueue>
    1658:	f0 91 f9 07 	lds	r31, 0x07F9	; 0x8007f9 <xTimerQueue+0x1>
    165c:	30 97       	sbiw	r30, 0x00	; 0
    165e:	71 f1       	breq	.+92     	; 0x16bc <xTimerGenericCommand+0x7a>
    1660:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    1662:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    1664:	5b 83       	std	Y+3, r21	; 0x03
    1666:	4a 83       	std	Y+2, r20	; 0x02
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    1668:	9d 83       	std	Y+5, r25	; 0x05
    166a:	8c 83       	std	Y+4, r24	; 0x04

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    166c:	66 30       	cpi	r22, 0x06	; 6
    166e:	ec f4       	brge	.+58     	; 0x16aa <xTimerGenericCommand+0x68>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    1670:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <xTaskGetSchedulerState>
    1674:	82 30       	cpi	r24, 0x02	; 2
    1676:	61 f4       	brne	.+24     	; 0x1690 <xTimerGenericCommand+0x4e>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    1678:	20 e0       	ldi	r18, 0x00	; 0
    167a:	a8 01       	movw	r20, r16
    167c:	be 01       	movw	r22, r28
    167e:	6f 5f       	subi	r22, 0xFF	; 255
    1680:	7f 4f       	sbci	r23, 0xFF	; 255
    1682:	80 91 f8 07 	lds	r24, 0x07F8	; 0x8007f8 <xTimerQueue>
    1686:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <xTimerQueue+0x1>
    168a:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
    168e:	17 c0       	rjmp	.+46     	; 0x16be <xTimerGenericCommand+0x7c>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    1690:	20 e0       	ldi	r18, 0x00	; 0
    1692:	40 e0       	ldi	r20, 0x00	; 0
    1694:	50 e0       	ldi	r21, 0x00	; 0
    1696:	be 01       	movw	r22, r28
    1698:	6f 5f       	subi	r22, 0xFF	; 255
    169a:	7f 4f       	sbci	r23, 0xFF	; 255
    169c:	80 91 f8 07 	lds	r24, 0x07F8	; 0x8007f8 <xTimerQueue>
    16a0:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <xTimerQueue+0x1>
    16a4:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
    16a8:	0a c0       	rjmp	.+20     	; 0x16be <xTimerGenericCommand+0x7c>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    16aa:	20 e0       	ldi	r18, 0x00	; 0
    16ac:	ad 01       	movw	r20, r26
    16ae:	be 01       	movw	r22, r28
    16b0:	6f 5f       	subi	r22, 0xFF	; 255
    16b2:	7f 4f       	sbci	r23, 0xFF	; 255
    16b4:	cf 01       	movw	r24, r30
    16b6:	0e 94 3b 04 	call	0x876	; 0x876 <xQueueGenericSendFromISR>
    16ba:	01 c0       	rjmp	.+2      	; 0x16be <xTimerGenericCommand+0x7c>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    16bc:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    16be:	0f 90       	pop	r0
    16c0:	0f 90       	pop	r0
    16c2:	0f 90       	pop	r0
    16c4:	0f 90       	pop	r0
    16c6:	0f 90       	pop	r0
    16c8:	df 91       	pop	r29
    16ca:	cf 91       	pop	r28
    16cc:	1f 91       	pop	r17
    16ce:	0f 91       	pop	r16
    16d0:	08 95       	ret

000016d2 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    16d2:	af 92       	push	r10
    16d4:	bf 92       	push	r11
    16d6:	cf 92       	push	r12
    16d8:	df 92       	push	r13
    16da:	ef 92       	push	r14
    16dc:	ff 92       	push	r15
    16de:	0f 93       	push	r16
    16e0:	1f 93       	push	r17
    16e2:	cf 93       	push	r28
    16e4:	df 93       	push	r29
    16e6:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    16e8:	0e 94 5b 07 	call	0xeb6	; 0xeb6 <xTaskGetTickCount>
    16ec:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    16ee:	80 91 f4 07 	lds	r24, 0x07F4	; 0x8007f4 <xLastTime.2351>
    16f2:	90 91 f5 07 	lds	r25, 0x07F5	; 0x8007f5 <xLastTime.2351+0x1>
    16f6:	e8 16       	cp	r14, r24
    16f8:	f9 06       	cpc	r15, r25
    16fa:	08 f0       	brcs	.+2      	; 0x16fe <prvSampleTimeNow+0x2c>
    16fc:	48 c0       	rjmp	.+144    	; 0x178e <prvSampleTimeNow+0xbc>
    16fe:	30 c0       	rjmp	.+96     	; 0x1760 <prvSampleTimeNow+0x8e>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1700:	05 80       	ldd	r0, Z+5	; 0x05
    1702:	f6 81       	ldd	r31, Z+6	; 0x06
    1704:	e0 2d       	mov	r30, r0
    1706:	a0 80       	ld	r10, Z
    1708:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    170a:	c6 81       	ldd	r28, Z+6	; 0x06
    170c:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    170e:	8e 01       	movw	r16, r28
    1710:	0e 5f       	subi	r16, 0xFE	; 254
    1712:	1f 4f       	sbci	r17, 0xFF	; 255
    1714:	c8 01       	movw	r24, r16
    1716:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    171a:	e9 89       	ldd	r30, Y+17	; 0x11
    171c:	fa 89       	ldd	r31, Y+18	; 0x12
    171e:	ce 01       	movw	r24, r28
    1720:	09 95       	icall

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1722:	8e 85       	ldd	r24, Y+14	; 0x0e
    1724:	81 30       	cpi	r24, 0x01	; 1
    1726:	e1 f4       	brne	.+56     	; 0x1760 <prvSampleTimeNow+0x8e>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    1728:	8c 85       	ldd	r24, Y+12	; 0x0c
    172a:	9d 85       	ldd	r25, Y+13	; 0x0d
    172c:	8a 0d       	add	r24, r10
    172e:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    1730:	a8 16       	cp	r10, r24
    1732:	b9 06       	cpc	r11, r25
    1734:	60 f4       	brcc	.+24     	; 0x174e <prvSampleTimeNow+0x7c>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    1736:	9b 83       	std	Y+3, r25	; 0x03
    1738:	8a 83       	std	Y+2, r24	; 0x02
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    173a:	d9 87       	std	Y+9, r29	; 0x09
    173c:	c8 87       	std	Y+8, r28	; 0x08
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    173e:	b8 01       	movw	r22, r16
    1740:	80 91 fc 07 	lds	r24, 0x07FC	; 0x8007fc <pxCurrentTimerList>
    1744:	90 91 fd 07 	lds	r25, 0x07FD	; 0x8007fd <pxCurrentTimerList+0x1>
    1748:	0e 94 90 00 	call	0x120	; 0x120 <vListInsert>
    174c:	09 c0       	rjmp	.+18     	; 0x1760 <prvSampleTimeNow+0x8e>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    174e:	00 e0       	ldi	r16, 0x00	; 0
    1750:	10 e0       	ldi	r17, 0x00	; 0
    1752:	20 e0       	ldi	r18, 0x00	; 0
    1754:	30 e0       	ldi	r19, 0x00	; 0
    1756:	a5 01       	movw	r20, r10
    1758:	60 e0       	ldi	r22, 0x00	; 0
    175a:	ce 01       	movw	r24, r28
    175c:	0e 94 21 0b 	call	0x1642	; 0x1642 <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    1760:	e0 91 fc 07 	lds	r30, 0x07FC	; 0x8007fc <pxCurrentTimerList>
    1764:	f0 91 fd 07 	lds	r31, 0x07FD	; 0x8007fd <pxCurrentTimerList+0x1>
    1768:	80 81       	ld	r24, Z
    176a:	81 11       	cpse	r24, r1
    176c:	c9 cf       	rjmp	.-110    	; 0x1700 <prvSampleTimeNow+0x2e>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    176e:	80 91 fa 07 	lds	r24, 0x07FA	; 0x8007fa <pxOverflowTimerList>
    1772:	90 91 fb 07 	lds	r25, 0x07FB	; 0x8007fb <pxOverflowTimerList+0x1>
    1776:	90 93 fd 07 	sts	0x07FD, r25	; 0x8007fd <pxCurrentTimerList+0x1>
    177a:	80 93 fc 07 	sts	0x07FC, r24	; 0x8007fc <pxCurrentTimerList>
	pxOverflowTimerList = pxTemp;
    177e:	f0 93 fb 07 	sts	0x07FB, r31	; 0x8007fb <pxOverflowTimerList+0x1>
    1782:	e0 93 fa 07 	sts	0x07FA, r30	; 0x8007fa <pxOverflowTimerList>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    1786:	81 e0       	ldi	r24, 0x01	; 1
    1788:	f6 01       	movw	r30, r12
    178a:	80 83       	st	Z, r24
    178c:	02 c0       	rjmp	.+4      	; 0x1792 <prvSampleTimeNow+0xc0>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    178e:	f6 01       	movw	r30, r12
    1790:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    1792:	f0 92 f5 07 	sts	0x07F5, r15	; 0x8007f5 <xLastTime.2351+0x1>
    1796:	e0 92 f4 07 	sts	0x07F4, r14	; 0x8007f4 <xLastTime.2351>

	return xTimeNow;
}
    179a:	c7 01       	movw	r24, r14
    179c:	df 91       	pop	r29
    179e:	cf 91       	pop	r28
    17a0:	1f 91       	pop	r17
    17a2:	0f 91       	pop	r16
    17a4:	ff 90       	pop	r15
    17a6:	ef 90       	pop	r14
    17a8:	df 90       	pop	r13
    17aa:	cf 90       	pop	r12
    17ac:	bf 90       	pop	r11
    17ae:	af 90       	pop	r10
    17b0:	08 95       	ret

000017b2 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    17b2:	cf 93       	push	r28
    17b4:	df 93       	push	r29
    17b6:	00 d0       	rcall	.+0      	; 0x17b8 <prvTimerTask+0x6>
    17b8:	00 d0       	rcall	.+0      	; 0x17ba <prvTimerTask+0x8>
    17ba:	00 d0       	rcall	.+0      	; 0x17bc <prvTimerTask+0xa>
    17bc:	cd b7       	in	r28, 0x3d	; 61
    17be:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    17c0:	ce 01       	movw	r24, r28
    17c2:	01 96       	adiw	r24, 0x01	; 1
    17c4:	4c 01       	movw	r8, r24
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    17c6:	44 24       	eor	r4, r4
    17c8:	43 94       	inc	r4
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    17ca:	d1 2c       	mov	r13, r1
    17cc:	e1 2c       	mov	r14, r1
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    17ce:	f1 2c       	mov	r15, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    17d0:	58 2e       	mov	r5, r24
    17d2:	c9 2c       	mov	r12, r9
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    17d4:	e0 91 fc 07 	lds	r30, 0x07FC	; 0x8007fc <pxCurrentTimerList>
    17d8:	f0 91 fd 07 	lds	r31, 0x07FD	; 0x8007fd <pxCurrentTimerList+0x1>
	if( *pxListWasEmpty == pdFALSE )
    17dc:	80 81       	ld	r24, Z
    17de:	88 23       	and	r24, r24
    17e0:	09 f4       	brne	.+2      	; 0x17e4 <prvTimerTask+0x32>
    17e2:	c3 c0       	rjmp	.+390    	; 0x196a <prvTimerTask+0x1b8>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    17e4:	05 80       	ldd	r0, Z+5	; 0x05
    17e6:	f6 81       	ldd	r31, Z+6	; 0x06
    17e8:	e0 2d       	mov	r30, r0
    17ea:	a0 80       	ld	r10, Z
    17ec:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    17ee:	0e 94 55 07 	call	0xeaa	; 0xeaa <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    17f2:	c4 01       	movw	r24, r8
    17f4:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <prvSampleTimeNow>
    17f8:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    17fa:	89 81       	ldd	r24, Y+1	; 0x01
    17fc:	81 11       	cpse	r24, r1
    17fe:	47 c0       	rjmp	.+142    	; 0x188e <prvTimerTask+0xdc>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    1800:	0a 15       	cp	r16, r10
    1802:	1b 05       	cpc	r17, r11
    1804:	98 f1       	brcs	.+102    	; 0x186c <prvTimerTask+0xba>
			{
				( void ) xTaskResumeAll();
    1806:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    180a:	e0 91 fc 07 	lds	r30, 0x07FC	; 0x8007fc <pxCurrentTimerList>
    180e:	f0 91 fd 07 	lds	r31, 0x07FD	; 0x8007fd <pxCurrentTimerList+0x1>
    1812:	05 80       	ldd	r0, Z+5	; 0x05
    1814:	f6 81       	ldd	r31, Z+6	; 0x06
    1816:	e0 2d       	mov	r30, r0
    1818:	66 80       	ldd	r6, Z+6	; 0x06
    181a:	77 80       	ldd	r7, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    181c:	c3 01       	movw	r24, r6
    181e:	02 96       	adiw	r24, 0x02	; 2
    1820:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1824:	d3 01       	movw	r26, r6
    1826:	1e 96       	adiw	r26, 0x0e	; 14
    1828:	8c 91       	ld	r24, X
    182a:	1e 97       	sbiw	r26, 0x0e	; 14
    182c:	81 30       	cpi	r24, 0x01	; 1
    182e:	b1 f4       	brne	.+44     	; 0x185c <prvTimerTask+0xaa>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    1830:	1c 96       	adiw	r26, 0x0c	; 12
    1832:	6d 91       	ld	r22, X+
    1834:	7c 91       	ld	r23, X
    1836:	1d 97       	sbiw	r26, 0x0d	; 13
    1838:	6a 0d       	add	r22, r10
    183a:	7b 1d       	adc	r23, r11
    183c:	95 01       	movw	r18, r10
    183e:	a8 01       	movw	r20, r16
    1840:	c3 01       	movw	r24, r6
    1842:	0e 94 6f 0a 	call	0x14de	; 0x14de <prvInsertTimerInActiveList>
    1846:	88 23       	and	r24, r24
    1848:	49 f0       	breq	.+18     	; 0x185c <prvTimerTask+0xaa>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    184a:	0d 2d       	mov	r16, r13
    184c:	1e 2d       	mov	r17, r14
    184e:	2d 2d       	mov	r18, r13
    1850:	3e 2d       	mov	r19, r14
    1852:	a5 01       	movw	r20, r10
    1854:	6f 2d       	mov	r22, r15
    1856:	c3 01       	movw	r24, r6
    1858:	0e 94 21 0b 	call	0x1642	; 0x1642 <xTimerGenericCommand>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    185c:	d3 01       	movw	r26, r6
    185e:	51 96       	adiw	r26, 0x11	; 17
    1860:	ed 91       	ld	r30, X+
    1862:	fc 91       	ld	r31, X
    1864:	52 97       	sbiw	r26, 0x12	; 18
    1866:	c3 01       	movw	r24, r6
    1868:	09 95       	icall
    186a:	71 c0       	rjmp	.+226    	; 0x194e <prvTimerTask+0x19c>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    186c:	4f 2d       	mov	r20, r15
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    186e:	b5 01       	movw	r22, r10
    1870:	60 1b       	sub	r22, r16
    1872:	71 0b       	sbc	r23, r17
    1874:	80 91 f8 07 	lds	r24, 0x07F8	; 0x8007f8 <xTimerQueue>
    1878:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <xTimerQueue+0x1>
    187c:	0e 94 37 05 	call	0xa6e	; 0xa6e <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    1880:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
    1884:	81 11       	cpse	r24, r1
    1886:	63 c0       	rjmp	.+198    	; 0x194e <prvTimerTask+0x19c>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    1888:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
    188c:	60 c0       	rjmp	.+192    	; 0x194e <prvTimerTask+0x19c>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    188e:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
    1892:	5d c0       	rjmp	.+186    	; 0x194e <prvTimerTask+0x19c>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    1894:	89 81       	ldd	r24, Y+1	; 0x01
    1896:	88 23       	and	r24, r24
    1898:	0c f4       	brge	.+2      	; 0x189c <prvTimerTask+0xea>
    189a:	59 c0       	rjmp	.+178    	; 0x194e <prvTimerTask+0x19c>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    189c:	ac 80       	ldd	r10, Y+4	; 0x04
    189e:	bd 80       	ldd	r11, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    18a0:	f5 01       	movw	r30, r10
    18a2:	82 85       	ldd	r24, Z+10	; 0x0a
    18a4:	93 85       	ldd	r25, Z+11	; 0x0b
    18a6:	89 2b       	or	r24, r25
    18a8:	21 f0       	breq	.+8      	; 0x18b2 <prvTimerTask+0x100>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    18aa:	c5 01       	movw	r24, r10
    18ac:	02 96       	adiw	r24, 0x02	; 2
    18ae:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    18b2:	ce 01       	movw	r24, r28
    18b4:	06 96       	adiw	r24, 0x06	; 6
    18b6:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <prvSampleTimeNow>

			switch( xMessage.xMessageID )
    18ba:	e9 81       	ldd	r30, Y+1	; 0x01
    18bc:	0e 2f       	mov	r16, r30
    18be:	ee 0f       	add	r30, r30
    18c0:	11 0b       	sbc	r17, r17
    18c2:	22 0b       	sbc	r18, r18
    18c4:	33 0b       	sbc	r19, r19
    18c6:	0a 30       	cpi	r16, 0x0A	; 10
    18c8:	11 05       	cpc	r17, r1
    18ca:	08 f0       	brcs	.+2      	; 0x18ce <prvTimerTask+0x11c>
    18cc:	40 c0       	rjmp	.+128    	; 0x194e <prvTimerTask+0x19c>
    18ce:	f8 01       	movw	r30, r16
    18d0:	ec 5c       	subi	r30, 0xCC	; 204
    18d2:	ff 4f       	sbci	r31, 0xFF	; 255
    18d4:	0c 94 d4 15 	jmp	0x2ba8	; 0x2ba8 <__tablejump2__>
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    18d8:	2a 81       	ldd	r18, Y+2	; 0x02
    18da:	3b 81       	ldd	r19, Y+3	; 0x03
    18dc:	d5 01       	movw	r26, r10
    18de:	1c 96       	adiw	r26, 0x0c	; 12
    18e0:	6d 91       	ld	r22, X+
    18e2:	7c 91       	ld	r23, X
    18e4:	1d 97       	sbiw	r26, 0x0d	; 13
    18e6:	62 0f       	add	r22, r18
    18e8:	73 1f       	adc	r23, r19
    18ea:	ac 01       	movw	r20, r24
    18ec:	c5 01       	movw	r24, r10
    18ee:	0e 94 6f 0a 	call	0x14de	; 0x14de <prvInsertTimerInActiveList>
    18f2:	88 23       	and	r24, r24
    18f4:	61 f1       	breq	.+88     	; 0x194e <prvTimerTask+0x19c>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    18f6:	d5 01       	movw	r26, r10
    18f8:	51 96       	adiw	r26, 0x11	; 17
    18fa:	ed 91       	ld	r30, X+
    18fc:	fc 91       	ld	r31, X
    18fe:	52 97       	sbiw	r26, 0x12	; 18
    1900:	c5 01       	movw	r24, r10
    1902:	09 95       	icall
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1904:	f5 01       	movw	r30, r10
    1906:	86 85       	ldd	r24, Z+14	; 0x0e
    1908:	81 30       	cpi	r24, 0x01	; 1
    190a:	09 f5       	brne	.+66     	; 0x194e <prvTimerTask+0x19c>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    190c:	4a 81       	ldd	r20, Y+2	; 0x02
    190e:	5b 81       	ldd	r21, Y+3	; 0x03
    1910:	84 85       	ldd	r24, Z+12	; 0x0c
    1912:	95 85       	ldd	r25, Z+13	; 0x0d
    1914:	48 0f       	add	r20, r24
    1916:	59 1f       	adc	r21, r25
    1918:	0d 2d       	mov	r16, r13
    191a:	1e 2d       	mov	r17, r14
    191c:	2d 2d       	mov	r18, r13
    191e:	3e 2d       	mov	r19, r14
    1920:	6f 2d       	mov	r22, r15
    1922:	c5 01       	movw	r24, r10
    1924:	0e 94 21 0b 	call	0x1642	; 0x1642 <xTimerGenericCommand>
    1928:	12 c0       	rjmp	.+36     	; 0x194e <prvTimerTask+0x19c>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    192a:	6a 81       	ldd	r22, Y+2	; 0x02
    192c:	7b 81       	ldd	r23, Y+3	; 0x03
    192e:	d5 01       	movw	r26, r10
    1930:	1d 96       	adiw	r26, 0x0d	; 13
    1932:	7c 93       	st	X, r23
    1934:	6e 93       	st	-X, r22
    1936:	1c 97       	sbiw	r26, 0x0c	; 12
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    1938:	68 0f       	add	r22, r24
    193a:	79 1f       	adc	r23, r25
    193c:	9c 01       	movw	r18, r24
    193e:	ac 01       	movw	r20, r24
    1940:	c5 01       	movw	r24, r10
    1942:	0e 94 6f 0a 	call	0x14de	; 0x14de <prvInsertTimerInActiveList>
    1946:	03 c0       	rjmp	.+6      	; 0x194e <prvTimerTask+0x19c>
					allocated. */
					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
					{
						/* The timer can only have been allocated dynamically -
						free it again. */
						vPortFree( pxTimer );
    1948:	c5 01       	movw	r24, r10
    194a:	0e 94 1c 01 	call	0x238	; 0x238 <vPortFree>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    194e:	2f 2d       	mov	r18, r15
    1950:	4d 2d       	mov	r20, r13
    1952:	5e 2d       	mov	r21, r14
    1954:	65 2d       	mov	r22, r5
    1956:	7c 2d       	mov	r23, r12
    1958:	80 91 f8 07 	lds	r24, 0x07F8	; 0x8007f8 <xTimerQueue>
    195c:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <xTimerQueue+0x1>
    1960:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    1964:	81 11       	cpse	r24, r1
    1966:	96 cf       	rjmp	.-212    	; 0x1894 <prvTimerTask+0xe2>
    1968:	35 cf       	rjmp	.-406    	; 0x17d4 <prvTimerTask+0x22>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    196a:	0e 94 55 07 	call	0xeaa	; 0xeaa <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    196e:	c4 01       	movw	r24, r8
    1970:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <prvSampleTimeNow>
    1974:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    1976:	89 81       	ldd	r24, Y+1	; 0x01
    1978:	81 11       	cpse	r24, r1
    197a:	89 cf       	rjmp	.-238    	; 0x188e <prvTimerTask+0xdc>
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    197c:	e0 91 fa 07 	lds	r30, 0x07FA	; 0x8007fa <pxOverflowTimerList>
    1980:	f0 91 fb 07 	lds	r31, 0x07FB	; 0x8007fb <pxOverflowTimerList+0x1>
    1984:	44 2d       	mov	r20, r4
    1986:	80 81       	ld	r24, Z
    1988:	81 11       	cpse	r24, r1
    198a:	4f 2d       	mov	r20, r15
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    198c:	ad 2c       	mov	r10, r13
    198e:	be 2c       	mov	r11, r14
    1990:	6e cf       	rjmp	.-292    	; 0x186e <prvTimerTask+0xbc>

00001992 <UART_sendChar>:
}

static void UART_sendChar(char data)
{
	//Wait for the transmission buffer is empty
	while (!(UCSR0A & (1 << UDRE0)));
    1992:	e0 ec       	ldi	r30, 0xC0	; 192
    1994:	f0 e0       	ldi	r31, 0x00	; 0
    1996:	90 81       	ld	r25, Z
    1998:	95 ff       	sbrs	r25, 5
    199a:	fd cf       	rjmp	.-6      	; 0x1996 <UART_sendChar+0x4>
	
	//Load the transmission buffer
	UDR0 = data;
    199c:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
    19a0:	08 95       	ret

000019a2 <ADC_read>:
	
}

static float ADC_read(){

	ADCSRA |= (1<<ADSC); //Start conversion
    19a2:	ea e7       	ldi	r30, 0x7A	; 122
    19a4:	f0 e0       	ldi	r31, 0x00	; 0
    19a6:	80 81       	ld	r24, Z
    19a8:	80 64       	ori	r24, 0x40	; 64
    19aa:	80 83       	st	Z, r24
	while ((ADCSRA&(1<<ADIF)) ==0); //wait for end of conversion
    19ac:	80 81       	ld	r24, Z
    19ae:	84 ff       	sbrs	r24, 4
    19b0:	fd cf       	rjmp	.-6      	; 0x19ac <ADC_read+0xa>
	ADCSRA |= (1<<ADIF); //clear the ADIF flag
    19b2:	ea e7       	ldi	r30, 0x7A	; 122
    19b4:	f0 e0       	ldi	r31, 0x00	; 0
    19b6:	80 81       	ld	r24, Z
    19b8:	80 61       	ori	r24, 0x10	; 16
    19ba:	80 83       	st	Z, r24

	return (ADCL+(ADCH<<8));
    19bc:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
    19c0:	60 91 79 00 	lds	r22, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
    19c4:	70 e0       	ldi	r23, 0x00	; 0
    19c6:	76 2f       	mov	r23, r22
    19c8:	66 27       	eor	r22, r22
    19ca:	68 0f       	add	r22, r24
    19cc:	71 1d       	adc	r23, r1
    19ce:	07 2e       	mov	r0, r23
    19d0:	00 0c       	add	r0, r0
    19d2:	88 0b       	sbc	r24, r24
    19d4:	99 0b       	sbc	r25, r25
    19d6:	0e 94 b2 14 	call	0x2964	; 0x2964 <__floatsisf>
	//return ADC;
}
    19da:	08 95       	ret

000019dc <LCD_putValue>:
	UDR0 = data;
}

static void LCD_putValue(unsigned char val)
{
  LCD_DPRT &= 0x0F;
    19dc:	9b b1       	in	r25, 0x0b	; 11
    19de:	9f 70       	andi	r25, 0x0F	; 15
    19e0:	9b b9       	out	0x0b, r25	; 11
  LCD_DPRT |= (val&0xF0);     //send cmnd to data port
    19e2:	9b b1       	in	r25, 0x0b	; 11
    19e4:	28 2f       	mov	r18, r24
    19e6:	20 7f       	andi	r18, 0xF0	; 240
    19e8:	92 2b       	or	r25, r18
    19ea:	9b b9       	out	0x0b, r25	; 11
  LCD_CPRT |= (1<<LCD_EN);    //EN = 1 for H-to-L pulse
    19ec:	29 9a       	sbi	0x05, 1	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    19ee:	35 e0       	ldi	r19, 0x05	; 5
    19f0:	3a 95       	dec	r19
    19f2:	f1 f7       	brne	.-4      	; 0x19f0 <LCD_putValue+0x14>
    19f4:	00 00       	nop
  _delay_us(1);       //wait to make enable wide
  LCD_CPRT &= ~ (1<<LCD_EN);  //EN = 0 for H-to-L pulse
    19f6:	29 98       	cbi	0x05, 1	; 5
    19f8:	ef e8       	ldi	r30, 0x8F	; 143
    19fa:	f1 e0       	ldi	r31, 0x01	; 1
    19fc:	31 97       	sbiw	r30, 0x01	; 1
    19fe:	f1 f7       	brne	.-4      	; 0x19fc <LCD_putValue+0x20>
    1a00:	00 c0       	rjmp	.+0      	; 0x1a02 <LCD_putValue+0x26>
    1a02:	00 00       	nop
  _delay_us(100);     //wait to make enable wide

  LCD_DPRT &= 0x0F;
    1a04:	9b b1       	in	r25, 0x0b	; 11
    1a06:	9f 70       	andi	r25, 0x0F	; 15
    1a08:	9b b9       	out	0x0b, r25	; 11
  LCD_DPRT |= val<<4;     //send cmnd to data port
    1a0a:	2b b1       	in	r18, 0x0b	; 11
    1a0c:	f0 e1       	ldi	r31, 0x10	; 16
    1a0e:	8f 9f       	mul	r24, r31
    1a10:	c0 01       	movw	r24, r0
    1a12:	11 24       	eor	r1, r1
    1a14:	82 2b       	or	r24, r18
    1a16:	8b b9       	out	0x0b, r24	; 11
  LCD_CPRT |= (1<<LCD_EN);    //EN = 1 for H-to-L pulse
    1a18:	29 9a       	sbi	0x05, 1	; 5
    1a1a:	35 e0       	ldi	r19, 0x05	; 5
    1a1c:	3a 95       	dec	r19
    1a1e:	f1 f7       	brne	.-4      	; 0x1a1c <LCD_putValue+0x40>
    1a20:	00 00       	nop
  _delay_us(1);       //wait to make enable wide
  LCD_CPRT &= ~ (1<<LCD_EN);  //EN = 0 for H-to-L pulse
    1a22:	29 98       	cbi	0x05, 1	; 5
    1a24:	8f e8       	ldi	r24, 0x8F	; 143
    1a26:	91 e0       	ldi	r25, 0x01	; 1
    1a28:	01 97       	sbiw	r24, 0x01	; 1
    1a2a:	f1 f7       	brne	.-4      	; 0x1a28 <LCD_putValue+0x4c>
    1a2c:	00 c0       	rjmp	.+0      	; 0x1a2e <LCD_putValue+0x52>
    1a2e:	00 00       	nop
    1a30:	08 95       	ret

00001a32 <LCD_sendCommand>:
  _delay_us(100);     //wait to make enable wide    
}

static void LCD_sendCommand( unsigned char cmnd )
{ 
  LCD_CPRT &= ~ (1<<LCD_RS);    //RS = 0 for command  
    1a32:	28 98       	cbi	0x05, 0	; 5
  LCD_putValue(cmnd);
    1a34:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <LCD_putValue>
    1a38:	08 95       	ret

00001a3a <LCD_sendData>:
}

static void LCD_sendData( unsigned char data )
{
  LCD_CPRT |= (1<<LCD_RS);    //RS = 1 for data   
    1a3a:	28 9a       	sbi	0x05, 0	; 5
  LCD_putValue(data);  
    1a3c:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <LCD_putValue>
    1a40:	08 95       	ret

00001a42 <LCD_goToXY>:

  LCD_clear();    
}

static void LCD_goToXY(unsigned char x, unsigned char y)
{  
    1a42:	cf 93       	push	r28
    1a44:	df 93       	push	r29
    1a46:	00 d0       	rcall	.+0      	; 0x1a48 <LCD_goToXY+0x6>
    1a48:	00 d0       	rcall	.+0      	; 0x1a4a <LCD_goToXY+0x8>
    1a4a:	cd b7       	in	r28, 0x3d	; 61
    1a4c:	de b7       	in	r29, 0x3e	; 62
  unsigned char firstCharAdr[]={0x80,0xC0,0x94,0xD4};
    1a4e:	90 e8       	ldi	r25, 0x80	; 128
    1a50:	99 83       	std	Y+1, r25	; 0x01
    1a52:	90 ec       	ldi	r25, 0xC0	; 192
    1a54:	9a 83       	std	Y+2, r25	; 0x02
    1a56:	94 e9       	ldi	r25, 0x94	; 148
    1a58:	9b 83       	std	Y+3, r25	; 0x03
    1a5a:	94 ed       	ldi	r25, 0xD4	; 212
    1a5c:	9c 83       	std	Y+4, r25	; 0x04
  LCD_sendCommand(firstCharAdr[y-1] + x - 1);
    1a5e:	fe 01       	movw	r30, r28
    1a60:	e6 0f       	add	r30, r22
    1a62:	f1 1d       	adc	r31, r1
    1a64:	81 50       	subi	r24, 0x01	; 1
    1a66:	90 81       	ld	r25, Z
    1a68:	89 0f       	add	r24, r25
    1a6a:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <LCD_sendCommand>
    1a6e:	8f e8       	ldi	r24, 0x8F	; 143
    1a70:	91 e0       	ldi	r25, 0x01	; 1
    1a72:	01 97       	sbiw	r24, 0x01	; 1
    1a74:	f1 f7       	brne	.-4      	; 0x1a72 <LCD_goToXY+0x30>
    1a76:	00 c0       	rjmp	.+0      	; 0x1a78 <LCD_goToXY+0x36>
    1a78:	00 00       	nop
  _delay_us(100); 
}
    1a7a:	0f 90       	pop	r0
    1a7c:	0f 90       	pop	r0
    1a7e:	0f 90       	pop	r0
    1a80:	0f 90       	pop	r0
    1a82:	df 91       	pop	r29
    1a84:	cf 91       	pop	r28
    1a86:	08 95       	ret

00001a88 <buzzerToggle>:
 	
}

static void buzzerToggle() {		
		//Se il buzzer non  impostato dall'esterno o il sistema non  in stato di allarme, il buzzer deve essere spento.
		if (stateBuzzer == OFF){
    1a88:	80 91 7f 08 	lds	r24, 0x087F	; 0x80087f <stateBuzzer>
    1a8c:	81 11       	cpse	r24, r1
    1a8e:	0b c0       	rjmp	.+22     	; 0x1aa6 <buzzerToggle+0x1e>
			//stop the timer
			TCCR2A &= (~(1 << 1 | 1 << 7 | 1 << 8)); 
    1a90:	e0 eb       	ldi	r30, 0xB0	; 176
    1a92:	f0 e0       	ldi	r31, 0x00	; 0
    1a94:	80 81       	ld	r24, Z
    1a96:	8d 77       	andi	r24, 0x7D	; 125
    1a98:	80 83       	st	Z, r24
			TCCR2B &= (~(1 << 1 | 1 << 2));
    1a9a:	e1 eb       	ldi	r30, 0xB1	; 177
    1a9c:	f0 e0       	ldi	r31, 0x00	; 0
    1a9e:	80 81       	ld	r24, Z
    1aa0:	89 7f       	andi	r24, 0xF9	; 249
    1aa2:	80 83       	st	Z, r24
    1aa4:	0d c0       	rjmp	.+26     	; 0x1ac0 <buzzerToggle+0x38>
		}
		else { //Start the PWM
		//Setup the timer
		//COM2A0 & COM2B1 set OC2b on compare match; WGM20 select PWM, Phase correct.
		//DDRD |= (1<<PD3);
		TCCR2A |= (1 << COM2A0 ) | (1 << COM2B1 ) | (1 << WGM20); //COM2A0 & 
    1aa6:	e0 eb       	ldi	r30, 0xB0	; 176
    1aa8:	f0 e0       	ldi	r31, 0x00	; 0
    1aaa:	80 81       	ld	r24, Z
    1aac:	81 66       	ori	r24, 0x61	; 97
    1aae:	80 83       	st	Z, r24
		
		//Select clck/32 (from prescaler); WGM22 is clear, it updates OC2B on 0xFF and not on OCRB.
		TCCR2B |= (1 << CS21) | (1 << CS20); 
    1ab0:	e1 eb       	ldi	r30, 0xB1	; 177
    1ab2:	f0 e0       	ldi	r31, 0x00	; 0
    1ab4:	80 81       	ld	r24, Z
    1ab6:	83 60       	ori	r24, 0x03	; 3
    1ab8:	80 83       	st	Z, r24
		OCR2B = 0xFF - 120;
    1aba:	87 e8       	ldi	r24, 0x87	; 135
    1abc:	80 93 b4 00 	sts	0x00B4, r24	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
		}
		
		if( xSemaphoreTake( xSemaphoreUART, ( TickType_t ) 100 ) == pdTRUE )
    1ac0:	20 e0       	ldi	r18, 0x00	; 0
    1ac2:	44 e6       	ldi	r20, 0x64	; 100
    1ac4:	50 e0       	ldi	r21, 0x00	; 0
    1ac6:	60 e0       	ldi	r22, 0x00	; 0
    1ac8:	70 e0       	ldi	r23, 0x00	; 0
    1aca:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    1ace:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    1ad2:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    1ad6:	81 30       	cpi	r24, 0x01	; 1
    1ad8:	e1 f4       	brne	.+56     	; 0x1b12 <buzzerToggle+0x8a>
		{
			if (stateBuzzer == OFF){
    1ada:	80 91 7f 08 	lds	r24, 0x087F	; 0x80087f <stateBuzzer>
    1ade:	81 11       	cpse	r24, r1
    1ae0:	07 c0       	rjmp	.+14     	; 0x1af0 <buzzerToggle+0x68>
				//UART_sendString("{\"actuator\":\"buzzer\",\"value\":\"off\"}\n");
				UART_sendChar(c_BUZZER_OFF);
    1ae2:	83 e3       	ldi	r24, 0x33	; 51
    1ae4:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
				UART_sendChar('\n');
    1ae8:	8a e0       	ldi	r24, 0x0A	; 10
    1aea:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
    1aee:	06 c0       	rjmp	.+12     	; 0x1afc <buzzerToggle+0x74>
				
			}
			else{
				//UART_sendString("{\"actuator\":\"buzzer\",\"value\":\"on\"}\n");
				UART_sendChar(c_BUZZER_ON);
    1af0:	82 e3       	ldi	r24, 0x32	; 50
    1af2:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
				UART_sendChar('\n');
    1af6:	8a e0       	ldi	r24, 0x0A	; 10
    1af8:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
				
				}
			xSemaphoreGive( xSemaphoreUART );
    1afc:	20 e0       	ldi	r18, 0x00	; 0
    1afe:	40 e0       	ldi	r20, 0x00	; 0
    1b00:	50 e0       	ldi	r21, 0x00	; 0
    1b02:	60 e0       	ldi	r22, 0x00	; 0
    1b04:	70 e0       	ldi	r23, 0x00	; 0
    1b06:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    1b0a:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    1b0e:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
    1b12:	08 95       	ret

00001b14 <fanToggle>:
		}
}

static void fanToggle() {
		//Se il buzzer non  impostato dall'esterno o il sistema non  in stato di allarme, il buzzer deve essere spento.
		if (stateFan == OFF){
    1b14:	80 91 a1 08 	lds	r24, 0x08A1	; 0x8008a1 <stateFan>
    1b18:	81 11       	cpse	r24, r1
    1b1a:	03 c0       	rjmp	.+6      	; 0x1b22 <fanToggle+0xe>
			PORTB &= (~(1 << PB3)); //stop the fan
    1b1c:	2b 98       	cbi	0x05, 3	; 5
			PORTB &=  (~(1 << PB2));
    1b1e:	2a 98       	cbi	0x05, 2	; 5
    1b20:	03 c0       	rjmp	.+6      	; 0x1b28 <fanToggle+0x14>
		}
		else {
			PORTB |= (1 << PB3); //ENABLE FAN
    1b22:	2b 9a       	sbi	0x05, 3	; 5
			PORTB |= (1 << PB2); //5v
    1b24:	2a 9a       	sbi	0x05, 2	; 5
			PORTB &= (~(1<< PB4)); //0v
    1b26:	2c 98       	cbi	0x05, 4	; 5
		}
		if( xSemaphoreTake( xSemaphoreUART, ( TickType_t ) 100 ) == pdTRUE )
    1b28:	20 e0       	ldi	r18, 0x00	; 0
    1b2a:	44 e6       	ldi	r20, 0x64	; 100
    1b2c:	50 e0       	ldi	r21, 0x00	; 0
    1b2e:	60 e0       	ldi	r22, 0x00	; 0
    1b30:	70 e0       	ldi	r23, 0x00	; 0
    1b32:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    1b36:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    1b3a:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    1b3e:	81 30       	cpi	r24, 0x01	; 1
    1b40:	e1 f4       	brne	.+56     	; 0x1b7a <fanToggle+0x66>
		{
			if (stateFan == OFF)
    1b42:	80 91 a1 08 	lds	r24, 0x08A1	; 0x8008a1 <stateFan>
    1b46:	81 11       	cpse	r24, r1
    1b48:	07 c0       	rjmp	.+14     	; 0x1b58 <fanToggle+0x44>
			{
				UART_sendChar(c_FAN_OFF);
    1b4a:	85 e3       	ldi	r24, 0x35	; 53
    1b4c:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
				UART_sendChar('\n');
    1b50:	8a e0       	ldi	r24, 0x0A	; 10
    1b52:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
    1b56:	06 c0       	rjmp	.+12     	; 0x1b64 <fanToggle+0x50>
				
					
			}else {
				UART_sendChar(c_FAN_ON);
    1b58:	84 e3       	ldi	r24, 0x34	; 52
    1b5a:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
				UART_sendChar('\n');
    1b5e:	8a e0       	ldi	r24, 0x0A	; 10
    1b60:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
				
			}
			
			xSemaphoreGive( xSemaphoreUART );
    1b64:	20 e0       	ldi	r18, 0x00	; 0
    1b66:	40 e0       	ldi	r20, 0x00	; 0
    1b68:	50 e0       	ldi	r21, 0x00	; 0
    1b6a:	60 e0       	ldi	r22, 0x00	; 0
    1b6c:	70 e0       	ldi	r23, 0x00	; 0
    1b6e:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    1b72:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    1b76:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
    1b7a:	08 95       	ret

00001b7c <alarmON>:

/* ----------------------------------- FUNCTION DEFINITIONS -------------------------------------*/

static void alarmON() {
				
		alarmState = ON;
    1b7c:	81 e0       	ldi	r24, 0x01	; 1
    1b7e:	80 93 a0 08 	sts	0x08A0, r24	; 0x8008a0 <alarmState>
		PORTD |= 1<<PD2; //toggle on a led on the board
    1b82:	5a 9a       	sbi	0x0b, 2	; 11
		
		if (stateBuzzer == OFF){
    1b84:	80 91 7f 08 	lds	r24, 0x087F	; 0x80087f <stateBuzzer>
    1b88:	81 11       	cpse	r24, r1
    1b8a:	05 c0       	rjmp	.+10     	; 0x1b96 <alarmON+0x1a>
			stateBuzzer = ON;
    1b8c:	81 e0       	ldi	r24, 0x01	; 1
    1b8e:	80 93 7f 08 	sts	0x087F, r24	; 0x80087f <stateBuzzer>
			buzzerToggle();	
    1b92:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <buzzerToggle>
		}
		
		if (stateFan == OFF){
    1b96:	80 91 a1 08 	lds	r24, 0x08A1	; 0x8008a1 <stateFan>
    1b9a:	81 11       	cpse	r24, r1
    1b9c:	05 c0       	rjmp	.+10     	; 0x1ba8 <alarmON+0x2c>
			stateFan = ON;
    1b9e:	81 e0       	ldi	r24, 0x01	; 1
    1ba0:	80 93 a1 08 	sts	0x08A1, r24	; 0x8008a1 <stateFan>
			fanToggle();		
    1ba4:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <fanToggle>
		}
				
		if( xSemaphoreTake( xSemaphoreUART, ( TickType_t ) 1000 ) == pdTRUE )
    1ba8:	20 e0       	ldi	r18, 0x00	; 0
    1baa:	48 ee       	ldi	r20, 0xE8	; 232
    1bac:	53 e0       	ldi	r21, 0x03	; 3
    1bae:	60 e0       	ldi	r22, 0x00	; 0
    1bb0:	70 e0       	ldi	r23, 0x00	; 0
    1bb2:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    1bb6:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    1bba:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    1bbe:	81 30       	cpi	r24, 0x01	; 1
    1bc0:	89 f4       	brne	.+34     	; 0x1be4 <alarmON+0x68>
		{
			UART_sendChar(c_ALARM_ON);
    1bc2:	80 e3       	ldi	r24, 0x30	; 48
    1bc4:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
			UART_sendChar('\n');
    1bc8:	8a e0       	ldi	r24, 0x0A	; 10
    1bca:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
			xSemaphoreGive( xSemaphoreUART );
    1bce:	20 e0       	ldi	r18, 0x00	; 0
    1bd0:	40 e0       	ldi	r20, 0x00	; 0
    1bd2:	50 e0       	ldi	r21, 0x00	; 0
    1bd4:	60 e0       	ldi	r22, 0x00	; 0
    1bd6:	70 e0       	ldi	r23, 0x00	; 0
    1bd8:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    1bdc:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    1be0:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
    1be4:	08 95       	ret

00001be6 <alarmOFF>:
			
}

static void alarmOFF() {
		
		alarmState = OFF;
    1be6:	10 92 a0 08 	sts	0x08A0, r1	; 0x8008a0 <alarmState>
		PORTD &= (~(1<< PD2)); //toggle off the led on the board
    1bea:	5a 98       	cbi	0x0b, 2	; 11
		
		if (stateBuzzer == ON){
    1bec:	80 91 7f 08 	lds	r24, 0x087F	; 0x80087f <stateBuzzer>
    1bf0:	81 30       	cpi	r24, 0x01	; 1
    1bf2:	21 f4       	brne	.+8      	; 0x1bfc <alarmOFF+0x16>
			stateBuzzer = OFF;	
    1bf4:	10 92 7f 08 	sts	0x087F, r1	; 0x80087f <stateBuzzer>
			buzzerToggle();
    1bf8:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <buzzerToggle>
		}
		
		if (stateFan == ON){
    1bfc:	80 91 a1 08 	lds	r24, 0x08A1	; 0x8008a1 <stateFan>
    1c00:	81 30       	cpi	r24, 0x01	; 1
    1c02:	21 f4       	brne	.+8      	; 0x1c0c <alarmOFF+0x26>
			stateFan = OFF;
    1c04:	10 92 a1 08 	sts	0x08A1, r1	; 0x8008a1 <stateFan>
			fanToggle();	
    1c08:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <fanToggle>
		}
				
		if( xSemaphoreTake( xSemaphoreUART, ( TickType_t ) 100 ) == pdTRUE )
    1c0c:	20 e0       	ldi	r18, 0x00	; 0
    1c0e:	44 e6       	ldi	r20, 0x64	; 100
    1c10:	50 e0       	ldi	r21, 0x00	; 0
    1c12:	60 e0       	ldi	r22, 0x00	; 0
    1c14:	70 e0       	ldi	r23, 0x00	; 0
    1c16:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    1c1a:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    1c1e:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    1c22:	81 30       	cpi	r24, 0x01	; 1
    1c24:	89 f4       	brne	.+34     	; 0x1c48 <alarmOFF+0x62>
		{
			UART_sendChar(c_ALARM_OFF);
    1c26:	81 e3       	ldi	r24, 0x31	; 49
    1c28:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
			UART_sendChar('\n');
    1c2c:	8a e0       	ldi	r24, 0x0A	; 10
    1c2e:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
			xSemaphoreGive( xSemaphoreUART );
    1c32:	20 e0       	ldi	r18, 0x00	; 0
    1c34:	40 e0       	ldi	r20, 0x00	; 0
    1c36:	50 e0       	ldi	r21, 0x00	; 0
    1c38:	60 e0       	ldi	r22, 0x00	; 0
    1c3a:	70 e0       	ldi	r23, 0x00	; 0
    1c3c:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    1c40:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    1c44:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
    1c48:	08 95       	ret

00001c4a <serialFromISRTask>:
	LCD_sendData(' ');
	LCD_sendData(' ');
	LCD_sendData(' ');
 }

void serialFromISRTask (void *parameters) {
    1c4a:	cf 93       	push	r28
    1c4c:	df 93       	push	r29
    1c4e:	00 d0       	rcall	.+0      	; 0x1c50 <serialFromISRTask+0x6>
    1c50:	cd b7       	in	r28, 0x3d	; 61
    1c52:	de b7       	in	r29, 0x3e	; 62
					alarmOFF();	
				}
				break;
			case BUZZER_ON:
				if (stateBuzzer == OFF){
					stateBuzzer = ON;
    1c54:	11 e0       	ldi	r17, 0x01	; 1
	char *pcString; //where the queue receive the msg.
	uint8_t commandReceived;
	
	for( ;; ) {
		/* Block on the queue to wait for data to arrive. */
		xQueueReceive(xCharQueue, &pcString, portMAX_DELAY);
    1c56:	20 e0       	ldi	r18, 0x00	; 0
    1c58:	4f ef       	ldi	r20, 0xFF	; 255
    1c5a:	5f ef       	ldi	r21, 0xFF	; 255
    1c5c:	be 01       	movw	r22, r28
    1c5e:	6f 5f       	subi	r22, 0xFF	; 255
    1c60:	7f 4f       	sbci	r23, 0xFF	; 255
    1c62:	80 91 9a 08 	lds	r24, 0x089A	; 0x80089a <xCharQueue>
    1c66:	90 91 9b 08 	lds	r25, 0x089B	; 0x80089b <xCharQueue+0x1>
    1c6a:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
		
		commandReceived = pcString - ASCII_OFFSET; //Gives the number from exadecimal to Ascii
		
		switch (commandReceived) {
    1c6e:	89 81       	ldd	r24, Y+1	; 0x01
    1c70:	9a 81       	ldd	r25, Y+2	; 0x02
    1c72:	c0 97       	sbiw	r24, 0x30	; 48
    1c74:	99 27       	eor	r25, r25
    1c76:	82 30       	cpi	r24, 0x02	; 2
    1c78:	91 05       	cpc	r25, r1
    1c7a:	d9 f0       	breq	.+54     	; 0x1cb2 <serialFromISRTask+0x68>
    1c7c:	2c f4       	brge	.+10     	; 0x1c88 <serialFromISRTask+0x3e>
    1c7e:	00 97       	sbiw	r24, 0x00	; 0
    1c80:	51 f0       	breq	.+20     	; 0x1c96 <serialFromISRTask+0x4c>
    1c82:	01 97       	sbiw	r24, 0x01	; 1
    1c84:	79 f0       	breq	.+30     	; 0x1ca4 <serialFromISRTask+0x5a>
    1c86:	e7 cf       	rjmp	.-50     	; 0x1c56 <serialFromISRTask+0xc>
    1c88:	84 30       	cpi	r24, 0x04	; 4
    1c8a:	91 05       	cpc	r25, r1
    1c8c:	21 f1       	breq	.+72     	; 0x1cd6 <serialFromISRTask+0x8c>
    1c8e:	d4 f0       	brlt	.+52     	; 0x1cc4 <serialFromISRTask+0x7a>
    1c90:	05 97       	sbiw	r24, 0x05	; 5
    1c92:	51 f1       	breq	.+84     	; 0x1ce8 <serialFromISRTask+0x9e>
    1c94:	e0 cf       	rjmp	.-64     	; 0x1c56 <serialFromISRTask+0xc>
			case ALARM_ON:
				if (alarmState == OFF){
    1c96:	80 91 a0 08 	lds	r24, 0x08A0	; 0x8008a0 <alarmState>
    1c9a:	81 11       	cpse	r24, r1
    1c9c:	dc cf       	rjmp	.-72     	; 0x1c56 <serialFromISRTask+0xc>
					alarmON();	
    1c9e:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <alarmON>
    1ca2:	d9 cf       	rjmp	.-78     	; 0x1c56 <serialFromISRTask+0xc>
				}
				break;
			case ALARM_OFF:
				if (alarmState == ON){
    1ca4:	80 91 a0 08 	lds	r24, 0x08A0	; 0x8008a0 <alarmState>
    1ca8:	81 30       	cpi	r24, 0x01	; 1
    1caa:	a9 f6       	brne	.-86     	; 0x1c56 <serialFromISRTask+0xc>
					alarmOFF();	
    1cac:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <alarmOFF>
    1cb0:	d2 cf       	rjmp	.-92     	; 0x1c56 <serialFromISRTask+0xc>
				}
				break;
			case BUZZER_ON:
				if (stateBuzzer == OFF){
    1cb2:	80 91 7f 08 	lds	r24, 0x087F	; 0x80087f <stateBuzzer>
    1cb6:	81 11       	cpse	r24, r1
    1cb8:	ce cf       	rjmp	.-100    	; 0x1c56 <serialFromISRTask+0xc>
					stateBuzzer = ON;
    1cba:	10 93 7f 08 	sts	0x087F, r17	; 0x80087f <stateBuzzer>
					buzzerToggle();	
    1cbe:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <buzzerToggle>
    1cc2:	c9 cf       	rjmp	.-110    	; 0x1c56 <serialFromISRTask+0xc>
				}
				break;
			case BUZZER_OFF:
				if (stateBuzzer == ON){
    1cc4:	80 91 7f 08 	lds	r24, 0x087F	; 0x80087f <stateBuzzer>
    1cc8:	81 30       	cpi	r24, 0x01	; 1
    1cca:	29 f6       	brne	.-118    	; 0x1c56 <serialFromISRTask+0xc>
					stateBuzzer = OFF;
    1ccc:	10 92 7f 08 	sts	0x087F, r1	; 0x80087f <stateBuzzer>
					buzzerToggle();
    1cd0:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <buzzerToggle>
    1cd4:	c0 cf       	rjmp	.-128    	; 0x1c56 <serialFromISRTask+0xc>
				}
				break;
			case FAN_ON:
				if (stateFan == OFF){
    1cd6:	80 91 a1 08 	lds	r24, 0x08A1	; 0x8008a1 <stateFan>
    1cda:	81 11       	cpse	r24, r1
    1cdc:	bc cf       	rjmp	.-136    	; 0x1c56 <serialFromISRTask+0xc>
					stateFan = ON;
    1cde:	10 93 a1 08 	sts	0x08A1, r17	; 0x8008a1 <stateFan>
					fanToggle();	
    1ce2:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <fanToggle>
    1ce6:	b7 cf       	rjmp	.-146    	; 0x1c56 <serialFromISRTask+0xc>
				}
				break;
			case FAN_OFF:
				if (stateFan == ON){
    1ce8:	80 91 a1 08 	lds	r24, 0x08A1	; 0x8008a1 <stateFan>
    1cec:	81 30       	cpi	r24, 0x01	; 1
    1cee:	09 f0       	breq	.+2      	; 0x1cf2 <serialFromISRTask+0xa8>
    1cf0:	b2 cf       	rjmp	.-156    	; 0x1c56 <serialFromISRTask+0xc>
					stateFan = OFF;
    1cf2:	10 92 a1 08 	sts	0x08A1, r1	; 0x8008a1 <stateFan>
					fanToggle();	
    1cf6:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <fanToggle>
    1cfa:	ad cf       	rjmp	.-166    	; 0x1c56 <serialFromISRTask+0xc>

00001cfc <temperatureReadTask>:
 		}
		
	}
}

void temperatureReadTask(void* parameter) {
    1cfc:	cf 93       	push	r28
    1cfe:	df 93       	push	r29
    1d00:	00 d0       	rcall	.+0      	; 0x1d02 <temperatureReadTask+0x6>
    1d02:	00 d0       	rcall	.+0      	; 0x1d04 <temperatureReadTask+0x8>
    1d04:	cd b7       	in	r28, 0x3d	; 61
    1d06:	de b7       	in	r29, 0x3e	; 62
	
}

static void ADC_setupToReadTemp(void){
	DDRC&=~(1<<0);
	ADCSRA = 0x87; //make ADC enagle and select ck/128
    1d08:	0f 2e       	mov	r0, r31
    1d0a:	fa e7       	ldi	r31, 0x7A	; 122
    1d0c:	ef 2e       	mov	r14, r31
    1d0e:	f1 2c       	mov	r15, r1
    1d10:	f0 2d       	mov	r31, r0
    1d12:	0f 2e       	mov	r0, r31
    1d14:	f7 e8       	ldi	r31, 0x87	; 135
    1d16:	cf 2e       	mov	r12, r31
    1d18:	f0 2d       	mov	r31, r0
	ADMUX = 0b11000000; //adc0
    1d1a:	0c e7       	ldi	r16, 0x7C	; 124
    1d1c:	10 e0       	ldi	r17, 0x00	; 0
    1d1e:	0f 2e       	mov	r0, r31
    1d20:	f0 ec       	ldi	r31, 0xC0	; 192
    1d22:	df 2e       	mov	r13, r31
    1d24:	f0 2d       	mov	r31, r0
	//float threshold = THRESHOLD_TEMPERATURE;
	float temperature;
	
	for (;;){
		
		vTaskSuspend(temperatureReadTaskHandle);
    1d26:	80 91 9c 08 	lds	r24, 0x089C	; 0x80089c <temperatureReadTaskHandle>
    1d2a:	90 91 9d 08 	lds	r25, 0x089D	; 0x80089d <temperatureReadTaskHandle+0x1>
    1d2e:	0e 94 58 09 	call	0x12b0	; 0x12b0 <vTaskSuspend>
		
		if( xSemaphoreADC != NULL )
    1d32:	80 91 94 08 	lds	r24, 0x0894	; 0x800894 <xSemaphoreADC>
    1d36:	90 91 95 08 	lds	r25, 0x0895	; 0x800895 <xSemaphoreADC+0x1>
    1d3a:	00 97       	sbiw	r24, 0x00	; 0
    1d3c:	09 f4       	brne	.+2      	; 0x1d40 <temperatureReadTask+0x44>
    1d3e:	4f c0       	rjmp	.+158    	; 0x1dde <temperatureReadTask+0xe2>
		{
        /* See if we can obtain the semaphore.  If the semaphore is not
        available wait 10 ticks to see if it becomes free. */
			if( xSemaphoreTake( xSemaphoreADC, ( TickType_t ) 1000 ) == pdTRUE )
    1d40:	20 e0       	ldi	r18, 0x00	; 0
    1d42:	48 ee       	ldi	r20, 0xE8	; 232
    1d44:	53 e0       	ldi	r21, 0x03	; 3
    1d46:	60 e0       	ldi	r22, 0x00	; 0
    1d48:	70 e0       	ldi	r23, 0x00	; 0
    1d4a:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    1d4e:	81 30       	cpi	r24, 0x01	; 1
    1d50:	09 f0       	breq	.+2      	; 0x1d54 <temperatureReadTask+0x58>
    1d52:	45 c0       	rjmp	.+138    	; 0x1dde <temperatureReadTask+0xe2>
	DDRB |= (1 << 3) | (1 << 2) | (1 << 4); //make port b output for PB3, PB2, PB4
	
}

static void ADC_setupToReadTemp(void){
	DDRC&=~(1<<0);
    1d54:	38 98       	cbi	0x07, 0	; 7
	ADCSRA = 0x87; //make ADC enagle and select ck/128
    1d56:	f7 01       	movw	r30, r14
    1d58:	c0 82       	st	Z, r12
	ADMUX = 0b11000000; //adc0
    1d5a:	f8 01       	movw	r30, r16
    1d5c:	d0 82       	st	Z, r13
			if( xSemaphoreTake( xSemaphoreADC, ( TickType_t ) 1000 ) == pdTRUE )
			{
				/* We were able to obtain the semaphore and can now access the
				shared resource. */
				ADC_setupToReadTemp();
				vTaskDelay(10);
    1d5e:	8a e0       	ldi	r24, 0x0A	; 10
    1d60:	90 e0       	ldi	r25, 0x00	; 0
    1d62:	0e 94 9f 08 	call	0x113e	; 0x113e <vTaskDelay>
				float tempTemperature = ADC_read();
    1d66:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <ADC_read>
				temperature = (tempTemperature*10/93)-50;
    1d6a:	20 e0       	ldi	r18, 0x00	; 0
    1d6c:	30 e0       	ldi	r19, 0x00	; 0
    1d6e:	40 e2       	ldi	r20, 0x20	; 32
    1d70:	51 e4       	ldi	r21, 0x41	; 65
    1d72:	0e 94 43 15 	call	0x2a86	; 0x2a86 <__mulsf3>
    1d76:	20 e0       	ldi	r18, 0x00	; 0
    1d78:	30 e0       	ldi	r19, 0x00	; 0
    1d7a:	4a eb       	ldi	r20, 0xBA	; 186
    1d7c:	52 e4       	ldi	r21, 0x42	; 66
    1d7e:	0e 94 0f 14 	call	0x281e	; 0x281e <__divsf3>
    1d82:	20 e0       	ldi	r18, 0x00	; 0
    1d84:	30 e0       	ldi	r19, 0x00	; 0
    1d86:	48 e4       	ldi	r20, 0x48	; 72
    1d88:	52 e4       	ldi	r21, 0x42	; 66
    1d8a:	0e 94 a2 13 	call	0x2744	; 0x2744 <__subsf3>
    1d8e:	69 83       	std	Y+1, r22	; 0x01
    1d90:	7a 83       	std	Y+2, r23	; 0x02
    1d92:	8b 83       	std	Y+3, r24	; 0x03
    1d94:	9c 83       	std	Y+4, r25	; 0x04
				
				/* We have finished accessing the shared resource.  Release the
				semaphore. */
				xSemaphoreGive( xSemaphoreADC );
    1d96:	20 e0       	ldi	r18, 0x00	; 0
    1d98:	40 e0       	ldi	r20, 0x00	; 0
    1d9a:	50 e0       	ldi	r21, 0x00	; 0
    1d9c:	60 e0       	ldi	r22, 0x00	; 0
    1d9e:	70 e0       	ldi	r23, 0x00	; 0
    1da0:	80 91 94 08 	lds	r24, 0x0894	; 0x800894 <xSemaphoreADC>
    1da4:	90 91 95 08 	lds	r25, 0x0895	; 0x800895 <xSemaphoreADC+0x1>
    1da8:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
				if (temperature > THRESHOLD_TEMPERATURE && alarmState == OFF) {
    1dac:	20 e0       	ldi	r18, 0x00	; 0
    1dae:	30 e0       	ldi	r19, 0x00	; 0
    1db0:	44 e6       	ldi	r20, 0x64	; 100
    1db2:	52 e4       	ldi	r21, 0x42	; 66
    1db4:	69 81       	ldd	r22, Y+1	; 0x01
    1db6:	7a 81       	ldd	r23, Y+2	; 0x02
    1db8:	8b 81       	ldd	r24, Y+3	; 0x03
    1dba:	9c 81       	ldd	r25, Y+4	; 0x04
    1dbc:	0e 94 3e 15 	call	0x2a7c	; 0x2a7c <__gesf2>
    1dc0:	18 16       	cp	r1, r24
    1dc2:	3c f4       	brge	.+14     	; 0x1dd2 <temperatureReadTask+0xd6>
    1dc4:	80 91 a0 08 	lds	r24, 0x08A0	; 0x8008a0 <alarmState>
    1dc8:	81 11       	cpse	r24, r1
    1dca:	03 c0       	rjmp	.+6      	; 0x1dd2 <temperatureReadTask+0xd6>
					alarmON();
    1dcc:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <alarmON>
    1dd0:	06 c0       	rjmp	.+12     	; 0x1dde <temperatureReadTask+0xe2>
				}
				else {
					if (alarmState == ON){
    1dd2:	80 91 a0 08 	lds	r24, 0x08A0	; 0x8008a0 <alarmState>
    1dd6:	81 30       	cpi	r24, 0x01	; 1
    1dd8:	11 f4       	brne	.+4      	; 0x1dde <temperatureReadTask+0xe2>
					alarmOFF();
    1dda:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <alarmOFF>
			{
				/* We could not obtain the semaphore and can therefore not access
				the shared resource safely. */
			}
		}			
		if( xQueueTemperatureSendings != 0 )
    1dde:	80 91 8a 08 	lds	r24, 0x088A	; 0x80088a <xQueueTemperatureSendings>
    1de2:	90 91 8b 08 	lds	r25, 0x088B	; 0x80088b <xQueueTemperatureSendings+0x1>
    1de6:	00 97       	sbiw	r24, 0x00	; 0
    1de8:	09 f4       	brne	.+2      	; 0x1dec <temperatureReadTask+0xf0>
    1dea:	9d cf       	rjmp	.-198    	; 0x1d26 <temperatureReadTask+0x2a>
		{
        /* Send an unsigned long.  Wait for 10 ticks for space to become
        available if necessary. */
			if( xQueueSend( xQueueTemperatureSendings,
    1dec:	20 e0       	ldi	r18, 0x00	; 0
    1dee:	48 ee       	ldi	r20, 0xE8	; 232
    1df0:	53 e0       	ldi	r21, 0x03	; 3
    1df2:	be 01       	movw	r22, r28
    1df4:	6f 5f       	subi	r22, 0xFF	; 255
    1df6:	7f 4f       	sbci	r23, 0xFF	; 255
    1df8:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
    1dfc:	94 cf       	rjmp	.-216    	; 0x1d26 <temperatureReadTask+0x2a>

00001dfe <airReadTask>:
			}	
		}
	}
}

void airReadTask(void* parameter) {
    1dfe:	cf 93       	push	r28
    1e00:	df 93       	push	r29
    1e02:	00 d0       	rcall	.+0      	; 0x1e04 <airReadTask+0x6>
    1e04:	00 d0       	rcall	.+0      	; 0x1e06 <airReadTask+0x8>
    1e06:	cd b7       	in	r28, 0x3d	; 61
    1e08:	de b7       	in	r29, 0x3e	; 62
	
}

static void ADC_setupToReadAir(void){
	DDRC&=~(1<<1);
	ADCSRA = 0x87; //make ADC enagle and select ck/128
    1e0a:	0f 2e       	mov	r0, r31
    1e0c:	fa e7       	ldi	r31, 0x7A	; 122
    1e0e:	ef 2e       	mov	r14, r31
    1e10:	f1 2c       	mov	r15, r1
    1e12:	f0 2d       	mov	r31, r0
    1e14:	0f 2e       	mov	r0, r31
    1e16:	f7 e8       	ldi	r31, 0x87	; 135
    1e18:	cf 2e       	mov	r12, r31
    1e1a:	f0 2d       	mov	r31, r0
	ADMUX = 0b01000001; //adc1
    1e1c:	0c e7       	ldi	r16, 0x7C	; 124
    1e1e:	10 e0       	ldi	r17, 0x00	; 0
    1e20:	0f 2e       	mov	r0, r31
    1e22:	f1 e4       	ldi	r31, 0x41	; 65
    1e24:	df 2e       	mov	r13, r31
    1e26:	f0 2d       	mov	r31, r0
	
	float air;
	
	for (;;)
 	{
 		vTaskSuspend(NULL);
    1e28:	80 e0       	ldi	r24, 0x00	; 0
    1e2a:	90 e0       	ldi	r25, 0x00	; 0
    1e2c:	0e 94 58 09 	call	0x12b0	; 0x12b0 <vTaskSuspend>
		
		if( xSemaphoreADC != NULL )
    1e30:	80 91 94 08 	lds	r24, 0x0894	; 0x800894 <xSemaphoreADC>
    1e34:	90 91 95 08 	lds	r25, 0x0895	; 0x800895 <xSemaphoreADC+0x1>
    1e38:	00 97       	sbiw	r24, 0x00	; 0
    1e3a:	e1 f1       	breq	.+120    	; 0x1eb4 <airReadTask+0xb6>
		{
			/* See if we can obtain the semaphore.  If the semaphore is not
			available wait 10 ticks to see if it becomes free. */
 			if( xSemaphoreTake( xSemaphoreADC, ( TickType_t ) 1000 ) == pdTRUE )
    1e3c:	20 e0       	ldi	r18, 0x00	; 0
    1e3e:	48 ee       	ldi	r20, 0xE8	; 232
    1e40:	53 e0       	ldi	r21, 0x03	; 3
    1e42:	60 e0       	ldi	r22, 0x00	; 0
    1e44:	70 e0       	ldi	r23, 0x00	; 0
    1e46:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    1e4a:	81 30       	cpi	r24, 0x01	; 1
    1e4c:	99 f5       	brne	.+102    	; 0x1eb4 <airReadTask+0xb6>
	ADMUX = 0b11000000; //adc0
	
}

static void ADC_setupToReadAir(void){
	DDRC&=~(1<<1);
    1e4e:	39 98       	cbi	0x07, 1	; 7
	ADCSRA = 0x87; //make ADC enagle and select ck/128
    1e50:	f7 01       	movw	r30, r14
    1e52:	c0 82       	st	Z, r12
	ADMUX = 0b01000001; //adc1
    1e54:	f8 01       	movw	r30, r16
    1e56:	d0 82       	st	Z, r13
			{
				/* We were able to obtain the semaphore and can now access the
				shared resource. */

				ADC_setupToReadAir();
				vTaskDelay(10);
    1e58:	8a e0       	ldi	r24, 0x0A	; 10
    1e5a:	90 e0       	ldi	r25, 0x00	; 0
    1e5c:	0e 94 9f 08 	call	0x113e	; 0x113e <vTaskDelay>
				air = ADC_read();
    1e60:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <ADC_read>
    1e64:	69 83       	std	Y+1, r22	; 0x01
    1e66:	7a 83       	std	Y+2, r23	; 0x02
    1e68:	8b 83       	std	Y+3, r24	; 0x03
    1e6a:	9c 83       	std	Y+4, r25	; 0x04
			

				/* We have finished accessing the shared resource.  Release the
				semaphore. */
				xSemaphoreGive( xSemaphoreADC );
    1e6c:	20 e0       	ldi	r18, 0x00	; 0
    1e6e:	40 e0       	ldi	r20, 0x00	; 0
    1e70:	50 e0       	ldi	r21, 0x00	; 0
    1e72:	60 e0       	ldi	r22, 0x00	; 0
    1e74:	70 e0       	ldi	r23, 0x00	; 0
    1e76:	80 91 94 08 	lds	r24, 0x0894	; 0x800894 <xSemaphoreADC>
    1e7a:	90 91 95 08 	lds	r25, 0x0895	; 0x800895 <xSemaphoreADC+0x1>
    1e7e:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
				
				if (air > THRESHOLD_AIR && alarmState == OFF) {
    1e82:	20 e0       	ldi	r18, 0x00	; 0
    1e84:	30 e0       	ldi	r19, 0x00	; 0
    1e86:	48 e4       	ldi	r20, 0x48	; 72
    1e88:	53 e4       	ldi	r21, 0x43	; 67
    1e8a:	69 81       	ldd	r22, Y+1	; 0x01
    1e8c:	7a 81       	ldd	r23, Y+2	; 0x02
    1e8e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e90:	9c 81       	ldd	r25, Y+4	; 0x04
    1e92:	0e 94 3e 15 	call	0x2a7c	; 0x2a7c <__gesf2>
    1e96:	18 16       	cp	r1, r24
    1e98:	3c f4       	brge	.+14     	; 0x1ea8 <airReadTask+0xaa>
    1e9a:	80 91 a0 08 	lds	r24, 0x08A0	; 0x8008a0 <alarmState>
    1e9e:	81 11       	cpse	r24, r1
    1ea0:	03 c0       	rjmp	.+6      	; 0x1ea8 <airReadTask+0xaa>
					alarmON();
    1ea2:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <alarmON>
    1ea6:	06 c0       	rjmp	.+12     	; 0x1eb4 <airReadTask+0xb6>
				}
				else {
					if (alarmState == ON){
    1ea8:	80 91 a0 08 	lds	r24, 0x08A0	; 0x8008a0 <alarmState>
    1eac:	81 30       	cpi	r24, 0x01	; 1
    1eae:	11 f4       	brne	.+4      	; 0x1eb4 <airReadTask+0xb6>
						alarmOFF();
    1eb0:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <alarmOFF>
				/* We could not obtain the semaphore and can therefore not access
				the shared resource safely. */
			}
		}
		
		if( xQueueAirSendings != 0 )
    1eb4:	80 91 9e 08 	lds	r24, 0x089E	; 0x80089e <xQueueAirSendings>
    1eb8:	90 91 9f 08 	lds	r25, 0x089F	; 0x80089f <xQueueAirSendings+0x1>
    1ebc:	00 97       	sbiw	r24, 0x00	; 0
    1ebe:	09 f4       	brne	.+2      	; 0x1ec2 <airReadTask+0xc4>
    1ec0:	b3 cf       	rjmp	.-154    	; 0x1e28 <airReadTask+0x2a>
		{
			/* Send an unsigned long.  Wait for 10 ticks for space to become
			available if necessary. */
			if( xQueueSend( xQueueAirSendings,
    1ec2:	20 e0       	ldi	r18, 0x00	; 0
    1ec4:	48 ee       	ldi	r20, 0xE8	; 232
    1ec6:	53 e0       	ldi	r21, 0x03	; 3
    1ec8:	be 01       	movw	r22, r28
    1eca:	6f 5f       	subi	r22, 0xFF	; 255
    1ecc:	7f 4f       	sbci	r23, 0xFF	; 255
    1ece:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
    1ed2:	aa cf       	rjmp	.-172    	; 0x1e28 <airReadTask+0x2a>

00001ed4 <vTimerCallback>:
}//airSendTask

void vTimerCallback(TimerHandle_t xTimerReadings)
 {
	//LCD_print("test");
	vTaskResume(temperatureReadTaskHandle);
    1ed4:	80 91 9c 08 	lds	r24, 0x089C	; 0x80089c <temperatureReadTaskHandle>
    1ed8:	90 91 9d 08 	lds	r25, 0x089D	; 0x80089d <temperatureReadTaskHandle+0x1>
    1edc:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <vTaskResume>
	
	vTaskResume (AirReadTaskHandle);  
    1ee0:	80 91 98 08 	lds	r24, 0x0898	; 0x800898 <AirReadTaskHandle>
    1ee4:	90 91 99 08 	lds	r25, 0x0899	; 0x800899 <AirReadTaskHandle+0x1>
    1ee8:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <vTaskResume>
    1eec:	08 95       	ret

00001eee <__vector_18>:
void vTimerCallback(TimerHandle_t xTimerReadings); //called when timer elapse

/* ----------------------------------- ISR -------------------------------------*/

//INTERRUPT SERVICE ROUTINE
ISR (USART_RX_vect) {
    1eee:	1f 92       	push	r1
    1ef0:	0f 92       	push	r0
    1ef2:	0f b6       	in	r0, 0x3f	; 63
    1ef4:	0f 92       	push	r0
    1ef6:	11 24       	eor	r1, r1
    1ef8:	2f 93       	push	r18
    1efa:	3f 93       	push	r19
    1efc:	4f 93       	push	r20
    1efe:	5f 93       	push	r21
    1f00:	6f 93       	push	r22
    1f02:	7f 93       	push	r23
    1f04:	8f 93       	push	r24
    1f06:	9f 93       	push	r25
    1f08:	af 93       	push	r26
    1f0a:	bf 93       	push	r27
    1f0c:	ef 93       	push	r30
    1f0e:	ff 93       	push	r31
    1f10:	cf 93       	push	r28
    1f12:	df 93       	push	r29
    1f14:	00 d0       	rcall	.+0      	; 0x1f16 <__vector_18+0x28>
    1f16:	cd b7       	in	r28, 0x3d	; 61
    1f18:	de b7       	in	r29, 0x3e	; 62
	
	signed char cChar;
	
	cChar = UDR0;
    1f1a:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
    1f1e:	89 83       	std	Y+1, r24	; 0x01
	//We need it for the task YIELD
	BaseType_t xHigherPriorityTaskWoken;
	xHigherPriorityTaskWoken = pdFALSE;
    1f20:	1a 82       	std	Y+2, r1	; 0x02
	
	//The queue is useful exchange message with the other task
	xQueueSendFromISR( xCharQueue, &cChar, &xHigherPriorityTaskWoken );
    1f22:	20 e0       	ldi	r18, 0x00	; 0
    1f24:	ae 01       	movw	r20, r28
    1f26:	4e 5f       	subi	r20, 0xFE	; 254
    1f28:	5f 4f       	sbci	r21, 0xFF	; 255
    1f2a:	be 01       	movw	r22, r28
    1f2c:	6f 5f       	subi	r22, 0xFF	; 255
    1f2e:	7f 4f       	sbci	r23, 0xFF	; 255
    1f30:	80 91 9a 08 	lds	r24, 0x089A	; 0x80089a <xCharQueue>
    1f34:	90 91 9b 08 	lds	r25, 0x089B	; 0x80089b <xCharQueue+0x1>
    1f38:	0e 94 3b 04 	call	0x876	; 0x876 <xQueueGenericSendFromISR>
	
	//TaskYIELD in Atmega328p.
	if( xHigherPriorityTaskWoken != pdFALSE ) {
    1f3c:	8a 81       	ldd	r24, Y+2	; 0x02
    1f3e:	81 11       	cpse	r24, r1
		taskYIELD();
    1f40:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
	}
	
}
    1f44:	0f 90       	pop	r0
    1f46:	0f 90       	pop	r0
    1f48:	df 91       	pop	r29
    1f4a:	cf 91       	pop	r28
    1f4c:	ff 91       	pop	r31
    1f4e:	ef 91       	pop	r30
    1f50:	bf 91       	pop	r27
    1f52:	af 91       	pop	r26
    1f54:	9f 91       	pop	r25
    1f56:	8f 91       	pop	r24
    1f58:	7f 91       	pop	r23
    1f5a:	6f 91       	pop	r22
    1f5c:	5f 91       	pop	r21
    1f5e:	4f 91       	pop	r20
    1f60:	3f 91       	pop	r19
    1f62:	2f 91       	pop	r18
    1f64:	0f 90       	pop	r0
    1f66:	0f be       	out	0x3f, r0	; 63
    1f68:	0f 90       	pop	r0
    1f6a:	1f 90       	pop	r1
    1f6c:	18 95       	reti

00001f6e <UART_sendString>:
	// Setup data format: 8 bit data, 1 stop bit
	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);
}

void UART_sendString(const char* data)
{
    1f6e:	cf 93       	push	r28
    1f70:	df 93       	push	r29
    1f72:	ec 01       	movw	r28, r24
	//Send character until null terminator
	while (*data != '\0')
    1f74:	88 81       	ld	r24, Y
    1f76:	88 23       	and	r24, r24
    1f78:	31 f0       	breq	.+12     	; 0x1f86 <UART_sendString+0x18>
    1f7a:	21 96       	adiw	r28, 0x01	; 1
	{
		UART_sendChar(*data);
    1f7c:	0e 94 c9 0c 	call	0x1992	; 0x1992 <UART_sendChar>
}

void UART_sendString(const char* data)
{
	//Send character until null terminator
	while (*data != '\0')
    1f80:	89 91       	ld	r24, Y+
    1f82:	81 11       	cpse	r24, r1
    1f84:	fb cf       	rjmp	.-10     	; 0x1f7c <UART_sendString+0xe>
	{
		UART_sendChar(*data);
		data++;
	}
}
    1f86:	df 91       	pop	r29
    1f88:	cf 91       	pop	r28
    1f8a:	08 95       	ret

00001f8c <generateArrayTemperature>:

	return (ADCL+(ADCH<<8));
	//return ADC;
}

char* generateArrayTemperature(unsigned char d1, unsigned char d2, unsigned char d3, unsigned char d4){
    1f8c:	0f 93       	push	r16
    1f8e:	1f 93       	push	r17
    1f90:	cf 93       	push	r28
    1f92:	df 93       	push	r29
    1f94:	cd b7       	in	r28, 0x3d	; 61
    1f96:	de b7       	in	r29, 0x3e	; 62
    1f98:	a0 97       	sbiw	r28, 0x20	; 32
    1f9a:	0f b6       	in	r0, 0x3f	; 63
    1f9c:	f8 94       	cli
    1f9e:	de bf       	out	0x3e, r29	; 62
    1fa0:	0f be       	out	0x3f, r0	; 63
    1fa2:	cd bf       	out	0x3d, r28	; 61
	//Handwriting the array of sending temperature
	const char jsonDataTemperatureTemp [] = "{\"sensor\":\"temperature\",\"value\"";
    1fa4:	90 e2       	ldi	r25, 0x20	; 32
    1fa6:	e2 e1       	ldi	r30, 0x12	; 18
    1fa8:	f1 e0       	ldi	r31, 0x01	; 1
    1faa:	de 01       	movw	r26, r28
    1fac:	11 96       	adiw	r26, 0x01	; 1
    1fae:	01 90       	ld	r0, Z+
    1fb0:	0d 92       	st	X+, r0
    1fb2:	9a 95       	dec	r25
    1fb4:	e1 f7       	brne	.-8      	; 0x1fae <generateArrayTemperature+0x22>
    1fb6:	fe 01       	movw	r30, r28
    1fb8:	31 96       	adiw	r30, 0x01	; 1
    1fba:	a9 e4       	ldi	r26, 0x49	; 73
    1fbc:	b8 e0       	ldi	r27, 0x08	; 8
    1fbe:	8e 01       	movw	r16, r28
    1fc0:	0f 5d       	subi	r16, 0xDF	; 223
    1fc2:	1f 4f       	sbci	r17, 0xFF	; 255
	int len1 = sizeof(jsonDataTemperatureTemp)/sizeof(jsonDataTemperatureTemp[0]);
	static char jsonDataTemperatureTempT2 [SIZE_ARRAY];
	
	for (int i = 0; i<len1; i++){
		jsonDataTemperatureTempT2[i] = jsonDataTemperatureTemp[i];
    1fc4:	91 91       	ld	r25, Z+
    1fc6:	9d 93       	st	X+, r25
	//Handwriting the array of sending temperature
	const char jsonDataTemperatureTemp [] = "{\"sensor\":\"temperature\",\"value\"";
	int len1 = sizeof(jsonDataTemperatureTemp)/sizeof(jsonDataTemperatureTemp[0]);
	static char jsonDataTemperatureTempT2 [SIZE_ARRAY];
	
	for (int i = 0; i<len1; i++){
    1fc8:	e0 17       	cp	r30, r16
    1fca:	f1 07       	cpc	r31, r17
    1fcc:	d9 f7       	brne	.-10     	; 0x1fc4 <generateArrayTemperature+0x38>
		jsonDataTemperatureTempT2[i] = jsonDataTemperatureTemp[i];
	}
	jsonDataTemperatureTempT2 [len1-1] = ':';
    1fce:	e9 e4       	ldi	r30, 0x49	; 73
    1fd0:	f8 e0       	ldi	r31, 0x08	; 8
    1fd2:	9a e3       	ldi	r25, 0x3A	; 58
    1fd4:	97 8f       	std	Z+31, r25	; 0x1f
	jsonDataTemperatureTempT2 [len1] = ASCII_CONVERT(d1);
    1fd6:	80 5d       	subi	r24, 0xD0	; 208
    1fd8:	80 a3       	std	Z+32, r24	; 0x20
	jsonDataTemperatureTempT2 [len1+1] = ASCII_CONVERT(d2);
    1fda:	60 5d       	subi	r22, 0xD0	; 208
    1fdc:	61 a3       	std	Z+33, r22	; 0x21
	jsonDataTemperatureTempT2 [len1+2] = '.';
    1fde:	8e e2       	ldi	r24, 0x2E	; 46
    1fe0:	82 a3       	std	Z+34, r24	; 0x22
	jsonDataTemperatureTempT2 [len1+3] = ASCII_CONVERT(d3);
    1fe2:	40 5d       	subi	r20, 0xD0	; 208
    1fe4:	43 a3       	std	Z+35, r20	; 0x23
	jsonDataTemperatureTempT2 [len1+4] = ASCII_CONVERT(d4);
    1fe6:	20 5d       	subi	r18, 0xD0	; 208
    1fe8:	24 a3       	std	Z+36, r18	; 0x24
	jsonDataTemperatureTempT2 [len1+5] = '}';
    1fea:	8d e7       	ldi	r24, 0x7D	; 125
    1fec:	85 a3       	std	Z+37, r24	; 0x25
	jsonDataTemperatureTempT2 [len1+6] = '\n';
    1fee:	8a e0       	ldi	r24, 0x0A	; 10
    1ff0:	86 a3       	std	Z+38, r24	; 0x26
	jsonDataTemperatureTempT2 [len1+7] = '\0';
    1ff2:	17 a2       	std	Z+39, r1	; 0x27
	return jsonDataTemperatureTempT2;
	
}
    1ff4:	cf 01       	movw	r24, r30
    1ff6:	a0 96       	adiw	r28, 0x20	; 32
    1ff8:	0f b6       	in	r0, 0x3f	; 63
    1ffa:	f8 94       	cli
    1ffc:	de bf       	out	0x3e, r29	; 62
    1ffe:	0f be       	out	0x3f, r0	; 63
    2000:	cd bf       	out	0x3d, r28	; 61
    2002:	df 91       	pop	r29
    2004:	cf 91       	pop	r28
    2006:	1f 91       	pop	r17
    2008:	0f 91       	pop	r16
    200a:	08 95       	ret

0000200c <convertTemperature>:

unsigned char* convertTemperature(float value){ //it must create  "{\"sensor\":\"temperature\",\"value\":25}\n"
    200c:	cf 92       	push	r12
    200e:	df 92       	push	r13
    2010:	ef 92       	push	r14
    2012:	ff 92       	push	r15
	static unsigned char result[4];
		
	/*float convert = value*10/93-50;*/
	float convert = value;
	//it must take single digit to print in LCD
	z = convert*100;
    2014:	20 e0       	ldi	r18, 0x00	; 0
    2016:	30 e0       	ldi	r19, 0x00	; 0
    2018:	48 ec       	ldi	r20, 0xC8	; 200
    201a:	52 e4       	ldi	r21, 0x42	; 66
    201c:	0e 94 43 15 	call	0x2a86	; 0x2a86 <__mulsf3>
    2020:	0e 94 81 14 	call	0x2902	; 0x2902 <__fixunssfsi>
    2024:	6b 01       	movw	r12, r22
    2026:	7c 01       	movw	r14, r24
	w = z/10;
	x=w/10;
	y=x/10;
	
	//module to take single unit digit
	result[0]=y%10;
    2028:	e5 e4       	ldi	r30, 0x45	; 69
    202a:	f8 e0       	ldi	r31, 0x08	; 8
    202c:	9b 01       	movw	r18, r22
    202e:	36 95       	lsr	r19
    2030:	27 95       	ror	r18
    2032:	36 95       	lsr	r19
    2034:	27 95       	ror	r18
    2036:	36 95       	lsr	r19
    2038:	27 95       	ror	r18
    203a:	a5 ec       	ldi	r26, 0xC5	; 197
    203c:	b0 e2       	ldi	r27, 0x20	; 32
    203e:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <__umulhisi3>
    2042:	ac 01       	movw	r20, r24
    2044:	52 95       	swap	r21
    2046:	42 95       	swap	r20
    2048:	4f 70       	andi	r20, 0x0F	; 15
    204a:	45 27       	eor	r20, r21
    204c:	5f 70       	andi	r21, 0x0F	; 15
    204e:	45 27       	eor	r20, r21
    2050:	9a 01       	movw	r18, r20
    2052:	ad ec       	ldi	r26, 0xCD	; 205
    2054:	bc ec       	ldi	r27, 0xCC	; 204
    2056:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <__umulhisi3>
    205a:	96 95       	lsr	r25
    205c:	87 95       	ror	r24
    205e:	96 95       	lsr	r25
    2060:	87 95       	ror	r24
    2062:	96 95       	lsr	r25
    2064:	87 95       	ror	r24
    2066:	9c 01       	movw	r18, r24
    2068:	22 0f       	add	r18, r18
    206a:	33 1f       	adc	r19, r19
    206c:	88 0f       	add	r24, r24
    206e:	99 1f       	adc	r25, r25
    2070:	88 0f       	add	r24, r24
    2072:	99 1f       	adc	r25, r25
    2074:	88 0f       	add	r24, r24
    2076:	99 1f       	adc	r25, r25
    2078:	82 0f       	add	r24, r18
    207a:	93 1f       	adc	r25, r19
    207c:	48 1b       	sub	r20, r24
    207e:	59 0b       	sbc	r21, r25
    2080:	40 83       	st	Z, r20
	result[1]=x%10;
    2082:	96 01       	movw	r18, r12
    2084:	36 95       	lsr	r19
    2086:	27 95       	ror	r18
    2088:	36 95       	lsr	r19
    208a:	27 95       	ror	r18
    208c:	ab e7       	ldi	r26, 0x7B	; 123
    208e:	b4 e1       	ldi	r27, 0x14	; 20
    2090:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <__umulhisi3>
    2094:	ac 01       	movw	r20, r24
    2096:	56 95       	lsr	r21
    2098:	47 95       	ror	r20
    209a:	9a 01       	movw	r18, r20
    209c:	ad ec       	ldi	r26, 0xCD	; 205
    209e:	bc ec       	ldi	r27, 0xCC	; 204
    20a0:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <__umulhisi3>
    20a4:	96 95       	lsr	r25
    20a6:	87 95       	ror	r24
    20a8:	96 95       	lsr	r25
    20aa:	87 95       	ror	r24
    20ac:	96 95       	lsr	r25
    20ae:	87 95       	ror	r24
    20b0:	9c 01       	movw	r18, r24
    20b2:	22 0f       	add	r18, r18
    20b4:	33 1f       	adc	r19, r19
    20b6:	88 0f       	add	r24, r24
    20b8:	99 1f       	adc	r25, r25
    20ba:	88 0f       	add	r24, r24
    20bc:	99 1f       	adc	r25, r25
    20be:	88 0f       	add	r24, r24
    20c0:	99 1f       	adc	r25, r25
    20c2:	82 0f       	add	r24, r18
    20c4:	93 1f       	adc	r25, r19
    20c6:	48 1b       	sub	r20, r24
    20c8:	59 0b       	sbc	r21, r25
    20ca:	41 83       	std	Z+1, r20	; 0x01
	result[2]=w%10;
    20cc:	96 01       	movw	r18, r12
    20ce:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <__umulhisi3>
    20d2:	ac 01       	movw	r20, r24
    20d4:	56 95       	lsr	r21
    20d6:	47 95       	ror	r20
    20d8:	56 95       	lsr	r21
    20da:	47 95       	ror	r20
    20dc:	56 95       	lsr	r21
    20de:	47 95       	ror	r20
    20e0:	9a 01       	movw	r18, r20
    20e2:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <__umulhisi3>
    20e6:	96 95       	lsr	r25
    20e8:	87 95       	ror	r24
    20ea:	96 95       	lsr	r25
    20ec:	87 95       	ror	r24
    20ee:	96 95       	lsr	r25
    20f0:	87 95       	ror	r24
    20f2:	9c 01       	movw	r18, r24
    20f4:	22 0f       	add	r18, r18
    20f6:	33 1f       	adc	r19, r19
    20f8:	88 0f       	add	r24, r24
    20fa:	99 1f       	adc	r25, r25
    20fc:	88 0f       	add	r24, r24
    20fe:	99 1f       	adc	r25, r25
    2100:	88 0f       	add	r24, r24
    2102:	99 1f       	adc	r25, r25
    2104:	82 0f       	add	r24, r18
    2106:	93 1f       	adc	r25, r19
    2108:	9a 01       	movw	r18, r20
    210a:	28 1b       	sub	r18, r24
    210c:	39 0b       	sbc	r19, r25
    210e:	22 83       	std	Z+2, r18	; 0x02
	result[3]=z%10;
    2110:	ca 01       	movw	r24, r20
    2112:	88 0f       	add	r24, r24
    2114:	99 1f       	adc	r25, r25
    2116:	44 0f       	add	r20, r20
    2118:	55 1f       	adc	r21, r21
    211a:	44 0f       	add	r20, r20
    211c:	55 1f       	adc	r21, r21
    211e:	44 0f       	add	r20, r20
    2120:	55 1f       	adc	r21, r21
    2122:	48 0f       	add	r20, r24
    2124:	59 1f       	adc	r21, r25
    2126:	c4 1a       	sub	r12, r20
    2128:	d5 0a       	sbc	r13, r21
    212a:	c3 82       	std	Z+3, r12	; 0x03
// 	LCD_sendData(d4+0x30);
// 	LCD_sendData(223);

	//return generateArrayTemperature(d1, d2, d3, d4);
	return result;
}
    212c:	cf 01       	movw	r24, r30
    212e:	ff 90       	pop	r15
    2130:	ef 90       	pop	r14
    2132:	df 90       	pop	r13
    2134:	cf 90       	pop	r12
    2136:	08 95       	ret

00002138 <LCD_sendTemp>:

 void LCD_sendTemp (unsigned char d1, unsigned char d2, unsigned char d3, unsigned char d4){
    2138:	1f 93       	push	r17
    213a:	cf 93       	push	r28
    213c:	df 93       	push	r29
    213e:	16 2f       	mov	r17, r22
    2140:	d4 2f       	mov	r29, r20
    2142:	c2 2f       	mov	r28, r18
 	LCD_sendData(d1+0x30);
    2144:	80 5d       	subi	r24, 0xD0	; 208
    2146:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
 	LCD_sendData(d2+0x30);
    214a:	80 e3       	ldi	r24, 0x30	; 48
    214c:	81 0f       	add	r24, r17
    214e:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
 	LCD_sendData('.');
    2152:	8e e2       	ldi	r24, 0x2E	; 46
    2154:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
 	LCD_sendData(d3+0x30);
    2158:	80 e3       	ldi	r24, 0x30	; 48
    215a:	8d 0f       	add	r24, r29
    215c:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
 	LCD_sendData(d4+0x30);
    2160:	80 e3       	ldi	r24, 0x30	; 48
    2162:	8c 0f       	add	r24, r28
    2164:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
 	LCD_sendData(223);	
    2168:	8f ed       	ldi	r24, 0xDF	; 223
    216a:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
}
    216e:	df 91       	pop	r29
    2170:	cf 91       	pop	r28
    2172:	1f 91       	pop	r17
    2174:	08 95       	ret

00002176 <temperatureSendTask>:
			}
		}
	}
}
	
void temperatureSendTask (void* parameter){
    2176:	cf 93       	push	r28
    2178:	df 93       	push	r29
    217a:	00 d0       	rcall	.+0      	; 0x217c <temperatureSendTask+0x6>
    217c:	00 d0       	rcall	.+0      	; 0x217e <temperatureSendTask+0x8>
    217e:	cd b7       	in	r28, 0x3d	; 61
    2180:	de b7       	in	r29, 0x3e	; 62
	
	float temperature;
	for (;;)
	{
		if( xQueueTemperatureSendings != NULL )
    2182:	80 91 8a 08 	lds	r24, 0x088A	; 0x80088a <xQueueTemperatureSendings>
    2186:	90 91 8b 08 	lds	r25, 0x088B	; 0x80088b <xQueueTemperatureSendings+0x1>
    218a:	00 97       	sbiw	r24, 0x00	; 0
    218c:	f1 f3       	breq	.-4      	; 0x218a <temperatureSendTask+0x14>
		{
		 /* Receive a message from the created queue to hold pointers.  Block for 10
		ticks if a message is not immediately available.  The value is read into a
		 pointer variable, and as the value received is the address of the xMessage
		variable, after this call pxRxedPointer will point to xMessage. */
			if( xQueueReceive( xQueueTemperatureSendings,
    218e:	20 e0       	ldi	r18, 0x00	; 0
    2190:	48 ee       	ldi	r20, 0xE8	; 232
    2192:	53 e0       	ldi	r21, 0x03	; 3
    2194:	be 01       	movw	r22, r28
    2196:	6f 5f       	subi	r22, 0xFF	; 255
    2198:	7f 4f       	sbci	r23, 0xFF	; 255
    219a:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    219e:	81 30       	cpi	r24, 0x01	; 1
    21a0:	81 f7       	brne	.-32     	; 0x2182 <temperatureSendTask+0xc>
                         &temperature,
                         1000 ) == pdPASS )
						 
			{
				
				unsigned char *values = convertTemperature(temperature);
    21a2:	69 81       	ldd	r22, Y+1	; 0x01
    21a4:	7a 81       	ldd	r23, Y+2	; 0x02
    21a6:	8b 81       	ldd	r24, Y+3	; 0x03
    21a8:	9c 81       	ldd	r25, Y+4	; 0x04
    21aa:	0e 94 06 10 	call	0x200c	; 0x200c <convertTemperature>
    21ae:	8c 01       	movw	r16, r24
				char *jsonDataTemperature = generateArrayTemperature(values[0], values[1], values[2], values[3]);
    21b0:	fc 01       	movw	r30, r24
    21b2:	23 81       	ldd	r18, Z+3	; 0x03
    21b4:	42 81       	ldd	r20, Z+2	; 0x02
    21b6:	61 81       	ldd	r22, Z+1	; 0x01
    21b8:	80 81       	ld	r24, Z
    21ba:	0e 94 c6 0f 	call	0x1f8c	; 0x1f8c <generateArrayTemperature>
    21be:	7c 01       	movw	r14, r24
				vTaskDelay(pdMS_TO_TICKS(1500));
    21c0:	8a e3       	ldi	r24, 0x3A	; 58
    21c2:	90 e0       	ldi	r25, 0x00	; 0
    21c4:	0e 94 9f 08 	call	0x113e	; 0x113e <vTaskDelay>
				
				
				if( xSemaphoreTake( xSemaphoreLCD, ( TickType_t ) 1000 ) == pdTRUE )
    21c8:	20 e0       	ldi	r18, 0x00	; 0
    21ca:	48 ee       	ldi	r20, 0xE8	; 232
    21cc:	53 e0       	ldi	r21, 0x03	; 3
    21ce:	60 e0       	ldi	r22, 0x00	; 0
    21d0:	70 e0       	ldi	r23, 0x00	; 0
    21d2:	80 91 80 08 	lds	r24, 0x0880	; 0x800880 <xSemaphoreLCD>
    21d6:	90 91 81 08 	lds	r25, 0x0881	; 0x800881 <xSemaphoreLCD+0x1>
    21da:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    21de:	81 30       	cpi	r24, 0x01	; 1
    21e0:	d1 f4       	brne	.+52     	; 0x2216 <temperatureSendTask+0xa0>
				{
					LCD_goToXY(6,1);
    21e2:	61 e0       	ldi	r22, 0x01	; 1
    21e4:	86 e0       	ldi	r24, 0x06	; 6
    21e6:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <LCD_goToXY>
					LCD_sendTemp(values[0], values[1], values[2], values[3]);
    21ea:	f8 01       	movw	r30, r16
    21ec:	23 81       	ldd	r18, Z+3	; 0x03
    21ee:	42 81       	ldd	r20, Z+2	; 0x02
    21f0:	61 81       	ldd	r22, Z+1	; 0x01
    21f2:	80 81       	ld	r24, Z
    21f4:	0e 94 9c 10 	call	0x2138	; 0x2138 <LCD_sendTemp>
					vTaskDelay(1);
    21f8:	81 e0       	ldi	r24, 0x01	; 1
    21fa:	90 e0       	ldi	r25, 0x00	; 0
    21fc:	0e 94 9f 08 	call	0x113e	; 0x113e <vTaskDelay>
					xSemaphoreGive( xSemaphoreLCD );
    2200:	20 e0       	ldi	r18, 0x00	; 0
    2202:	40 e0       	ldi	r20, 0x00	; 0
    2204:	50 e0       	ldi	r21, 0x00	; 0
    2206:	60 e0       	ldi	r22, 0x00	; 0
    2208:	70 e0       	ldi	r23, 0x00	; 0
    220a:	80 91 80 08 	lds	r24, 0x0880	; 0x800880 <xSemaphoreLCD>
    220e:	90 91 81 08 	lds	r25, 0x0881	; 0x800881 <xSemaphoreLCD+0x1>
    2212:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
				}	
				
				if( xSemaphoreTake( xSemaphoreUART, ( TickType_t ) 1000 ) == pdTRUE )
    2216:	20 e0       	ldi	r18, 0x00	; 0
    2218:	48 ee       	ldi	r20, 0xE8	; 232
    221a:	53 e0       	ldi	r21, 0x03	; 3
    221c:	60 e0       	ldi	r22, 0x00	; 0
    221e:	70 e0       	ldi	r23, 0x00	; 0
    2220:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    2224:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    2228:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    222c:	81 30       	cpi	r24, 0x01	; 1
    222e:	09 f0       	breq	.+2      	; 0x2232 <temperatureSendTask+0xbc>
    2230:	a8 cf       	rjmp	.-176    	; 0x2182 <temperatureSendTask+0xc>
				{
					/* We were able to obtain the semaphore and can now access the
					shared resource. */
					vTaskDelay(5);
    2232:	85 e0       	ldi	r24, 0x05	; 5
    2234:	90 e0       	ldi	r25, 0x00	; 0
    2236:	0e 94 9f 08 	call	0x113e	; 0x113e <vTaskDelay>
					UART_sendString(jsonDataTemperature);
    223a:	c7 01       	movw	r24, r14
    223c:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <UART_sendString>
					
					/* We have finished accessing the shared resource.  Release the
					semaphore. */
					xSemaphoreGive( xSemaphoreUART );
    2240:	20 e0       	ldi	r18, 0x00	; 0
    2242:	40 e0       	ldi	r20, 0x00	; 0
    2244:	50 e0       	ldi	r21, 0x00	; 0
    2246:	60 e0       	ldi	r22, 0x00	; 0
    2248:	70 e0       	ldi	r23, 0x00	; 0
    224a:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    224e:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    2252:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
    2256:	95 cf       	rjmp	.-214    	; 0x2182 <temperatureSendTask+0xc>

00002258 <convertAir>:

	return jsonDataAirT2;
	
}

unsigned char* convertAir(float value){
    2258:	cf 92       	push	r12
    225a:	df 92       	push	r13
    225c:	ef 92       	push	r14
    225e:	ff 92       	push	r15
	//3 digit: 000 -> 999 
	unsigned int x,y,w;
	
	static unsigned char result[3];
	
	w = value;
    2260:	0e 94 81 14 	call	0x2902	; 0x2902 <__fixunssfsi>
    2264:	6b 01       	movw	r12, r22
    2266:	7c 01       	movw	r14, r24
	x=w/10;
	y=x/10;
	
	result[0]=y%10;
    2268:	e2 e4       	ldi	r30, 0x42	; 66
    226a:	f8 e0       	ldi	r31, 0x08	; 8
    226c:	9b 01       	movw	r18, r22
    226e:	36 95       	lsr	r19
    2270:	27 95       	ror	r18
    2272:	36 95       	lsr	r19
    2274:	27 95       	ror	r18
    2276:	ab e7       	ldi	r26, 0x7B	; 123
    2278:	b4 e1       	ldi	r27, 0x14	; 20
    227a:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <__umulhisi3>
    227e:	ac 01       	movw	r20, r24
    2280:	56 95       	lsr	r21
    2282:	47 95       	ror	r20
    2284:	9a 01       	movw	r18, r20
    2286:	ad ec       	ldi	r26, 0xCD	; 205
    2288:	bc ec       	ldi	r27, 0xCC	; 204
    228a:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <__umulhisi3>
    228e:	96 95       	lsr	r25
    2290:	87 95       	ror	r24
    2292:	96 95       	lsr	r25
    2294:	87 95       	ror	r24
    2296:	96 95       	lsr	r25
    2298:	87 95       	ror	r24
    229a:	9c 01       	movw	r18, r24
    229c:	22 0f       	add	r18, r18
    229e:	33 1f       	adc	r19, r19
    22a0:	88 0f       	add	r24, r24
    22a2:	99 1f       	adc	r25, r25
    22a4:	88 0f       	add	r24, r24
    22a6:	99 1f       	adc	r25, r25
    22a8:	88 0f       	add	r24, r24
    22aa:	99 1f       	adc	r25, r25
    22ac:	82 0f       	add	r24, r18
    22ae:	93 1f       	adc	r25, r19
    22b0:	48 1b       	sub	r20, r24
    22b2:	59 0b       	sbc	r21, r25
    22b4:	40 83       	st	Z, r20
	result[1]=x%10;
    22b6:	96 01       	movw	r18, r12
    22b8:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <__umulhisi3>
    22bc:	ac 01       	movw	r20, r24
    22be:	56 95       	lsr	r21
    22c0:	47 95       	ror	r20
    22c2:	56 95       	lsr	r21
    22c4:	47 95       	ror	r20
    22c6:	56 95       	lsr	r21
    22c8:	47 95       	ror	r20
    22ca:	9a 01       	movw	r18, r20
    22cc:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <__umulhisi3>
    22d0:	96 95       	lsr	r25
    22d2:	87 95       	ror	r24
    22d4:	96 95       	lsr	r25
    22d6:	87 95       	ror	r24
    22d8:	96 95       	lsr	r25
    22da:	87 95       	ror	r24
    22dc:	9c 01       	movw	r18, r24
    22de:	22 0f       	add	r18, r18
    22e0:	33 1f       	adc	r19, r19
    22e2:	88 0f       	add	r24, r24
    22e4:	99 1f       	adc	r25, r25
    22e6:	88 0f       	add	r24, r24
    22e8:	99 1f       	adc	r25, r25
    22ea:	88 0f       	add	r24, r24
    22ec:	99 1f       	adc	r25, r25
    22ee:	82 0f       	add	r24, r18
    22f0:	93 1f       	adc	r25, r19
    22f2:	9a 01       	movw	r18, r20
    22f4:	28 1b       	sub	r18, r24
    22f6:	39 0b       	sbc	r19, r25
    22f8:	21 83       	std	Z+1, r18	; 0x01
	result[2]=w%10;
    22fa:	ca 01       	movw	r24, r20
    22fc:	88 0f       	add	r24, r24
    22fe:	99 1f       	adc	r25, r25
    2300:	44 0f       	add	r20, r20
    2302:	55 1f       	adc	r21, r21
    2304:	44 0f       	add	r20, r20
    2306:	55 1f       	adc	r21, r21
    2308:	44 0f       	add	r20, r20
    230a:	55 1f       	adc	r21, r21
    230c:	48 0f       	add	r20, r24
    230e:	59 1f       	adc	r21, r25
    2310:	c4 1a       	sub	r12, r20
    2312:	d5 0a       	sbc	r13, r21
    2314:	c2 82       	std	Z+2, r12	; 0x02
// 	LCD_sendData(d2+ASCII_OFFSET);
// 	LCD_sendData(d3+ASCII_OFFSET);

	//return generateArrayAir(d1, d2, d3);
	return result;
}
    2316:	cf 01       	movw	r24, r30
    2318:	ff 90       	pop	r15
    231a:	ef 90       	pop	r14
    231c:	df 90       	pop	r13
    231e:	cf 90       	pop	r12
    2320:	08 95       	ret

00002322 <LCD_sendAir>:

 void LCD_sendAir (unsigned char d1, unsigned char d2, unsigned char d3){
    2322:	cf 93       	push	r28
    2324:	df 93       	push	r29
    2326:	d6 2f       	mov	r29, r22
    2328:	c4 2f       	mov	r28, r20
	LCD_sendData(d1+0x30);
    232a:	80 5d       	subi	r24, 0xD0	; 208
    232c:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
	LCD_sendData(d2+0x30);
    2330:	80 e3       	ldi	r24, 0x30	; 48
    2332:	8d 0f       	add	r24, r29
    2334:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
	LCD_sendData(d3+0x30);
    2338:	80 e3       	ldi	r24, 0x30	; 48
    233a:	8c 0f       	add	r24, r28
    233c:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
	LCD_sendData(' ');
    2340:	80 e2       	ldi	r24, 0x20	; 32
    2342:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
	LCD_sendData(' ');
    2346:	80 e2       	ldi	r24, 0x20	; 32
    2348:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
	LCD_sendData(' ');
    234c:	80 e2       	ldi	r24, 0x20	; 32
    234e:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
	LCD_sendData(' ');
    2352:	80 e2       	ldi	r24, 0x20	; 32
    2354:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
	LCD_sendData(' ');
    2358:	80 e2       	ldi	r24, 0x20	; 32
    235a:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
	LCD_sendData(' ');
    235e:	80 e2       	ldi	r24, 0x20	; 32
    2360:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
 }
    2364:	df 91       	pop	r29
    2366:	cf 91       	pop	r28
    2368:	08 95       	ret

0000236a <airSendTask>:
			}
		}
	}//FOR	
}//READING AIR

void airSendTask (void* parameter){
    236a:	cf 93       	push	r28
    236c:	df 93       	push	r29
    236e:	cd b7       	in	r28, 0x3d	; 61
    2370:	de b7       	in	r29, 0x3e	; 62
    2372:	6c 97       	sbiw	r28, 0x1c	; 28
    2374:	0f b6       	in	r0, 0x3f	; 63
    2376:	f8 94       	cli
    2378:	de bf       	out	0x3e, r29	; 62
    237a:	0f be       	out	0x3f, r0	; 63
    237c:	cd bf       	out	0x3d, r28	; 61
    237e:	8e 01       	movw	r16, r28
    2380:	03 5e       	subi	r16, 0xE3	; 227
    2382:	1f 4f       	sbci	r17, 0xFF	; 255
	for (int i = 0; i<len; i++){
		jsonDataAirT2[i] = jsonDataAir[i];
	}

		
	jsonDataAirT2 [len-1] = ':';
    2384:	0f 2e       	mov	r0, r31
    2386:	f0 e1       	ldi	r31, 0x10	; 16
    2388:	cf 2e       	mov	r12, r31
    238a:	f8 e0       	ldi	r31, 0x08	; 8
    238c:	df 2e       	mov	r13, r31
    238e:	f0 2d       	mov	r31, r0
    2390:	0f 2e       	mov	r0, r31
    2392:	fa e3       	ldi	r31, 0x3A	; 58
    2394:	9f 2e       	mov	r9, r31
    2396:	f0 2d       	mov	r31, r0
		jsonDataAirT2 [len+1] = d2+ASCII_OFFSET;
	}
		
	jsonDataAirT2 [len+2] = d3+ASCII_OFFSET;
		
	jsonDataAirT2 [len+3] = '.';
    2398:	0f 2e       	mov	r0, r31
    239a:	fe e2       	ldi	r31, 0x2E	; 46
    239c:	af 2e       	mov	r10, r31
    239e:	f0 2d       	mov	r31, r0
 	LCD_sendData(223);	
}

static char* generateArrayAir(unsigned char d1, unsigned char d2, unsigned char d3){
	char jsonDataAir [] = "{\"sensor\":\"air\",\"value\"";
	int len = sizeof(jsonDataAir)/sizeof(jsonDataAir[0]);
    23a0:	0f 2e       	mov	r0, r31
    23a2:	f8 e1       	ldi	r31, 0x18	; 24
    23a4:	5f 2e       	mov	r5, r31
    23a6:	f0 2d       	mov	r31, r0
    23a8:	61 2c       	mov	r6, r1
		
	jsonDataAirT2 [len-1] = ':';

	if ((d1+ASCII_OFFSET) == '0'){ //excluding 0 when the value is < 100
		jsonDataAirT2 [len] = d2+ASCII_OFFSET;
		len = len -1;
    23aa:	0f 2e       	mov	r0, r31
    23ac:	f7 e1       	ldi	r31, 0x17	; 23
    23ae:	3f 2e       	mov	r3, r31
    23b0:	f0 2d       	mov	r31, r0
    23b2:	41 2c       	mov	r4, r1
	}
		
	jsonDataAirT2 [len+2] = d3+ASCII_OFFSET;
		
	jsonDataAirT2 [len+3] = '.';
	jsonDataAirT2 [len+4] = '0';
    23b4:	0f 2e       	mov	r0, r31
    23b6:	f0 e3       	ldi	r31, 0x30	; 48
    23b8:	bf 2e       	mov	r11, r31
    23ba:	f0 2d       	mov	r31, r0
	jsonDataAirT2 [len+5] = '0';
		
	jsonDataAirT2 [len+6] = '}';
    23bc:	0f 2e       	mov	r0, r31
    23be:	fd e7       	ldi	r31, 0x7D	; 125
    23c0:	7f 2e       	mov	r7, r31
    23c2:	f0 2d       	mov	r31, r0
	
	jsonDataAirT2 [len+7] = '\n';
    23c4:	0f 2e       	mov	r0, r31
    23c6:	fa e0       	ldi	r31, 0x0A	; 10
    23c8:	8f 2e       	mov	r8, r31
    23ca:	f0 2d       	mov	r31, r0
void airSendTask (void* parameter){
	
	float air;
	for (;;)
 	{	
 		if( xQueueAirSendings != NULL )
    23cc:	80 91 9e 08 	lds	r24, 0x089E	; 0x80089e <xQueueAirSendings>
    23d0:	90 91 9f 08 	lds	r25, 0x089F	; 0x80089f <xQueueAirSendings+0x1>
    23d4:	00 97       	sbiw	r24, 0x00	; 0
    23d6:	f1 f3       	breq	.-4      	; 0x23d4 <airSendTask+0x6a>
 		{
 			if( xQueueReceive( xQueueAirSendings,
    23d8:	20 e0       	ldi	r18, 0x00	; 0
    23da:	48 ee       	ldi	r20, 0xE8	; 232
    23dc:	53 e0       	ldi	r21, 0x03	; 3
    23de:	be 01       	movw	r22, r28
    23e0:	6f 5f       	subi	r22, 0xFF	; 255
    23e2:	7f 4f       	sbci	r23, 0xFF	; 255
    23e4:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    23e8:	81 30       	cpi	r24, 0x01	; 1
    23ea:	81 f7       	brne	.-32     	; 0x23cc <airSendTask+0x62>
                          &( air ),
                          ( TickType_t ) 1000 ) == pdPASS )		 
 			{
				unsigned char *values = convertAir(air);
    23ec:	69 81       	ldd	r22, Y+1	; 0x01
    23ee:	7a 81       	ldd	r23, Y+2	; 0x02
    23f0:	8b 81       	ldd	r24, Y+3	; 0x03
    23f2:	9c 81       	ldd	r25, Y+4	; 0x04
    23f4:	0e 94 2c 11 	call	0x2258	; 0x2258 <convertAir>
    23f8:	7c 01       	movw	r14, r24
				char *jsonDataAir = generateArrayAir(values[0], values[1], values[2]);
    23fa:	fc 01       	movw	r30, r24
    23fc:	92 81       	ldd	r25, Z+2	; 0x02
    23fe:	21 81       	ldd	r18, Z+1	; 0x01
    2400:	30 81       	ld	r19, Z
 	LCD_sendData(d4+0x30);
 	LCD_sendData(223);	
}

static char* generateArrayAir(unsigned char d1, unsigned char d2, unsigned char d3){
	char jsonDataAir [] = "{\"sensor\":\"air\",\"value\"";
    2402:	88 e1       	ldi	r24, 0x18	; 24
    2404:	e2 e3       	ldi	r30, 0x32	; 50
    2406:	f1 e0       	ldi	r31, 0x01	; 1
    2408:	de 01       	movw	r26, r28
    240a:	15 96       	adiw	r26, 0x05	; 5
    240c:	01 90       	ld	r0, Z+
    240e:	0d 92       	st	X+, r0
    2410:	8a 95       	dec	r24
    2412:	e1 f7       	brne	.-8      	; 0x240c <airSendTask+0xa2>
    2414:	fe 01       	movw	r30, r28
    2416:	35 96       	adiw	r30, 0x05	; 5
    2418:	a0 e1       	ldi	r26, 0x10	; 16
    241a:	b8 e0       	ldi	r27, 0x08	; 8
	int len = sizeof(jsonDataAir)/sizeof(jsonDataAir[0]);
	//char *jsonDataAirT2 = malloc(len+8);
	static char jsonDataAirT2 [SIZE_ARRAY];
		
	for (int i = 0; i<len; i++){
		jsonDataAirT2[i] = jsonDataAir[i];
    241c:	81 91       	ld	r24, Z+
    241e:	8d 93       	st	X+, r24
	char jsonDataAir [] = "{\"sensor\":\"air\",\"value\"";
	int len = sizeof(jsonDataAir)/sizeof(jsonDataAir[0]);
	//char *jsonDataAirT2 = malloc(len+8);
	static char jsonDataAirT2 [SIZE_ARRAY];
		
	for (int i = 0; i<len; i++){
    2420:	e0 17       	cp	r30, r16
    2422:	f1 07       	cpc	r31, r17
    2424:	d9 f7       	brne	.-10     	; 0x241c <airSendTask+0xb2>
		jsonDataAirT2[i] = jsonDataAir[i];
	}

		
	jsonDataAirT2 [len-1] = ':';
    2426:	f6 01       	movw	r30, r12
    2428:	97 8a       	std	Z+23, r9	; 0x17

	if ((d1+ASCII_OFFSET) == '0'){ //excluding 0 when the value is < 100
    242a:	31 11       	cpse	r19, r1
    242c:	05 c0       	rjmp	.+10     	; 0x2438 <airSendTask+0xce>
		jsonDataAirT2 [len] = d2+ASCII_OFFSET;
    242e:	20 5d       	subi	r18, 0xD0	; 208
    2430:	20 8f       	std	Z+24, r18	; 0x18
		len = len -1;
    2432:	e3 2d       	mov	r30, r3
    2434:	f4 2d       	mov	r31, r4
    2436:	07 c0       	rjmp	.+14     	; 0x2446 <airSendTask+0xdc>
		} else {
		jsonDataAirT2 [len] = d1+ASCII_OFFSET;
    2438:	30 5d       	subi	r19, 0xD0	; 208
    243a:	f6 01       	movw	r30, r12
    243c:	30 8f       	std	Z+24, r19	; 0x18
		jsonDataAirT2 [len+1] = d2+ASCII_OFFSET;
    243e:	20 5d       	subi	r18, 0xD0	; 208
    2440:	21 8f       	std	Z+25, r18	; 0x19
 	LCD_sendData(223);	
}

static char* generateArrayAir(unsigned char d1, unsigned char d2, unsigned char d3){
	char jsonDataAir [] = "{\"sensor\":\"air\",\"value\"";
	int len = sizeof(jsonDataAir)/sizeof(jsonDataAir[0]);
    2442:	e5 2d       	mov	r30, r5
    2444:	f6 2d       	mov	r31, r6
		} else {
		jsonDataAirT2 [len] = d1+ASCII_OFFSET;
		jsonDataAirT2 [len+1] = d2+ASCII_OFFSET;
	}
		
	jsonDataAirT2 [len+2] = d3+ASCII_OFFSET;
    2446:	e0 5f       	subi	r30, 0xF0	; 240
    2448:	f7 4f       	sbci	r31, 0xF7	; 247
    244a:	90 5d       	subi	r25, 0xD0	; 208
    244c:	92 83       	std	Z+2, r25	; 0x02
		
	jsonDataAirT2 [len+3] = '.';
    244e:	a3 82       	std	Z+3, r10	; 0x03
	jsonDataAirT2 [len+4] = '0';
    2450:	b4 82       	std	Z+4, r11	; 0x04
	jsonDataAirT2 [len+5] = '0';
    2452:	b5 82       	std	Z+5, r11	; 0x05
		
	jsonDataAirT2 [len+6] = '}';
    2454:	76 82       	std	Z+6, r7	; 0x06
	
	jsonDataAirT2 [len+7] = '\n';
    2456:	87 82       	std	Z+7, r8	; 0x07
	jsonDataAirT2 [len+8] = '\0';
    2458:	10 86       	std	Z+8, r1	; 0x08
                          &( air ),
                          ( TickType_t ) 1000 ) == pdPASS )		 
 			{
				unsigned char *values = convertAir(air);
				char *jsonDataAir = generateArrayAir(values[0], values[1], values[2]);
				vTaskDelay(pdMS_TO_TICKS(1500));
    245a:	8a e3       	ldi	r24, 0x3A	; 58
    245c:	90 e0       	ldi	r25, 0x00	; 0
    245e:	0e 94 9f 08 	call	0x113e	; 0x113e <vTaskDelay>
				
				if( xSemaphoreTake( xSemaphoreLCD, ( TickType_t ) 1000 ) == pdTRUE )
    2462:	20 e0       	ldi	r18, 0x00	; 0
    2464:	48 ee       	ldi	r20, 0xE8	; 232
    2466:	53 e0       	ldi	r21, 0x03	; 3
    2468:	60 e0       	ldi	r22, 0x00	; 0
    246a:	70 e0       	ldi	r23, 0x00	; 0
    246c:	80 91 80 08 	lds	r24, 0x0880	; 0x800880 <xSemaphoreLCD>
    2470:	90 91 81 08 	lds	r25, 0x0881	; 0x800881 <xSemaphoreLCD+0x1>
    2474:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    2478:	81 30       	cpi	r24, 0x01	; 1
    247a:	c9 f4       	brne	.+50     	; 0x24ae <airSendTask+0x144>
				{
					LCD_goToXY(6,2);
    247c:	62 e0       	ldi	r22, 0x02	; 2
    247e:	86 e0       	ldi	r24, 0x06	; 6
    2480:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <LCD_goToXY>
					LCD_sendAir(values[0], values[1], values[2]);
    2484:	f7 01       	movw	r30, r14
    2486:	42 81       	ldd	r20, Z+2	; 0x02
    2488:	61 81       	ldd	r22, Z+1	; 0x01
    248a:	80 81       	ld	r24, Z
    248c:	0e 94 91 11 	call	0x2322	; 0x2322 <LCD_sendAir>
					vTaskDelay(1);
    2490:	81 e0       	ldi	r24, 0x01	; 1
    2492:	90 e0       	ldi	r25, 0x00	; 0
    2494:	0e 94 9f 08 	call	0x113e	; 0x113e <vTaskDelay>
					xSemaphoreGive( xSemaphoreLCD );
    2498:	20 e0       	ldi	r18, 0x00	; 0
    249a:	40 e0       	ldi	r20, 0x00	; 0
    249c:	50 e0       	ldi	r21, 0x00	; 0
    249e:	60 e0       	ldi	r22, 0x00	; 0
    24a0:	70 e0       	ldi	r23, 0x00	; 0
    24a2:	80 91 80 08 	lds	r24, 0x0880	; 0x800880 <xSemaphoreLCD>
    24a6:	90 91 81 08 	lds	r25, 0x0881	; 0x800881 <xSemaphoreLCD+0x1>
    24aa:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
				}
				
				if( xSemaphoreTake( xSemaphoreUART, ( TickType_t ) 1000 ) == pdTRUE )
    24ae:	20 e0       	ldi	r18, 0x00	; 0
    24b0:	48 ee       	ldi	r20, 0xE8	; 232
    24b2:	53 e0       	ldi	r21, 0x03	; 3
    24b4:	60 e0       	ldi	r22, 0x00	; 0
    24b6:	70 e0       	ldi	r23, 0x00	; 0
    24b8:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    24bc:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    24c0:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    24c4:	81 30       	cpi	r24, 0x01	; 1
    24c6:	09 f0       	breq	.+2      	; 0x24ca <airSendTask+0x160>
    24c8:	81 cf       	rjmp	.-254    	; 0x23cc <airSendTask+0x62>
				{
					/* We were able to obtain the semaphore and can now access the
					shared resource. */
					vTaskDelay(5);
    24ca:	85 e0       	ldi	r24, 0x05	; 5
    24cc:	90 e0       	ldi	r25, 0x00	; 0
    24ce:	0e 94 9f 08 	call	0x113e	; 0x113e <vTaskDelay>
					UART_sendString(jsonDataAir);
    24d2:	c6 01       	movw	r24, r12
    24d4:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <UART_sendString>
					
					/* We have finished accessing the shared resource.  Release the
					semaphore. */
					xSemaphoreGive( xSemaphoreUART );
    24d8:	20 e0       	ldi	r18, 0x00	; 0
    24da:	40 e0       	ldi	r20, 0x00	; 0
    24dc:	50 e0       	ldi	r21, 0x00	; 0
    24de:	60 e0       	ldi	r22, 0x00	; 0
    24e0:	70 e0       	ldi	r23, 0x00	; 0
    24e2:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    24e6:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    24ea:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
    24ee:	62 cf       	rjmp	.-316    	; 0x23b4 <airSendTask+0x4a>

000024f0 <main>:
 }
 
// MAIN PROGRAM
int main(void)
{
	alarmState = OFF;
    24f0:	10 92 a0 08 	sts	0x08A0, r1	; 0x8008a0 <alarmState>
	stateBuzzer = OFF;
    24f4:	10 92 7f 08 	sts	0x087F, r1	; 0x80087f <stateBuzzer>
	stateFan = OFF;
    24f8:	10 92 a1 08 	sts	0x08A1, r1	; 0x8008a1 <stateFan>
}
*/

static void LCD_init()
{
  LCD_DDDR |= 0xF0;
    24fc:	8a b1       	in	r24, 0x0a	; 10
    24fe:	80 6f       	ori	r24, 0xF0	; 240
    2500:	8a b9       	out	0x0a, r24	; 10
  LCD_CDDR |= (1<<LCD_RS)|(1<<LCD_EN);
    2502:	84 b1       	in	r24, 0x04	; 4
    2504:	83 60       	ori	r24, 0x03	; 3
    2506:	84 b9       	out	0x04, r24	; 4
 
  LCD_CPRT &=~(1<<LCD_EN);  //LCD_EN = 0
    2508:	29 98       	cbi	0x05, 1	; 5
    250a:	8f e3       	ldi	r24, 0x3F	; 63
    250c:	9f e1       	ldi	r25, 0x1F	; 31
    250e:	01 97       	sbiw	r24, 0x01	; 1
    2510:	f1 f7       	brne	.-4      	; 0x250e <main+0x1e>
    2512:	00 c0       	rjmp	.+0      	; 0x2514 <main+0x24>
    2514:	00 00       	nop
  _delay_us(2000);      //wait for init.

  LCD_sendCommand(0x33); //send $33 for init.
    2516:	83 e3       	ldi	r24, 0x33	; 51
    2518:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <LCD_sendCommand>
  LCD_sendCommand(0x32); //send $32 for init
    251c:	82 e3       	ldi	r24, 0x32	; 50
    251e:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <LCD_sendCommand>
  LCD_sendCommand(0x28); //init. LCD 2 line,5*7 matrix
    2522:	88 e2       	ldi	r24, 0x28	; 40
    2524:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <LCD_sendCommand>
  LCD_sendCommand(0x0C); //display on, cursor on
    2528:	8c e0       	ldi	r24, 0x0C	; 12
    252a:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <LCD_sendCommand>
  LCD_sendCommand(0x06); //shift cursor right
    252e:	86 e0       	ldi	r24, 0x06	; 6
    2530:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <LCD_sendCommand>
  LCD_putValue(data);  
}

static void LCD_clear()
{
  LCD_sendCommand(0x01);
    2534:	81 e0       	ldi	r24, 0x01	; 1
    2536:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <LCD_sendCommand>
    253a:	8f e8       	ldi	r24, 0x8F	; 143
    253c:	9a e1       	ldi	r25, 0x1A	; 26
    253e:	01 97       	sbiw	r24, 0x01	; 1
    2540:	f1 f7       	brne	.-4      	; 0x253e <main+0x4e>
    2542:	00 c0       	rjmp	.+0      	; 0x2544 <main+0x54>
    2544:	00 00       	nop
    2546:	c0 e0       	ldi	r28, 0x00	; 0
    2548:	84 e5       	ldi	r24, 0x54	; 84
{
  unsigned char i = 0;

  while(str[i] != 0) //while it is not end of string
  {
    LCD_sendData(str[i]);
    254a:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
    i++ ;
    254e:	cf 5f       	subi	r28, 0xFF	; 255

static void LCD_print( char * str )
{
  unsigned char i = 0;

  while(str[i] != 0) //while it is not end of string
    2550:	ec 2f       	mov	r30, r28
    2552:	f0 e0       	ldi	r31, 0x00	; 0
    2554:	e6 5b       	subi	r30, 0xB6	; 182
    2556:	fe 4f       	sbci	r31, 0xFE	; 254
    2558:	80 81       	ld	r24, Z
    255a:	81 11       	cpse	r24, r1
    255c:	f6 cf       	rjmp	.-20     	; 0x254a <main+0x5a>
	stateBuzzer = OFF;
	stateFan = OFF;
	LCD_init();
	
	LCD_print("Temp:");
	LCD_goToXY(1,2);
    255e:	62 e0       	ldi	r22, 0x02	; 2
    2560:	81 e0       	ldi	r24, 0x01	; 1
    2562:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <LCD_goToXY>
    2566:	c0 e0       	ldi	r28, 0x00	; 0
    2568:	81 e4       	ldi	r24, 0x41	; 65
{
  unsigned char i = 0;

  while(str[i] != 0) //while it is not end of string
  {
    LCD_sendData(str[i]);
    256a:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_sendData>
    i++ ;
    256e:	cf 5f       	subi	r28, 0xFF	; 255

static void LCD_print( char * str )
{
  unsigned char i = 0;

  while(str[i] != 0) //while it is not end of string
    2570:	ec 2f       	mov	r30, r28
    2572:	f0 e0       	ldi	r31, 0x00	; 0
    2574:	e0 5b       	subi	r30, 0xB0	; 176
    2576:	fe 4f       	sbci	r31, 0xFE	; 254
    2578:	80 81       	ld	r24, Z
    257a:	81 11       	cpse	r24, r1
    257c:	f6 cf       	rjmp	.-20     	; 0x256a <main+0x7a>
}

static void UART_init()
{
	// Setup transmission speed
	UBRR0H = (BAUD_PRESCALER >> 8);
    257e:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
	UBRR0L = BAUD_PRESCALER;
    2582:	87 e6       	ldi	r24, 0x67	; 103
    2584:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
	
	// Enable transmission and receiving (FULL DUPLEX)
	UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
    2588:	88 e9       	ldi	r24, 0x98	; 152
    258a:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
	
	// Setup data format: 8 bit data, 1 stop bit
	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);
    258e:	86 e0       	ldi	r24, 0x06	; 6
    2590:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__DATA_REGION_ORIGIN__+0x62>
  }
}

static void portInit (void){
	
	DDRC = 0; //make Porct C an input for ADC input
    2594:	17 b8       	out	0x07, r1	; 7
	DDRD = 0xFF; //make port D output
    2596:	8f ef       	ldi	r24, 0xFF	; 255
    2598:	8a b9       	out	0x0a, r24	; 10
	//DDRD |= (1<<PD3);
	DDRB |= (1 << 3) | (1 << 2) | (1 << 4); //make port b output for PB3, PB2, PB4
    259a:	84 b1       	in	r24, 0x04	; 4
    259c:	8c 61       	ori	r24, 0x1C	; 28
    259e:	84 b9       	out	0x04, r24	; 4

	UART_init();
	
	portInit();
	
	xTimerReadings = xTimerCreate ("Timer", 5000, pdTRUE, ( void * ) 0, vTimerCallback);
    25a0:	0a e6       	ldi	r16, 0x6A	; 106
    25a2:	1f e0       	ldi	r17, 0x0F	; 15
    25a4:	20 e0       	ldi	r18, 0x00	; 0
    25a6:	30 e0       	ldi	r19, 0x00	; 0
    25a8:	41 e0       	ldi	r20, 0x01	; 1
    25aa:	68 e8       	ldi	r22, 0x88	; 136
    25ac:	73 e1       	ldi	r23, 0x13	; 19
    25ae:	85 e5       	ldi	r24, 0x55	; 85
    25b0:	91 e0       	ldi	r25, 0x01	; 1
    25b2:	0e 94 ef 0a 	call	0x15de	; 0x15de <xTimerCreate>
    25b6:	90 93 85 08 	sts	0x0885, r25	; 0x800885 <xTimerReadings+0x1>
    25ba:	80 93 84 08 	sts	0x0884, r24	; 0x800884 <xTimerReadings>

         if( xTimerReadings == NULL )
    25be:	89 2b       	or	r24, r25
    25c0:	71 f0       	breq	.+28     	; 0x25de <main+0xee>
         else
         {
             /* Start the timer.  No block time is specified, and
             even if one was it would be ignored because the RTOS
             scheduler has not yet been started. */
             if( xTimerStart( xTimerReadings, 0) != pdPASS )
    25c2:	0e 94 5b 07 	call	0xeb6	; 0xeb6 <xTaskGetTickCount>
    25c6:	00 e0       	ldi	r16, 0x00	; 0
    25c8:	10 e0       	ldi	r17, 0x00	; 0
    25ca:	20 e0       	ldi	r18, 0x00	; 0
    25cc:	30 e0       	ldi	r19, 0x00	; 0
    25ce:	ac 01       	movw	r20, r24
    25d0:	61 e0       	ldi	r22, 0x01	; 1
    25d2:	80 91 84 08 	lds	r24, 0x0884	; 0x800884 <xTimerReadings>
    25d6:	90 91 85 08 	lds	r25, 0x0885	; 0x800885 <xTimerReadings+0x1>
    25da:	0e 94 21 0b 	call	0x1642	; 0x1642 <xTimerGenericCommand>
                 state. */
             }
         }
	
    // Attempt to create a semaphores.
    xSemaphoreADC = xSemaphoreCreateBinary();
    25de:	43 e0       	ldi	r20, 0x03	; 3
    25e0:	60 e0       	ldi	r22, 0x00	; 0
    25e2:	81 e0       	ldi	r24, 0x01	; 1
    25e4:	0e 94 6d 03 	call	0x6da	; 0x6da <xQueueGenericCreate>
    25e8:	90 93 95 08 	sts	0x0895, r25	; 0x800895 <xSemaphoreADC+0x1>
    25ec:	80 93 94 08 	sts	0x0894, r24	; 0x800894 <xSemaphoreADC>
	xSemaphoreUART = xSemaphoreCreateBinary();
    25f0:	43 e0       	ldi	r20, 0x03	; 3
    25f2:	60 e0       	ldi	r22, 0x00	; 0
    25f4:	81 e0       	ldi	r24, 0x01	; 1
    25f6:	0e 94 6d 03 	call	0x6da	; 0x6da <xQueueGenericCreate>
    25fa:	90 93 83 08 	sts	0x0883, r25	; 0x800883 <xSemaphoreUART+0x1>
    25fe:	80 93 82 08 	sts	0x0882, r24	; 0x800882 <xSemaphoreUART>
	xSemaphoreLCD = xSemaphoreCreateBinary();
    2602:	43 e0       	ldi	r20, 0x03	; 3
    2604:	60 e0       	ldi	r22, 0x00	; 0
    2606:	81 e0       	ldi	r24, 0x01	; 1
    2608:	0e 94 6d 03 	call	0x6da	; 0x6da <xQueueGenericCreate>
    260c:	90 93 81 08 	sts	0x0881, r25	; 0x800881 <xSemaphoreLCD+0x1>
    2610:	80 93 80 08 	sts	0x0880, r24	; 0x800880 <xSemaphoreLCD>
	
	if( xSemaphoreADC != NULL )
    2614:	80 91 94 08 	lds	r24, 0x0894	; 0x800894 <xSemaphoreADC>
    2618:	90 91 95 08 	lds	r25, 0x0895	; 0x800895 <xSemaphoreADC+0x1>
    261c:	00 97       	sbiw	r24, 0x00	; 0
    261e:	39 f0       	breq	.+14     	; 0x262e <main+0x13e>
   {
       xSemaphoreGive(xSemaphoreADC);
    2620:	20 e0       	ldi	r18, 0x00	; 0
    2622:	40 e0       	ldi	r20, 0x00	; 0
    2624:	50 e0       	ldi	r21, 0x00	; 0
    2626:	60 e0       	ldi	r22, 0x00	; 0
    2628:	70 e0       	ldi	r23, 0x00	; 0
    262a:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
   }
   
   if( xSemaphoreUART != NULL )
    262e:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <xSemaphoreUART>
    2632:	90 91 83 08 	lds	r25, 0x0883	; 0x800883 <xSemaphoreUART+0x1>
    2636:	00 97       	sbiw	r24, 0x00	; 0
    2638:	39 f0       	breq	.+14     	; 0x2648 <main+0x158>
   {
       xSemaphoreGive(xSemaphoreUART);
    263a:	20 e0       	ldi	r18, 0x00	; 0
    263c:	40 e0       	ldi	r20, 0x00	; 0
    263e:	50 e0       	ldi	r21, 0x00	; 0
    2640:	60 e0       	ldi	r22, 0x00	; 0
    2642:	70 e0       	ldi	r23, 0x00	; 0
    2644:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
   }
   
   	if( xSemaphoreLCD != NULL )
    2648:	80 91 80 08 	lds	r24, 0x0880	; 0x800880 <xSemaphoreLCD>
    264c:	90 91 81 08 	lds	r25, 0x0881	; 0x800881 <xSemaphoreLCD+0x1>
    2650:	00 97       	sbiw	r24, 0x00	; 0
    2652:	39 f0       	breq	.+14     	; 0x2662 <main+0x172>
   	{
	   	xSemaphoreGive(xSemaphoreLCD);
    2654:	20 e0       	ldi	r18, 0x00	; 0
    2656:	40 e0       	ldi	r20, 0x00	; 0
    2658:	50 e0       	ldi	r21, 0x00	; 0
    265a:	60 e0       	ldi	r22, 0x00	; 0
    265c:	70 e0       	ldi	r23, 0x00	; 0
    265e:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
   	}
	
	xCharQueue = xQueueCreate( 2, sizeof( char * ) );
    2662:	40 e0       	ldi	r20, 0x00	; 0
    2664:	62 e0       	ldi	r22, 0x02	; 2
    2666:	82 e0       	ldi	r24, 0x02	; 2
    2668:	0e 94 6d 03 	call	0x6da	; 0x6da <xQueueGenericCreate>
    266c:	90 93 9b 08 	sts	0x089B, r25	; 0x80089b <xCharQueue+0x1>
    2670:	80 93 9a 08 	sts	0x089A, r24	; 0x80089a <xCharQueue>
	
	xQueueAirSendings = xQueueCreate( 2, sizeof (float) );
    2674:	40 e0       	ldi	r20, 0x00	; 0
    2676:	64 e0       	ldi	r22, 0x04	; 4
    2678:	82 e0       	ldi	r24, 0x02	; 2
    267a:	0e 94 6d 03 	call	0x6da	; 0x6da <xQueueGenericCreate>
    267e:	90 93 9f 08 	sts	0x089F, r25	; 0x80089f <xQueueAirSendings+0x1>
    2682:	80 93 9e 08 	sts	0x089E, r24	; 0x80089e <xQueueAirSendings>
	xQueueTemperatureSendings = xQueueCreate( 2, sizeof (float) );
    2686:	40 e0       	ldi	r20, 0x00	; 0
    2688:	64 e0       	ldi	r22, 0x04	; 4
    268a:	82 e0       	ldi	r24, 0x02	; 2
    268c:	0e 94 6d 03 	call	0x6da	; 0x6da <xQueueGenericCreate>
    2690:	90 93 8b 08 	sts	0x088B, r25	; 0x80088b <xQueueTemperatureSendings+0x1>
    2694:	80 93 8a 08 	sts	0x088A, r24	; 0x80088a <xQueueTemperatureSendings>
			
	
	
 	xTaskCreate(temperatureReadTask, "temperatureReadTask", 100, NULL, 2, &temperatureReadTaskHandle);
    2698:	0f 2e       	mov	r0, r31
    269a:	fc e9       	ldi	r31, 0x9C	; 156
    269c:	ef 2e       	mov	r14, r31
    269e:	f8 e0       	ldi	r31, 0x08	; 8
    26a0:	ff 2e       	mov	r15, r31
    26a2:	f0 2d       	mov	r31, r0
    26a4:	02 e0       	ldi	r16, 0x02	; 2
    26a6:	20 e0       	ldi	r18, 0x00	; 0
    26a8:	30 e0       	ldi	r19, 0x00	; 0
    26aa:	44 e6       	ldi	r20, 0x64	; 100
    26ac:	50 e0       	ldi	r21, 0x00	; 0
    26ae:	6b e5       	ldi	r22, 0x5B	; 91
    26b0:	71 e0       	ldi	r23, 0x01	; 1
    26b2:	8e e7       	ldi	r24, 0x7E	; 126
    26b4:	9e e0       	ldi	r25, 0x0E	; 14
    26b6:	0e 94 cb 05 	call	0xb96	; 0xb96 <xTaskCreate>
 	
 	xTaskCreate(temperatureSendTask, "temperatureSendTask", 250, NULL, 2, &temperatureSendTaskHandle);
    26ba:	0f 2e       	mov	r0, r31
    26bc:	fc e8       	ldi	r31, 0x8C	; 140
    26be:	ef 2e       	mov	r14, r31
    26c0:	f8 e0       	ldi	r31, 0x08	; 8
    26c2:	ff 2e       	mov	r15, r31
    26c4:	f0 2d       	mov	r31, r0
    26c6:	20 e0       	ldi	r18, 0x00	; 0
    26c8:	30 e0       	ldi	r19, 0x00	; 0
    26ca:	4a ef       	ldi	r20, 0xFA	; 250
    26cc:	50 e0       	ldi	r21, 0x00	; 0
    26ce:	6f e6       	ldi	r22, 0x6F	; 111
    26d0:	71 e0       	ldi	r23, 0x01	; 1
    26d2:	8b eb       	ldi	r24, 0xBB	; 187
    26d4:	90 e1       	ldi	r25, 0x10	; 16
    26d6:	0e 94 cb 05 	call	0xb96	; 0xb96 <xTaskCreate>
 	
 	xTaskCreate(airReadTask, "airReadTask", 100, NULL, 2, &AirReadTaskHandle);
    26da:	0f 2e       	mov	r0, r31
    26dc:	f8 e9       	ldi	r31, 0x98	; 152
    26de:	ef 2e       	mov	r14, r31
    26e0:	f8 e0       	ldi	r31, 0x08	; 8
    26e2:	ff 2e       	mov	r15, r31
    26e4:	f0 2d       	mov	r31, r0
    26e6:	20 e0       	ldi	r18, 0x00	; 0
    26e8:	30 e0       	ldi	r19, 0x00	; 0
    26ea:	44 e6       	ldi	r20, 0x64	; 100
    26ec:	50 e0       	ldi	r21, 0x00	; 0
    26ee:	63 e8       	ldi	r22, 0x83	; 131
    26f0:	71 e0       	ldi	r23, 0x01	; 1
    26f2:	8f ef       	ldi	r24, 0xFF	; 255
    26f4:	9e e0       	ldi	r25, 0x0E	; 14
    26f6:	0e 94 cb 05 	call	0xb96	; 0xb96 <xTaskCreate>
 	
 	xTaskCreate(airSendTask, "airSendTask", 200, NULL, 2, &AirSendTaskHandle);
    26fa:	0f 2e       	mov	r0, r31
    26fc:	fe e8       	ldi	r31, 0x8E	; 142
    26fe:	ef 2e       	mov	r14, r31
    2700:	f8 e0       	ldi	r31, 0x08	; 8
    2702:	ff 2e       	mov	r15, r31
    2704:	f0 2d       	mov	r31, r0
    2706:	20 e0       	ldi	r18, 0x00	; 0
    2708:	30 e0       	ldi	r19, 0x00	; 0
    270a:	48 ec       	ldi	r20, 0xC8	; 200
    270c:	50 e0       	ldi	r21, 0x00	; 0
    270e:	6f e8       	ldi	r22, 0x8F	; 143
    2710:	71 e0       	ldi	r23, 0x01	; 1
    2712:	85 eb       	ldi	r24, 0xB5	; 181
    2714:	91 e1       	ldi	r25, 0x11	; 17
    2716:	0e 94 cb 05 	call	0xb96	; 0xb96 <xTaskCreate>
 	
 	xTaskCreate(serialFromISRTask, "serialFromISRTask", 100, NULL, 2, &serialFromISRTaskHandle);
    271a:	0f 2e       	mov	r0, r31
    271c:	f6 e9       	ldi	r31, 0x96	; 150
    271e:	ef 2e       	mov	r14, r31
    2720:	f8 e0       	ldi	r31, 0x08	; 8
    2722:	ff 2e       	mov	r15, r31
    2724:	f0 2d       	mov	r31, r0
    2726:	20 e0       	ldi	r18, 0x00	; 0
    2728:	30 e0       	ldi	r19, 0x00	; 0
    272a:	44 e6       	ldi	r20, 0x64	; 100
    272c:	50 e0       	ldi	r21, 0x00	; 0
    272e:	6b e9       	ldi	r22, 0x9B	; 155
    2730:	71 e0       	ldi	r23, 0x01	; 1
    2732:	85 e2       	ldi	r24, 0x25	; 37
    2734:	9e e0       	ldi	r25, 0x0E	; 14
    2736:	0e 94 cb 05 	call	0xb96	; 0xb96 <xTaskCreate>
	
	sei();
    273a:	78 94       	sei
	
	// START SCHELUDER
	vTaskStartScheduler();
    273c:	0e 94 27 07 	call	0xe4e	; 0xe4e <vTaskStartScheduler>
    2740:	ff cf       	rjmp	.-2      	; 0x2740 <main+0x250>

00002742 <vApplicationIdleHook>:

}

// IDLE TASK
void vApplicationIdleHook(void)
{
    2742:	08 95       	ret

00002744 <__subsf3>:
    2744:	50 58       	subi	r21, 0x80	; 128

00002746 <__addsf3>:
    2746:	bb 27       	eor	r27, r27
    2748:	aa 27       	eor	r26, r26
    274a:	0e 94 ba 13 	call	0x2774	; 0x2774 <__addsf3x>
    274e:	0c 94 04 15 	jmp	0x2a08	; 0x2a08 <__fp_round>
    2752:	0e 94 f6 14 	call	0x29ec	; 0x29ec <__fp_pscA>
    2756:	38 f0       	brcs	.+14     	; 0x2766 <__addsf3+0x20>
    2758:	0e 94 fd 14 	call	0x29fa	; 0x29fa <__fp_pscB>
    275c:	20 f0       	brcs	.+8      	; 0x2766 <__addsf3+0x20>
    275e:	39 f4       	brne	.+14     	; 0x276e <__addsf3+0x28>
    2760:	9f 3f       	cpi	r25, 0xFF	; 255
    2762:	19 f4       	brne	.+6      	; 0x276a <__addsf3+0x24>
    2764:	26 f4       	brtc	.+8      	; 0x276e <__addsf3+0x28>
    2766:	0c 94 f3 14 	jmp	0x29e6	; 0x29e6 <__fp_nan>
    276a:	0e f4       	brtc	.+2      	; 0x276e <__addsf3+0x28>
    276c:	e0 95       	com	r30
    276e:	e7 fb       	bst	r30, 7
    2770:	0c 94 ed 14 	jmp	0x29da	; 0x29da <__fp_inf>

00002774 <__addsf3x>:
    2774:	e9 2f       	mov	r30, r25
    2776:	0e 94 15 15 	call	0x2a2a	; 0x2a2a <__fp_split3>
    277a:	58 f3       	brcs	.-42     	; 0x2752 <__addsf3+0xc>
    277c:	ba 17       	cp	r27, r26
    277e:	62 07       	cpc	r22, r18
    2780:	73 07       	cpc	r23, r19
    2782:	84 07       	cpc	r24, r20
    2784:	95 07       	cpc	r25, r21
    2786:	20 f0       	brcs	.+8      	; 0x2790 <__addsf3x+0x1c>
    2788:	79 f4       	brne	.+30     	; 0x27a8 <__addsf3x+0x34>
    278a:	a6 f5       	brtc	.+104    	; 0x27f4 <__addsf3x+0x80>
    278c:	0c 94 37 15 	jmp	0x2a6e	; 0x2a6e <__fp_zero>
    2790:	0e f4       	brtc	.+2      	; 0x2794 <__addsf3x+0x20>
    2792:	e0 95       	com	r30
    2794:	0b 2e       	mov	r0, r27
    2796:	ba 2f       	mov	r27, r26
    2798:	a0 2d       	mov	r26, r0
    279a:	0b 01       	movw	r0, r22
    279c:	b9 01       	movw	r22, r18
    279e:	90 01       	movw	r18, r0
    27a0:	0c 01       	movw	r0, r24
    27a2:	ca 01       	movw	r24, r20
    27a4:	a0 01       	movw	r20, r0
    27a6:	11 24       	eor	r1, r1
    27a8:	ff 27       	eor	r31, r31
    27aa:	59 1b       	sub	r21, r25
    27ac:	99 f0       	breq	.+38     	; 0x27d4 <__addsf3x+0x60>
    27ae:	59 3f       	cpi	r21, 0xF9	; 249
    27b0:	50 f4       	brcc	.+20     	; 0x27c6 <__addsf3x+0x52>
    27b2:	50 3e       	cpi	r21, 0xE0	; 224
    27b4:	68 f1       	brcs	.+90     	; 0x2810 <__addsf3x+0x9c>
    27b6:	1a 16       	cp	r1, r26
    27b8:	f0 40       	sbci	r31, 0x00	; 0
    27ba:	a2 2f       	mov	r26, r18
    27bc:	23 2f       	mov	r18, r19
    27be:	34 2f       	mov	r19, r20
    27c0:	44 27       	eor	r20, r20
    27c2:	58 5f       	subi	r21, 0xF8	; 248
    27c4:	f3 cf       	rjmp	.-26     	; 0x27ac <__addsf3x+0x38>
    27c6:	46 95       	lsr	r20
    27c8:	37 95       	ror	r19
    27ca:	27 95       	ror	r18
    27cc:	a7 95       	ror	r26
    27ce:	f0 40       	sbci	r31, 0x00	; 0
    27d0:	53 95       	inc	r21
    27d2:	c9 f7       	brne	.-14     	; 0x27c6 <__addsf3x+0x52>
    27d4:	7e f4       	brtc	.+30     	; 0x27f4 <__addsf3x+0x80>
    27d6:	1f 16       	cp	r1, r31
    27d8:	ba 0b       	sbc	r27, r26
    27da:	62 0b       	sbc	r22, r18
    27dc:	73 0b       	sbc	r23, r19
    27de:	84 0b       	sbc	r24, r20
    27e0:	ba f0       	brmi	.+46     	; 0x2810 <__addsf3x+0x9c>
    27e2:	91 50       	subi	r25, 0x01	; 1
    27e4:	a1 f0       	breq	.+40     	; 0x280e <__addsf3x+0x9a>
    27e6:	ff 0f       	add	r31, r31
    27e8:	bb 1f       	adc	r27, r27
    27ea:	66 1f       	adc	r22, r22
    27ec:	77 1f       	adc	r23, r23
    27ee:	88 1f       	adc	r24, r24
    27f0:	c2 f7       	brpl	.-16     	; 0x27e2 <__addsf3x+0x6e>
    27f2:	0e c0       	rjmp	.+28     	; 0x2810 <__addsf3x+0x9c>
    27f4:	ba 0f       	add	r27, r26
    27f6:	62 1f       	adc	r22, r18
    27f8:	73 1f       	adc	r23, r19
    27fa:	84 1f       	adc	r24, r20
    27fc:	48 f4       	brcc	.+18     	; 0x2810 <__addsf3x+0x9c>
    27fe:	87 95       	ror	r24
    2800:	77 95       	ror	r23
    2802:	67 95       	ror	r22
    2804:	b7 95       	ror	r27
    2806:	f7 95       	ror	r31
    2808:	9e 3f       	cpi	r25, 0xFE	; 254
    280a:	08 f0       	brcs	.+2      	; 0x280e <__addsf3x+0x9a>
    280c:	b0 cf       	rjmp	.-160    	; 0x276e <__addsf3+0x28>
    280e:	93 95       	inc	r25
    2810:	88 0f       	add	r24, r24
    2812:	08 f0       	brcs	.+2      	; 0x2816 <__addsf3x+0xa2>
    2814:	99 27       	eor	r25, r25
    2816:	ee 0f       	add	r30, r30
    2818:	97 95       	ror	r25
    281a:	87 95       	ror	r24
    281c:	08 95       	ret

0000281e <__divsf3>:
    281e:	0e 94 23 14 	call	0x2846	; 0x2846 <__divsf3x>
    2822:	0c 94 04 15 	jmp	0x2a08	; 0x2a08 <__fp_round>
    2826:	0e 94 fd 14 	call	0x29fa	; 0x29fa <__fp_pscB>
    282a:	58 f0       	brcs	.+22     	; 0x2842 <__divsf3+0x24>
    282c:	0e 94 f6 14 	call	0x29ec	; 0x29ec <__fp_pscA>
    2830:	40 f0       	brcs	.+16     	; 0x2842 <__divsf3+0x24>
    2832:	29 f4       	brne	.+10     	; 0x283e <__divsf3+0x20>
    2834:	5f 3f       	cpi	r21, 0xFF	; 255
    2836:	29 f0       	breq	.+10     	; 0x2842 <__divsf3+0x24>
    2838:	0c 94 ed 14 	jmp	0x29da	; 0x29da <__fp_inf>
    283c:	51 11       	cpse	r21, r1
    283e:	0c 94 38 15 	jmp	0x2a70	; 0x2a70 <__fp_szero>
    2842:	0c 94 f3 14 	jmp	0x29e6	; 0x29e6 <__fp_nan>

00002846 <__divsf3x>:
    2846:	0e 94 15 15 	call	0x2a2a	; 0x2a2a <__fp_split3>
    284a:	68 f3       	brcs	.-38     	; 0x2826 <__divsf3+0x8>

0000284c <__divsf3_pse>:
    284c:	99 23       	and	r25, r25
    284e:	b1 f3       	breq	.-20     	; 0x283c <__divsf3+0x1e>
    2850:	55 23       	and	r21, r21
    2852:	91 f3       	breq	.-28     	; 0x2838 <__divsf3+0x1a>
    2854:	95 1b       	sub	r25, r21
    2856:	55 0b       	sbc	r21, r21
    2858:	bb 27       	eor	r27, r27
    285a:	aa 27       	eor	r26, r26
    285c:	62 17       	cp	r22, r18
    285e:	73 07       	cpc	r23, r19
    2860:	84 07       	cpc	r24, r20
    2862:	38 f0       	brcs	.+14     	; 0x2872 <__divsf3_pse+0x26>
    2864:	9f 5f       	subi	r25, 0xFF	; 255
    2866:	5f 4f       	sbci	r21, 0xFF	; 255
    2868:	22 0f       	add	r18, r18
    286a:	33 1f       	adc	r19, r19
    286c:	44 1f       	adc	r20, r20
    286e:	aa 1f       	adc	r26, r26
    2870:	a9 f3       	breq	.-22     	; 0x285c <__divsf3_pse+0x10>
    2872:	35 d0       	rcall	.+106    	; 0x28de <__divsf3_pse+0x92>
    2874:	0e 2e       	mov	r0, r30
    2876:	3a f0       	brmi	.+14     	; 0x2886 <__divsf3_pse+0x3a>
    2878:	e0 e8       	ldi	r30, 0x80	; 128
    287a:	32 d0       	rcall	.+100    	; 0x28e0 <__divsf3_pse+0x94>
    287c:	91 50       	subi	r25, 0x01	; 1
    287e:	50 40       	sbci	r21, 0x00	; 0
    2880:	e6 95       	lsr	r30
    2882:	00 1c       	adc	r0, r0
    2884:	ca f7       	brpl	.-14     	; 0x2878 <__divsf3_pse+0x2c>
    2886:	2b d0       	rcall	.+86     	; 0x28de <__divsf3_pse+0x92>
    2888:	fe 2f       	mov	r31, r30
    288a:	29 d0       	rcall	.+82     	; 0x28de <__divsf3_pse+0x92>
    288c:	66 0f       	add	r22, r22
    288e:	77 1f       	adc	r23, r23
    2890:	88 1f       	adc	r24, r24
    2892:	bb 1f       	adc	r27, r27
    2894:	26 17       	cp	r18, r22
    2896:	37 07       	cpc	r19, r23
    2898:	48 07       	cpc	r20, r24
    289a:	ab 07       	cpc	r26, r27
    289c:	b0 e8       	ldi	r27, 0x80	; 128
    289e:	09 f0       	breq	.+2      	; 0x28a2 <__divsf3_pse+0x56>
    28a0:	bb 0b       	sbc	r27, r27
    28a2:	80 2d       	mov	r24, r0
    28a4:	bf 01       	movw	r22, r30
    28a6:	ff 27       	eor	r31, r31
    28a8:	93 58       	subi	r25, 0x83	; 131
    28aa:	5f 4f       	sbci	r21, 0xFF	; 255
    28ac:	3a f0       	brmi	.+14     	; 0x28bc <__divsf3_pse+0x70>
    28ae:	9e 3f       	cpi	r25, 0xFE	; 254
    28b0:	51 05       	cpc	r21, r1
    28b2:	78 f0       	brcs	.+30     	; 0x28d2 <__divsf3_pse+0x86>
    28b4:	0c 94 ed 14 	jmp	0x29da	; 0x29da <__fp_inf>
    28b8:	0c 94 38 15 	jmp	0x2a70	; 0x2a70 <__fp_szero>
    28bc:	5f 3f       	cpi	r21, 0xFF	; 255
    28be:	e4 f3       	brlt	.-8      	; 0x28b8 <__divsf3_pse+0x6c>
    28c0:	98 3e       	cpi	r25, 0xE8	; 232
    28c2:	d4 f3       	brlt	.-12     	; 0x28b8 <__divsf3_pse+0x6c>
    28c4:	86 95       	lsr	r24
    28c6:	77 95       	ror	r23
    28c8:	67 95       	ror	r22
    28ca:	b7 95       	ror	r27
    28cc:	f7 95       	ror	r31
    28ce:	9f 5f       	subi	r25, 0xFF	; 255
    28d0:	c9 f7       	brne	.-14     	; 0x28c4 <__divsf3_pse+0x78>
    28d2:	88 0f       	add	r24, r24
    28d4:	91 1d       	adc	r25, r1
    28d6:	96 95       	lsr	r25
    28d8:	87 95       	ror	r24
    28da:	97 f9       	bld	r25, 7
    28dc:	08 95       	ret
    28de:	e1 e0       	ldi	r30, 0x01	; 1
    28e0:	66 0f       	add	r22, r22
    28e2:	77 1f       	adc	r23, r23
    28e4:	88 1f       	adc	r24, r24
    28e6:	bb 1f       	adc	r27, r27
    28e8:	62 17       	cp	r22, r18
    28ea:	73 07       	cpc	r23, r19
    28ec:	84 07       	cpc	r24, r20
    28ee:	ba 07       	cpc	r27, r26
    28f0:	20 f0       	brcs	.+8      	; 0x28fa <__divsf3_pse+0xae>
    28f2:	62 1b       	sub	r22, r18
    28f4:	73 0b       	sbc	r23, r19
    28f6:	84 0b       	sbc	r24, r20
    28f8:	ba 0b       	sbc	r27, r26
    28fa:	ee 1f       	adc	r30, r30
    28fc:	88 f7       	brcc	.-30     	; 0x28e0 <__divsf3_pse+0x94>
    28fe:	e0 95       	com	r30
    2900:	08 95       	ret

00002902 <__fixunssfsi>:
    2902:	0e 94 1d 15 	call	0x2a3a	; 0x2a3a <__fp_splitA>
    2906:	88 f0       	brcs	.+34     	; 0x292a <__fixunssfsi+0x28>
    2908:	9f 57       	subi	r25, 0x7F	; 127
    290a:	98 f0       	brcs	.+38     	; 0x2932 <__fixunssfsi+0x30>
    290c:	b9 2f       	mov	r27, r25
    290e:	99 27       	eor	r25, r25
    2910:	b7 51       	subi	r27, 0x17	; 23
    2912:	b0 f0       	brcs	.+44     	; 0x2940 <__fixunssfsi+0x3e>
    2914:	e1 f0       	breq	.+56     	; 0x294e <__fixunssfsi+0x4c>
    2916:	66 0f       	add	r22, r22
    2918:	77 1f       	adc	r23, r23
    291a:	88 1f       	adc	r24, r24
    291c:	99 1f       	adc	r25, r25
    291e:	1a f0       	brmi	.+6      	; 0x2926 <__fixunssfsi+0x24>
    2920:	ba 95       	dec	r27
    2922:	c9 f7       	brne	.-14     	; 0x2916 <__fixunssfsi+0x14>
    2924:	14 c0       	rjmp	.+40     	; 0x294e <__fixunssfsi+0x4c>
    2926:	b1 30       	cpi	r27, 0x01	; 1
    2928:	91 f0       	breq	.+36     	; 0x294e <__fixunssfsi+0x4c>
    292a:	0e 94 37 15 	call	0x2a6e	; 0x2a6e <__fp_zero>
    292e:	b1 e0       	ldi	r27, 0x01	; 1
    2930:	08 95       	ret
    2932:	0c 94 37 15 	jmp	0x2a6e	; 0x2a6e <__fp_zero>
    2936:	67 2f       	mov	r22, r23
    2938:	78 2f       	mov	r23, r24
    293a:	88 27       	eor	r24, r24
    293c:	b8 5f       	subi	r27, 0xF8	; 248
    293e:	39 f0       	breq	.+14     	; 0x294e <__fixunssfsi+0x4c>
    2940:	b9 3f       	cpi	r27, 0xF9	; 249
    2942:	cc f3       	brlt	.-14     	; 0x2936 <__fixunssfsi+0x34>
    2944:	86 95       	lsr	r24
    2946:	77 95       	ror	r23
    2948:	67 95       	ror	r22
    294a:	b3 95       	inc	r27
    294c:	d9 f7       	brne	.-10     	; 0x2944 <__fixunssfsi+0x42>
    294e:	3e f4       	brtc	.+14     	; 0x295e <__fixunssfsi+0x5c>
    2950:	90 95       	com	r25
    2952:	80 95       	com	r24
    2954:	70 95       	com	r23
    2956:	61 95       	neg	r22
    2958:	7f 4f       	sbci	r23, 0xFF	; 255
    295a:	8f 4f       	sbci	r24, 0xFF	; 255
    295c:	9f 4f       	sbci	r25, 0xFF	; 255
    295e:	08 95       	ret

00002960 <__floatunsisf>:
    2960:	e8 94       	clt
    2962:	09 c0       	rjmp	.+18     	; 0x2976 <__floatsisf+0x12>

00002964 <__floatsisf>:
    2964:	97 fb       	bst	r25, 7
    2966:	3e f4       	brtc	.+14     	; 0x2976 <__floatsisf+0x12>
    2968:	90 95       	com	r25
    296a:	80 95       	com	r24
    296c:	70 95       	com	r23
    296e:	61 95       	neg	r22
    2970:	7f 4f       	sbci	r23, 0xFF	; 255
    2972:	8f 4f       	sbci	r24, 0xFF	; 255
    2974:	9f 4f       	sbci	r25, 0xFF	; 255
    2976:	99 23       	and	r25, r25
    2978:	a9 f0       	breq	.+42     	; 0x29a4 <__floatsisf+0x40>
    297a:	f9 2f       	mov	r31, r25
    297c:	96 e9       	ldi	r25, 0x96	; 150
    297e:	bb 27       	eor	r27, r27
    2980:	93 95       	inc	r25
    2982:	f6 95       	lsr	r31
    2984:	87 95       	ror	r24
    2986:	77 95       	ror	r23
    2988:	67 95       	ror	r22
    298a:	b7 95       	ror	r27
    298c:	f1 11       	cpse	r31, r1
    298e:	f8 cf       	rjmp	.-16     	; 0x2980 <__floatsisf+0x1c>
    2990:	fa f4       	brpl	.+62     	; 0x29d0 <__floatsisf+0x6c>
    2992:	bb 0f       	add	r27, r27
    2994:	11 f4       	brne	.+4      	; 0x299a <__floatsisf+0x36>
    2996:	60 ff       	sbrs	r22, 0
    2998:	1b c0       	rjmp	.+54     	; 0x29d0 <__floatsisf+0x6c>
    299a:	6f 5f       	subi	r22, 0xFF	; 255
    299c:	7f 4f       	sbci	r23, 0xFF	; 255
    299e:	8f 4f       	sbci	r24, 0xFF	; 255
    29a0:	9f 4f       	sbci	r25, 0xFF	; 255
    29a2:	16 c0       	rjmp	.+44     	; 0x29d0 <__floatsisf+0x6c>
    29a4:	88 23       	and	r24, r24
    29a6:	11 f0       	breq	.+4      	; 0x29ac <__floatsisf+0x48>
    29a8:	96 e9       	ldi	r25, 0x96	; 150
    29aa:	11 c0       	rjmp	.+34     	; 0x29ce <__floatsisf+0x6a>
    29ac:	77 23       	and	r23, r23
    29ae:	21 f0       	breq	.+8      	; 0x29b8 <__floatsisf+0x54>
    29b0:	9e e8       	ldi	r25, 0x8E	; 142
    29b2:	87 2f       	mov	r24, r23
    29b4:	76 2f       	mov	r23, r22
    29b6:	05 c0       	rjmp	.+10     	; 0x29c2 <__floatsisf+0x5e>
    29b8:	66 23       	and	r22, r22
    29ba:	71 f0       	breq	.+28     	; 0x29d8 <__floatsisf+0x74>
    29bc:	96 e8       	ldi	r25, 0x86	; 134
    29be:	86 2f       	mov	r24, r22
    29c0:	70 e0       	ldi	r23, 0x00	; 0
    29c2:	60 e0       	ldi	r22, 0x00	; 0
    29c4:	2a f0       	brmi	.+10     	; 0x29d0 <__floatsisf+0x6c>
    29c6:	9a 95       	dec	r25
    29c8:	66 0f       	add	r22, r22
    29ca:	77 1f       	adc	r23, r23
    29cc:	88 1f       	adc	r24, r24
    29ce:	da f7       	brpl	.-10     	; 0x29c6 <__floatsisf+0x62>
    29d0:	88 0f       	add	r24, r24
    29d2:	96 95       	lsr	r25
    29d4:	87 95       	ror	r24
    29d6:	97 f9       	bld	r25, 7
    29d8:	08 95       	ret

000029da <__fp_inf>:
    29da:	97 f9       	bld	r25, 7
    29dc:	9f 67       	ori	r25, 0x7F	; 127
    29de:	80 e8       	ldi	r24, 0x80	; 128
    29e0:	70 e0       	ldi	r23, 0x00	; 0
    29e2:	60 e0       	ldi	r22, 0x00	; 0
    29e4:	08 95       	ret

000029e6 <__fp_nan>:
    29e6:	9f ef       	ldi	r25, 0xFF	; 255
    29e8:	80 ec       	ldi	r24, 0xC0	; 192
    29ea:	08 95       	ret

000029ec <__fp_pscA>:
    29ec:	00 24       	eor	r0, r0
    29ee:	0a 94       	dec	r0
    29f0:	16 16       	cp	r1, r22
    29f2:	17 06       	cpc	r1, r23
    29f4:	18 06       	cpc	r1, r24
    29f6:	09 06       	cpc	r0, r25
    29f8:	08 95       	ret

000029fa <__fp_pscB>:
    29fa:	00 24       	eor	r0, r0
    29fc:	0a 94       	dec	r0
    29fe:	12 16       	cp	r1, r18
    2a00:	13 06       	cpc	r1, r19
    2a02:	14 06       	cpc	r1, r20
    2a04:	05 06       	cpc	r0, r21
    2a06:	08 95       	ret

00002a08 <__fp_round>:
    2a08:	09 2e       	mov	r0, r25
    2a0a:	03 94       	inc	r0
    2a0c:	00 0c       	add	r0, r0
    2a0e:	11 f4       	brne	.+4      	; 0x2a14 <__fp_round+0xc>
    2a10:	88 23       	and	r24, r24
    2a12:	52 f0       	brmi	.+20     	; 0x2a28 <__fp_round+0x20>
    2a14:	bb 0f       	add	r27, r27
    2a16:	40 f4       	brcc	.+16     	; 0x2a28 <__fp_round+0x20>
    2a18:	bf 2b       	or	r27, r31
    2a1a:	11 f4       	brne	.+4      	; 0x2a20 <__fp_round+0x18>
    2a1c:	60 ff       	sbrs	r22, 0
    2a1e:	04 c0       	rjmp	.+8      	; 0x2a28 <__fp_round+0x20>
    2a20:	6f 5f       	subi	r22, 0xFF	; 255
    2a22:	7f 4f       	sbci	r23, 0xFF	; 255
    2a24:	8f 4f       	sbci	r24, 0xFF	; 255
    2a26:	9f 4f       	sbci	r25, 0xFF	; 255
    2a28:	08 95       	ret

00002a2a <__fp_split3>:
    2a2a:	57 fd       	sbrc	r21, 7
    2a2c:	90 58       	subi	r25, 0x80	; 128
    2a2e:	44 0f       	add	r20, r20
    2a30:	55 1f       	adc	r21, r21
    2a32:	59 f0       	breq	.+22     	; 0x2a4a <__fp_splitA+0x10>
    2a34:	5f 3f       	cpi	r21, 0xFF	; 255
    2a36:	71 f0       	breq	.+28     	; 0x2a54 <__fp_splitA+0x1a>
    2a38:	47 95       	ror	r20

00002a3a <__fp_splitA>:
    2a3a:	88 0f       	add	r24, r24
    2a3c:	97 fb       	bst	r25, 7
    2a3e:	99 1f       	adc	r25, r25
    2a40:	61 f0       	breq	.+24     	; 0x2a5a <__fp_splitA+0x20>
    2a42:	9f 3f       	cpi	r25, 0xFF	; 255
    2a44:	79 f0       	breq	.+30     	; 0x2a64 <__fp_splitA+0x2a>
    2a46:	87 95       	ror	r24
    2a48:	08 95       	ret
    2a4a:	12 16       	cp	r1, r18
    2a4c:	13 06       	cpc	r1, r19
    2a4e:	14 06       	cpc	r1, r20
    2a50:	55 1f       	adc	r21, r21
    2a52:	f2 cf       	rjmp	.-28     	; 0x2a38 <__fp_split3+0xe>
    2a54:	46 95       	lsr	r20
    2a56:	f1 df       	rcall	.-30     	; 0x2a3a <__fp_splitA>
    2a58:	08 c0       	rjmp	.+16     	; 0x2a6a <__fp_splitA+0x30>
    2a5a:	16 16       	cp	r1, r22
    2a5c:	17 06       	cpc	r1, r23
    2a5e:	18 06       	cpc	r1, r24
    2a60:	99 1f       	adc	r25, r25
    2a62:	f1 cf       	rjmp	.-30     	; 0x2a46 <__fp_splitA+0xc>
    2a64:	86 95       	lsr	r24
    2a66:	71 05       	cpc	r23, r1
    2a68:	61 05       	cpc	r22, r1
    2a6a:	08 94       	sec
    2a6c:	08 95       	ret

00002a6e <__fp_zero>:
    2a6e:	e8 94       	clt

00002a70 <__fp_szero>:
    2a70:	bb 27       	eor	r27, r27
    2a72:	66 27       	eor	r22, r22
    2a74:	77 27       	eor	r23, r23
    2a76:	cb 01       	movw	r24, r22
    2a78:	97 f9       	bld	r25, 7
    2a7a:	08 95       	ret

00002a7c <__gesf2>:
    2a7c:	0e 94 b0 15 	call	0x2b60	; 0x2b60 <__fp_cmp>
    2a80:	08 f4       	brcc	.+2      	; 0x2a84 <__gesf2+0x8>
    2a82:	8f ef       	ldi	r24, 0xFF	; 255
    2a84:	08 95       	ret

00002a86 <__mulsf3>:
    2a86:	0e 94 56 15 	call	0x2aac	; 0x2aac <__mulsf3x>
    2a8a:	0c 94 04 15 	jmp	0x2a08	; 0x2a08 <__fp_round>
    2a8e:	0e 94 f6 14 	call	0x29ec	; 0x29ec <__fp_pscA>
    2a92:	38 f0       	brcs	.+14     	; 0x2aa2 <__mulsf3+0x1c>
    2a94:	0e 94 fd 14 	call	0x29fa	; 0x29fa <__fp_pscB>
    2a98:	20 f0       	brcs	.+8      	; 0x2aa2 <__mulsf3+0x1c>
    2a9a:	95 23       	and	r25, r21
    2a9c:	11 f0       	breq	.+4      	; 0x2aa2 <__mulsf3+0x1c>
    2a9e:	0c 94 ed 14 	jmp	0x29da	; 0x29da <__fp_inf>
    2aa2:	0c 94 f3 14 	jmp	0x29e6	; 0x29e6 <__fp_nan>
    2aa6:	11 24       	eor	r1, r1
    2aa8:	0c 94 38 15 	jmp	0x2a70	; 0x2a70 <__fp_szero>

00002aac <__mulsf3x>:
    2aac:	0e 94 15 15 	call	0x2a2a	; 0x2a2a <__fp_split3>
    2ab0:	70 f3       	brcs	.-36     	; 0x2a8e <__mulsf3+0x8>

00002ab2 <__mulsf3_pse>:
    2ab2:	95 9f       	mul	r25, r21
    2ab4:	c1 f3       	breq	.-16     	; 0x2aa6 <__mulsf3+0x20>
    2ab6:	95 0f       	add	r25, r21
    2ab8:	50 e0       	ldi	r21, 0x00	; 0
    2aba:	55 1f       	adc	r21, r21
    2abc:	62 9f       	mul	r22, r18
    2abe:	f0 01       	movw	r30, r0
    2ac0:	72 9f       	mul	r23, r18
    2ac2:	bb 27       	eor	r27, r27
    2ac4:	f0 0d       	add	r31, r0
    2ac6:	b1 1d       	adc	r27, r1
    2ac8:	63 9f       	mul	r22, r19
    2aca:	aa 27       	eor	r26, r26
    2acc:	f0 0d       	add	r31, r0
    2ace:	b1 1d       	adc	r27, r1
    2ad0:	aa 1f       	adc	r26, r26
    2ad2:	64 9f       	mul	r22, r20
    2ad4:	66 27       	eor	r22, r22
    2ad6:	b0 0d       	add	r27, r0
    2ad8:	a1 1d       	adc	r26, r1
    2ada:	66 1f       	adc	r22, r22
    2adc:	82 9f       	mul	r24, r18
    2ade:	22 27       	eor	r18, r18
    2ae0:	b0 0d       	add	r27, r0
    2ae2:	a1 1d       	adc	r26, r1
    2ae4:	62 1f       	adc	r22, r18
    2ae6:	73 9f       	mul	r23, r19
    2ae8:	b0 0d       	add	r27, r0
    2aea:	a1 1d       	adc	r26, r1
    2aec:	62 1f       	adc	r22, r18
    2aee:	83 9f       	mul	r24, r19
    2af0:	a0 0d       	add	r26, r0
    2af2:	61 1d       	adc	r22, r1
    2af4:	22 1f       	adc	r18, r18
    2af6:	74 9f       	mul	r23, r20
    2af8:	33 27       	eor	r19, r19
    2afa:	a0 0d       	add	r26, r0
    2afc:	61 1d       	adc	r22, r1
    2afe:	23 1f       	adc	r18, r19
    2b00:	84 9f       	mul	r24, r20
    2b02:	60 0d       	add	r22, r0
    2b04:	21 1d       	adc	r18, r1
    2b06:	82 2f       	mov	r24, r18
    2b08:	76 2f       	mov	r23, r22
    2b0a:	6a 2f       	mov	r22, r26
    2b0c:	11 24       	eor	r1, r1
    2b0e:	9f 57       	subi	r25, 0x7F	; 127
    2b10:	50 40       	sbci	r21, 0x00	; 0
    2b12:	9a f0       	brmi	.+38     	; 0x2b3a <__mulsf3_pse+0x88>
    2b14:	f1 f0       	breq	.+60     	; 0x2b52 <__mulsf3_pse+0xa0>
    2b16:	88 23       	and	r24, r24
    2b18:	4a f0       	brmi	.+18     	; 0x2b2c <__mulsf3_pse+0x7a>
    2b1a:	ee 0f       	add	r30, r30
    2b1c:	ff 1f       	adc	r31, r31
    2b1e:	bb 1f       	adc	r27, r27
    2b20:	66 1f       	adc	r22, r22
    2b22:	77 1f       	adc	r23, r23
    2b24:	88 1f       	adc	r24, r24
    2b26:	91 50       	subi	r25, 0x01	; 1
    2b28:	50 40       	sbci	r21, 0x00	; 0
    2b2a:	a9 f7       	brne	.-22     	; 0x2b16 <__mulsf3_pse+0x64>
    2b2c:	9e 3f       	cpi	r25, 0xFE	; 254
    2b2e:	51 05       	cpc	r21, r1
    2b30:	80 f0       	brcs	.+32     	; 0x2b52 <__mulsf3_pse+0xa0>
    2b32:	0c 94 ed 14 	jmp	0x29da	; 0x29da <__fp_inf>
    2b36:	0c 94 38 15 	jmp	0x2a70	; 0x2a70 <__fp_szero>
    2b3a:	5f 3f       	cpi	r21, 0xFF	; 255
    2b3c:	e4 f3       	brlt	.-8      	; 0x2b36 <__mulsf3_pse+0x84>
    2b3e:	98 3e       	cpi	r25, 0xE8	; 232
    2b40:	d4 f3       	brlt	.-12     	; 0x2b36 <__mulsf3_pse+0x84>
    2b42:	86 95       	lsr	r24
    2b44:	77 95       	ror	r23
    2b46:	67 95       	ror	r22
    2b48:	b7 95       	ror	r27
    2b4a:	f7 95       	ror	r31
    2b4c:	e7 95       	ror	r30
    2b4e:	9f 5f       	subi	r25, 0xFF	; 255
    2b50:	c1 f7       	brne	.-16     	; 0x2b42 <__mulsf3_pse+0x90>
    2b52:	fe 2b       	or	r31, r30
    2b54:	88 0f       	add	r24, r24
    2b56:	91 1d       	adc	r25, r1
    2b58:	96 95       	lsr	r25
    2b5a:	87 95       	ror	r24
    2b5c:	97 f9       	bld	r25, 7
    2b5e:	08 95       	ret

00002b60 <__fp_cmp>:
    2b60:	99 0f       	add	r25, r25
    2b62:	00 08       	sbc	r0, r0
    2b64:	55 0f       	add	r21, r21
    2b66:	aa 0b       	sbc	r26, r26
    2b68:	e0 e8       	ldi	r30, 0x80	; 128
    2b6a:	fe ef       	ldi	r31, 0xFE	; 254
    2b6c:	16 16       	cp	r1, r22
    2b6e:	17 06       	cpc	r1, r23
    2b70:	e8 07       	cpc	r30, r24
    2b72:	f9 07       	cpc	r31, r25
    2b74:	c0 f0       	brcs	.+48     	; 0x2ba6 <__fp_cmp+0x46>
    2b76:	12 16       	cp	r1, r18
    2b78:	13 06       	cpc	r1, r19
    2b7a:	e4 07       	cpc	r30, r20
    2b7c:	f5 07       	cpc	r31, r21
    2b7e:	98 f0       	brcs	.+38     	; 0x2ba6 <__fp_cmp+0x46>
    2b80:	62 1b       	sub	r22, r18
    2b82:	73 0b       	sbc	r23, r19
    2b84:	84 0b       	sbc	r24, r20
    2b86:	95 0b       	sbc	r25, r21
    2b88:	39 f4       	brne	.+14     	; 0x2b98 <__fp_cmp+0x38>
    2b8a:	0a 26       	eor	r0, r26
    2b8c:	61 f0       	breq	.+24     	; 0x2ba6 <__fp_cmp+0x46>
    2b8e:	23 2b       	or	r18, r19
    2b90:	24 2b       	or	r18, r20
    2b92:	25 2b       	or	r18, r21
    2b94:	21 f4       	brne	.+8      	; 0x2b9e <__fp_cmp+0x3e>
    2b96:	08 95       	ret
    2b98:	0a 26       	eor	r0, r26
    2b9a:	09 f4       	brne	.+2      	; 0x2b9e <__fp_cmp+0x3e>
    2b9c:	a1 40       	sbci	r26, 0x01	; 1
    2b9e:	a6 95       	lsr	r26
    2ba0:	8f ef       	ldi	r24, 0xFF	; 255
    2ba2:	81 1d       	adc	r24, r1
    2ba4:	81 1d       	adc	r24, r1
    2ba6:	08 95       	ret

00002ba8 <__tablejump2__>:
    2ba8:	ee 0f       	add	r30, r30
    2baa:	ff 1f       	adc	r31, r31
    2bac:	05 90       	lpm	r0, Z+
    2bae:	f4 91       	lpm	r31, Z
    2bb0:	e0 2d       	mov	r30, r0
    2bb2:	09 94       	ijmp

00002bb4 <__umulhisi3>:
    2bb4:	a2 9f       	mul	r26, r18
    2bb6:	b0 01       	movw	r22, r0
    2bb8:	b3 9f       	mul	r27, r19
    2bba:	c0 01       	movw	r24, r0
    2bbc:	a3 9f       	mul	r26, r19
    2bbe:	70 0d       	add	r23, r0
    2bc0:	81 1d       	adc	r24, r1
    2bc2:	11 24       	eor	r1, r1
    2bc4:	91 1d       	adc	r25, r1
    2bc6:	b2 9f       	mul	r27, r18
    2bc8:	70 0d       	add	r23, r0
    2bca:	81 1d       	adc	r24, r1
    2bcc:	11 24       	eor	r1, r1
    2bce:	91 1d       	adc	r25, r1
    2bd0:	08 95       	ret

00002bd2 <memcpy>:
    2bd2:	fb 01       	movw	r30, r22
    2bd4:	dc 01       	movw	r26, r24
    2bd6:	02 c0       	rjmp	.+4      	; 0x2bdc <memcpy+0xa>
    2bd8:	01 90       	ld	r0, Z+
    2bda:	0d 92       	st	X+, r0
    2bdc:	41 50       	subi	r20, 0x01	; 1
    2bde:	50 40       	sbci	r21, 0x00	; 0
    2be0:	d8 f7       	brcc	.-10     	; 0x2bd8 <memcpy+0x6>
    2be2:	08 95       	ret

00002be4 <_exit>:
    2be4:	f8 94       	cli

00002be6 <__stop_program>:
    2be6:	ff cf       	rjmp	.-2      	; 0x2be6 <__stop_program>
