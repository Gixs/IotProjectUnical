
ArduinoFreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000186  00800100  00002ac0  00002b54  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002ac0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000625  00800286  00800286  00002cda  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002cda  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002d0c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000420  00000000  00000000  00002d4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005ef6  00000000  00000000  0000316c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001060  00000000  00000000  00009062  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002e9b  00000000  00000000  0000a0c2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000ce8  00000000  00000000  0000cf60  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001ae2  00000000  00000000  0000dc48  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000057d4  00000000  00000000  0000f72a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000005a8  00000000  00000000  00014efe  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
       4:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       8:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      2c:	0c 94 7d 02 	jmp	0x4fa	; 0x4fa <__vector_11>
      30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      34:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      40:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      48:	0c 94 ad 11 	jmp	0x235a	; 0x235a <__vector_18>
      4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      50:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      68:	6c 0c       	add	r6, r12
      6a:	6c 0c       	add	r6, r12
      6c:	6c 0c       	add	r6, r12
      6e:	a7 0c       	add	r10, r7
      70:	95 0c       	add	r9, r5
      72:	a4 0c       	add	r10, r4
      74:	6c 0c       	add	r6, r12
      76:	6c 0c       	add	r6, r12
      78:	a7 0c       	add	r10, r7
      7a:	95 0c       	add	r9, r5

0000007c <__ctors_end>:
      7c:	11 24       	eor	r1, r1
      7e:	1f be       	out	0x3f, r1	; 63
      80:	cf ef       	ldi	r28, 0xFF	; 255
      82:	d8 e0       	ldi	r29, 0x08	; 8
      84:	de bf       	out	0x3e, r29	; 62
      86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
      88:	12 e0       	ldi	r17, 0x02	; 2
      8a:	a0 e0       	ldi	r26, 0x00	; 0
      8c:	b1 e0       	ldi	r27, 0x01	; 1
      8e:	e0 ec       	ldi	r30, 0xC0	; 192
      90:	fa e2       	ldi	r31, 0x2A	; 42
      92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
      94:	05 90       	lpm	r0, Z+
      96:	0d 92       	st	X+, r0
      98:	a6 38       	cpi	r26, 0x86	; 134
      9a:	b1 07       	cpc	r27, r17
      9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
      9e:	28 e0       	ldi	r18, 0x08	; 8
      a0:	a6 e8       	ldi	r26, 0x86	; 134
      a2:	b2 e0       	ldi	r27, 0x02	; 2
      a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
      a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
      a8:	ab 3a       	cpi	r26, 0xAB	; 171
      aa:	b2 07       	cpc	r27, r18
      ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
      ae:	0e 94 b3 10 	call	0x2166	; 0x2166 <main>
      b2:	0c 94 5e 15 	jmp	0x2abc	; 0x2abc <_exit>

000000b6 <__bad_interrupt>:
      b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
      ba:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      bc:	03 96       	adiw	r24, 0x03	; 3
      be:	92 83       	std	Z+2, r25	; 0x02
      c0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
      c2:	2f ef       	ldi	r18, 0xFF	; 255
      c4:	3f ef       	ldi	r19, 0xFF	; 255
      c6:	34 83       	std	Z+4, r19	; 0x04
      c8:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      ca:	96 83       	std	Z+6, r25	; 0x06
      cc:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      ce:	90 87       	std	Z+8, r25	; 0x08
      d0:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
      d2:	10 82       	st	Z, r1
      d4:	08 95       	ret

000000d6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
      d6:	fc 01       	movw	r30, r24
      d8:	11 86       	std	Z+9, r1	; 0x09
      da:	10 86       	std	Z+8, r1	; 0x08
      dc:	08 95       	ret

000000de <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
      de:	cf 93       	push	r28
      e0:	df 93       	push	r29
      e2:	9c 01       	movw	r18, r24
      e4:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
      e6:	dc 01       	movw	r26, r24
      e8:	11 96       	adiw	r26, 0x01	; 1
      ea:	cd 91       	ld	r28, X+
      ec:	dc 91       	ld	r29, X
      ee:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
      f0:	d3 83       	std	Z+3, r29	; 0x03
      f2:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
      f4:	8c 81       	ldd	r24, Y+4	; 0x04
      f6:	9d 81       	ldd	r25, Y+5	; 0x05
      f8:	95 83       	std	Z+5, r25	; 0x05
      fa:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
      fc:	8c 81       	ldd	r24, Y+4	; 0x04
      fe:	9d 81       	ldd	r25, Y+5	; 0x05
     100:	dc 01       	movw	r26, r24
     102:	13 96       	adiw	r26, 0x03	; 3
     104:	7c 93       	st	X, r23
     106:	6e 93       	st	-X, r22
     108:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     10a:	7d 83       	std	Y+5, r23	; 0x05
     10c:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     10e:	31 87       	std	Z+9, r19	; 0x09
     110:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     112:	f9 01       	movw	r30, r18
     114:	80 81       	ld	r24, Z
     116:	8f 5f       	subi	r24, 0xFF	; 255
     118:	80 83       	st	Z, r24
}
     11a:	df 91       	pop	r29
     11c:	cf 91       	pop	r28
     11e:	08 95       	ret

00000120 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     120:	cf 93       	push	r28
     122:	df 93       	push	r29
     124:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     126:	48 81       	ld	r20, Y
     128:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     12a:	4f 3f       	cpi	r20, 0xFF	; 255
     12c:	2f ef       	ldi	r18, 0xFF	; 255
     12e:	52 07       	cpc	r21, r18
     130:	21 f4       	brne	.+8      	; 0x13a <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     132:	fc 01       	movw	r30, r24
     134:	a7 81       	ldd	r26, Z+7	; 0x07
     136:	b0 85       	ldd	r27, Z+8	; 0x08
     138:	0d c0       	rjmp	.+26     	; 0x154 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     13a:	dc 01       	movw	r26, r24
     13c:	13 96       	adiw	r26, 0x03	; 3
     13e:	01 c0       	rjmp	.+2      	; 0x142 <vListInsert+0x22>
     140:	df 01       	movw	r26, r30
     142:	12 96       	adiw	r26, 0x02	; 2
     144:	ed 91       	ld	r30, X+
     146:	fc 91       	ld	r31, X
     148:	13 97       	sbiw	r26, 0x03	; 3
     14a:	20 81       	ld	r18, Z
     14c:	31 81       	ldd	r19, Z+1	; 0x01
     14e:	42 17       	cp	r20, r18
     150:	53 07       	cpc	r21, r19
     152:	b0 f7       	brcc	.-20     	; 0x140 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     154:	12 96       	adiw	r26, 0x02	; 2
     156:	ed 91       	ld	r30, X+
     158:	fc 91       	ld	r31, X
     15a:	13 97       	sbiw	r26, 0x03	; 3
     15c:	fb 83       	std	Y+3, r31	; 0x03
     15e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     160:	d5 83       	std	Z+5, r29	; 0x05
     162:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     164:	bd 83       	std	Y+5, r27	; 0x05
     166:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     168:	13 96       	adiw	r26, 0x03	; 3
     16a:	dc 93       	st	X, r29
     16c:	ce 93       	st	-X, r28
     16e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     170:	99 87       	std	Y+9, r25	; 0x09
     172:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     174:	fc 01       	movw	r30, r24
     176:	20 81       	ld	r18, Z
     178:	2f 5f       	subi	r18, 0xFF	; 255
     17a:	20 83       	st	Z, r18
}
     17c:	df 91       	pop	r29
     17e:	cf 91       	pop	r28
     180:	08 95       	ret

00000182 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     182:	cf 93       	push	r28
     184:	df 93       	push	r29
     186:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     188:	a0 85       	ldd	r26, Z+8	; 0x08
     18a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     18c:	c2 81       	ldd	r28, Z+2	; 0x02
     18e:	d3 81       	ldd	r29, Z+3	; 0x03
     190:	84 81       	ldd	r24, Z+4	; 0x04
     192:	95 81       	ldd	r25, Z+5	; 0x05
     194:	9d 83       	std	Y+5, r25	; 0x05
     196:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     198:	c4 81       	ldd	r28, Z+4	; 0x04
     19a:	d5 81       	ldd	r29, Z+5	; 0x05
     19c:	82 81       	ldd	r24, Z+2	; 0x02
     19e:	93 81       	ldd	r25, Z+3	; 0x03
     1a0:	9b 83       	std	Y+3, r25	; 0x03
     1a2:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     1a4:	11 96       	adiw	r26, 0x01	; 1
     1a6:	8d 91       	ld	r24, X+
     1a8:	9c 91       	ld	r25, X
     1aa:	12 97       	sbiw	r26, 0x02	; 2
     1ac:	e8 17       	cp	r30, r24
     1ae:	f9 07       	cpc	r31, r25
     1b0:	31 f4       	brne	.+12     	; 0x1be <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     1b2:	84 81       	ldd	r24, Z+4	; 0x04
     1b4:	95 81       	ldd	r25, Z+5	; 0x05
     1b6:	12 96       	adiw	r26, 0x02	; 2
     1b8:	9c 93       	st	X, r25
     1ba:	8e 93       	st	-X, r24
     1bc:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     1be:	11 86       	std	Z+9, r1	; 0x09
     1c0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     1c2:	8c 91       	ld	r24, X
     1c4:	81 50       	subi	r24, 0x01	; 1
     1c6:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     1c8:	df 91       	pop	r29
     1ca:	cf 91       	pop	r28
     1cc:	08 95       	ret

000001ce <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     1ce:	cf 93       	push	r28
     1d0:	df 93       	push	r29
     1d2:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     1d4:	0e 94 55 07 	call	0xeaa	; 0xeaa <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     1d8:	80 91 86 02 	lds	r24, 0x0286	; 0x800286 <__data_end>
     1dc:	90 91 87 02 	lds	r25, 0x0287	; 0x800287 <__data_end+0x1>
     1e0:	89 2b       	or	r24, r25
     1e2:	31 f4       	brne	.+12     	; 0x1f0 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     1e4:	8b e8       	ldi	r24, 0x8B	; 139
     1e6:	92 e0       	ldi	r25, 0x02	; 2
     1e8:	90 93 87 02 	sts	0x0287, r25	; 0x800287 <__data_end+0x1>
     1ec:	80 93 86 02 	sts	0x0286, r24	; 0x800286 <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     1f0:	20 91 88 02 	lds	r18, 0x0288	; 0x800288 <xNextFreeByte>
     1f4:	30 91 89 02 	lds	r19, 0x0289	; 0x800289 <xNextFreeByte+0x1>
     1f8:	c9 01       	movw	r24, r18
     1fa:	8c 0f       	add	r24, r28
     1fc:	9d 1f       	adc	r25, r29
     1fe:	87 37       	cpi	r24, 0x77	; 119
     200:	45 e0       	ldi	r20, 0x05	; 5
     202:	94 07       	cpc	r25, r20
     204:	70 f4       	brcc	.+28     	; 0x222 <pvPortMalloc+0x54>
     206:	28 17       	cp	r18, r24
     208:	39 07       	cpc	r19, r25
     20a:	70 f4       	brcc	.+28     	; 0x228 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     20c:	c0 91 86 02 	lds	r28, 0x0286	; 0x800286 <__data_end>
     210:	d0 91 87 02 	lds	r29, 0x0287	; 0x800287 <__data_end+0x1>
     214:	c2 0f       	add	r28, r18
     216:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     218:	90 93 89 02 	sts	0x0289, r25	; 0x800289 <xNextFreeByte+0x1>
     21c:	80 93 88 02 	sts	0x0288, r24	; 0x800288 <xNextFreeByte>
     220:	05 c0       	rjmp	.+10     	; 0x22c <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     222:	c0 e0       	ldi	r28, 0x00	; 0
     224:	d0 e0       	ldi	r29, 0x00	; 0
     226:	02 c0       	rjmp	.+4      	; 0x22c <pvPortMalloc+0x5e>
     228:	c0 e0       	ldi	r28, 0x00	; 0
     22a:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     22c:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     230:	ce 01       	movw	r24, r28
     232:	df 91       	pop	r29
     234:	cf 91       	pop	r28
     236:	08 95       	ret

00000238 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     238:	08 95       	ret

0000023a <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     23a:	31 e1       	ldi	r19, 0x11	; 17
     23c:	fc 01       	movw	r30, r24
     23e:	30 83       	st	Z, r19
     240:	31 97       	sbiw	r30, 0x01	; 1
     242:	22 e2       	ldi	r18, 0x22	; 34
     244:	20 83       	st	Z, r18
     246:	31 97       	sbiw	r30, 0x01	; 1
     248:	a3 e3       	ldi	r26, 0x33	; 51
     24a:	a0 83       	st	Z, r26
     24c:	31 97       	sbiw	r30, 0x01	; 1
     24e:	60 83       	st	Z, r22
     250:	31 97       	sbiw	r30, 0x01	; 1
     252:	70 83       	st	Z, r23
     254:	31 97       	sbiw	r30, 0x01	; 1
     256:	10 82       	st	Z, r1
     258:	31 97       	sbiw	r30, 0x01	; 1
     25a:	60 e8       	ldi	r22, 0x80	; 128
     25c:	60 83       	st	Z, r22
     25e:	31 97       	sbiw	r30, 0x01	; 1
     260:	10 82       	st	Z, r1
     262:	31 97       	sbiw	r30, 0x01	; 1
     264:	62 e0       	ldi	r22, 0x02	; 2
     266:	60 83       	st	Z, r22
     268:	31 97       	sbiw	r30, 0x01	; 1
     26a:	63 e0       	ldi	r22, 0x03	; 3
     26c:	60 83       	st	Z, r22
     26e:	31 97       	sbiw	r30, 0x01	; 1
     270:	64 e0       	ldi	r22, 0x04	; 4
     272:	60 83       	st	Z, r22
     274:	31 97       	sbiw	r30, 0x01	; 1
     276:	65 e0       	ldi	r22, 0x05	; 5
     278:	60 83       	st	Z, r22
     27a:	31 97       	sbiw	r30, 0x01	; 1
     27c:	66 e0       	ldi	r22, 0x06	; 6
     27e:	60 83       	st	Z, r22
     280:	31 97       	sbiw	r30, 0x01	; 1
     282:	67 e0       	ldi	r22, 0x07	; 7
     284:	60 83       	st	Z, r22
     286:	31 97       	sbiw	r30, 0x01	; 1
     288:	68 e0       	ldi	r22, 0x08	; 8
     28a:	60 83       	st	Z, r22
     28c:	31 97       	sbiw	r30, 0x01	; 1
     28e:	69 e0       	ldi	r22, 0x09	; 9
     290:	60 83       	st	Z, r22
     292:	31 97       	sbiw	r30, 0x01	; 1
     294:	60 e1       	ldi	r22, 0x10	; 16
     296:	60 83       	st	Z, r22
     298:	31 97       	sbiw	r30, 0x01	; 1
     29a:	30 83       	st	Z, r19
     29c:	31 97       	sbiw	r30, 0x01	; 1
     29e:	32 e1       	ldi	r19, 0x12	; 18
     2a0:	30 83       	st	Z, r19
     2a2:	31 97       	sbiw	r30, 0x01	; 1
     2a4:	33 e1       	ldi	r19, 0x13	; 19
     2a6:	30 83       	st	Z, r19
     2a8:	31 97       	sbiw	r30, 0x01	; 1
     2aa:	34 e1       	ldi	r19, 0x14	; 20
     2ac:	30 83       	st	Z, r19
     2ae:	31 97       	sbiw	r30, 0x01	; 1
     2b0:	35 e1       	ldi	r19, 0x15	; 21
     2b2:	30 83       	st	Z, r19
     2b4:	31 97       	sbiw	r30, 0x01	; 1
     2b6:	36 e1       	ldi	r19, 0x16	; 22
     2b8:	30 83       	st	Z, r19
     2ba:	31 97       	sbiw	r30, 0x01	; 1
     2bc:	37 e1       	ldi	r19, 0x17	; 23
     2be:	30 83       	st	Z, r19
     2c0:	31 97       	sbiw	r30, 0x01	; 1
     2c2:	38 e1       	ldi	r19, 0x18	; 24
     2c4:	30 83       	st	Z, r19
     2c6:	31 97       	sbiw	r30, 0x01	; 1
     2c8:	39 e1       	ldi	r19, 0x19	; 25
     2ca:	30 83       	st	Z, r19
     2cc:	31 97       	sbiw	r30, 0x01	; 1
     2ce:	30 e2       	ldi	r19, 0x20	; 32
     2d0:	30 83       	st	Z, r19
     2d2:	31 97       	sbiw	r30, 0x01	; 1
     2d4:	31 e2       	ldi	r19, 0x21	; 33
     2d6:	30 83       	st	Z, r19
     2d8:	31 97       	sbiw	r30, 0x01	; 1
     2da:	20 83       	st	Z, r18
     2dc:	31 97       	sbiw	r30, 0x01	; 1
     2de:	23 e2       	ldi	r18, 0x23	; 35
     2e0:	20 83       	st	Z, r18
     2e2:	31 97       	sbiw	r30, 0x01	; 1
     2e4:	40 83       	st	Z, r20
     2e6:	31 97       	sbiw	r30, 0x01	; 1
     2e8:	50 83       	st	Z, r21
     2ea:	31 97       	sbiw	r30, 0x01	; 1
     2ec:	26 e2       	ldi	r18, 0x26	; 38
     2ee:	20 83       	st	Z, r18
     2f0:	31 97       	sbiw	r30, 0x01	; 1
     2f2:	27 e2       	ldi	r18, 0x27	; 39
     2f4:	20 83       	st	Z, r18
     2f6:	31 97       	sbiw	r30, 0x01	; 1
     2f8:	28 e2       	ldi	r18, 0x28	; 40
     2fa:	20 83       	st	Z, r18
     2fc:	31 97       	sbiw	r30, 0x01	; 1
     2fe:	29 e2       	ldi	r18, 0x29	; 41
     300:	20 83       	st	Z, r18
     302:	31 97       	sbiw	r30, 0x01	; 1
     304:	20 e3       	ldi	r18, 0x30	; 48
     306:	20 83       	st	Z, r18
     308:	31 97       	sbiw	r30, 0x01	; 1
     30a:	21 e3       	ldi	r18, 0x31	; 49
     30c:	20 83       	st	Z, r18
     30e:	86 97       	sbiw	r24, 0x26	; 38
     310:	08 95       	ret

00000312 <xPortStartScheduler>:
     312:	89 ef       	ldi	r24, 0xF9	; 249
     314:	90 e0       	ldi	r25, 0x00	; 0
     316:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
     31a:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
     31e:	e0 e8       	ldi	r30, 0x80	; 128
     320:	f0 e0       	ldi	r31, 0x00	; 0
     322:	80 81       	ld	r24, Z
     324:	8c 7f       	andi	r24, 0xFC	; 252
     326:	80 83       	st	Z, r24
     328:	8b e0       	ldi	r24, 0x0B	; 11
     32a:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
     32e:	ef e6       	ldi	r30, 0x6F	; 111
     330:	f0 e0       	ldi	r31, 0x00	; 0
     332:	80 81       	ld	r24, Z
     334:	82 60       	ori	r24, 0x02	; 2
     336:	80 83       	st	Z, r24
     338:	a0 91 66 08 	lds	r26, 0x0866	; 0x800866 <pxCurrentTCB>
     33c:	b0 91 67 08 	lds	r27, 0x0867	; 0x800867 <pxCurrentTCB+0x1>
     340:	cd 91       	ld	r28, X+
     342:	cd bf       	out	0x3d, r28	; 61
     344:	dd 91       	ld	r29, X+
     346:	de bf       	out	0x3e, r29	; 62
     348:	ff 91       	pop	r31
     34a:	ef 91       	pop	r30
     34c:	df 91       	pop	r29
     34e:	cf 91       	pop	r28
     350:	bf 91       	pop	r27
     352:	af 91       	pop	r26
     354:	9f 91       	pop	r25
     356:	8f 91       	pop	r24
     358:	7f 91       	pop	r23
     35a:	6f 91       	pop	r22
     35c:	5f 91       	pop	r21
     35e:	4f 91       	pop	r20
     360:	3f 91       	pop	r19
     362:	2f 91       	pop	r18
     364:	1f 91       	pop	r17
     366:	0f 91       	pop	r16
     368:	ff 90       	pop	r15
     36a:	ef 90       	pop	r14
     36c:	df 90       	pop	r13
     36e:	cf 90       	pop	r12
     370:	bf 90       	pop	r11
     372:	af 90       	pop	r10
     374:	9f 90       	pop	r9
     376:	8f 90       	pop	r8
     378:	7f 90       	pop	r7
     37a:	6f 90       	pop	r6
     37c:	5f 90       	pop	r5
     37e:	4f 90       	pop	r4
     380:	3f 90       	pop	r3
     382:	2f 90       	pop	r2
     384:	1f 90       	pop	r1
     386:	0f 90       	pop	r0
     388:	0f be       	out	0x3f, r0	; 63
     38a:	0f 90       	pop	r0
     38c:	08 95       	ret
     38e:	81 e0       	ldi	r24, 0x01	; 1
     390:	08 95       	ret

00000392 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     392:	0f 92       	push	r0
     394:	0f b6       	in	r0, 0x3f	; 63
     396:	f8 94       	cli
     398:	0f 92       	push	r0
     39a:	1f 92       	push	r1
     39c:	11 24       	eor	r1, r1
     39e:	2f 92       	push	r2
     3a0:	3f 92       	push	r3
     3a2:	4f 92       	push	r4
     3a4:	5f 92       	push	r5
     3a6:	6f 92       	push	r6
     3a8:	7f 92       	push	r7
     3aa:	8f 92       	push	r8
     3ac:	9f 92       	push	r9
     3ae:	af 92       	push	r10
     3b0:	bf 92       	push	r11
     3b2:	cf 92       	push	r12
     3b4:	df 92       	push	r13
     3b6:	ef 92       	push	r14
     3b8:	ff 92       	push	r15
     3ba:	0f 93       	push	r16
     3bc:	1f 93       	push	r17
     3be:	2f 93       	push	r18
     3c0:	3f 93       	push	r19
     3c2:	4f 93       	push	r20
     3c4:	5f 93       	push	r21
     3c6:	6f 93       	push	r22
     3c8:	7f 93       	push	r23
     3ca:	8f 93       	push	r24
     3cc:	9f 93       	push	r25
     3ce:	af 93       	push	r26
     3d0:	bf 93       	push	r27
     3d2:	cf 93       	push	r28
     3d4:	df 93       	push	r29
     3d6:	ef 93       	push	r30
     3d8:	ff 93       	push	r31
     3da:	a0 91 66 08 	lds	r26, 0x0866	; 0x800866 <pxCurrentTCB>
     3de:	b0 91 67 08 	lds	r27, 0x0867	; 0x800867 <pxCurrentTCB+0x1>
     3e2:	0d b6       	in	r0, 0x3d	; 61
     3e4:	0d 92       	st	X+, r0
     3e6:	0e b6       	in	r0, 0x3e	; 62
     3e8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     3ea:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     3ee:	a0 91 66 08 	lds	r26, 0x0866	; 0x800866 <pxCurrentTCB>
     3f2:	b0 91 67 08 	lds	r27, 0x0867	; 0x800867 <pxCurrentTCB+0x1>
     3f6:	cd 91       	ld	r28, X+
     3f8:	cd bf       	out	0x3d, r28	; 61
     3fa:	dd 91       	ld	r29, X+
     3fc:	de bf       	out	0x3e, r29	; 62
     3fe:	ff 91       	pop	r31
     400:	ef 91       	pop	r30
     402:	df 91       	pop	r29
     404:	cf 91       	pop	r28
     406:	bf 91       	pop	r27
     408:	af 91       	pop	r26
     40a:	9f 91       	pop	r25
     40c:	8f 91       	pop	r24
     40e:	7f 91       	pop	r23
     410:	6f 91       	pop	r22
     412:	5f 91       	pop	r21
     414:	4f 91       	pop	r20
     416:	3f 91       	pop	r19
     418:	2f 91       	pop	r18
     41a:	1f 91       	pop	r17
     41c:	0f 91       	pop	r16
     41e:	ff 90       	pop	r15
     420:	ef 90       	pop	r14
     422:	df 90       	pop	r13
     424:	cf 90       	pop	r12
     426:	bf 90       	pop	r11
     428:	af 90       	pop	r10
     42a:	9f 90       	pop	r9
     42c:	8f 90       	pop	r8
     42e:	7f 90       	pop	r7
     430:	6f 90       	pop	r6
     432:	5f 90       	pop	r5
     434:	4f 90       	pop	r4
     436:	3f 90       	pop	r3
     438:	2f 90       	pop	r2
     43a:	1f 90       	pop	r1
     43c:	0f 90       	pop	r0
     43e:	0f be       	out	0x3f, r0	; 63
     440:	0f 90       	pop	r0

	asm volatile ( "ret" );
     442:	08 95       	ret

00000444 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     444:	0f 92       	push	r0
     446:	0f b6       	in	r0, 0x3f	; 63
     448:	f8 94       	cli
     44a:	0f 92       	push	r0
     44c:	1f 92       	push	r1
     44e:	11 24       	eor	r1, r1
     450:	2f 92       	push	r2
     452:	3f 92       	push	r3
     454:	4f 92       	push	r4
     456:	5f 92       	push	r5
     458:	6f 92       	push	r6
     45a:	7f 92       	push	r7
     45c:	8f 92       	push	r8
     45e:	9f 92       	push	r9
     460:	af 92       	push	r10
     462:	bf 92       	push	r11
     464:	cf 92       	push	r12
     466:	df 92       	push	r13
     468:	ef 92       	push	r14
     46a:	ff 92       	push	r15
     46c:	0f 93       	push	r16
     46e:	1f 93       	push	r17
     470:	2f 93       	push	r18
     472:	3f 93       	push	r19
     474:	4f 93       	push	r20
     476:	5f 93       	push	r21
     478:	6f 93       	push	r22
     47a:	7f 93       	push	r23
     47c:	8f 93       	push	r24
     47e:	9f 93       	push	r25
     480:	af 93       	push	r26
     482:	bf 93       	push	r27
     484:	cf 93       	push	r28
     486:	df 93       	push	r29
     488:	ef 93       	push	r30
     48a:	ff 93       	push	r31
     48c:	a0 91 66 08 	lds	r26, 0x0866	; 0x800866 <pxCurrentTCB>
     490:	b0 91 67 08 	lds	r27, 0x0867	; 0x800867 <pxCurrentTCB+0x1>
     494:	0d b6       	in	r0, 0x3d	; 61
     496:	0d 92       	st	X+, r0
     498:	0e b6       	in	r0, 0x3e	; 62
     49a:	0d 92       	st	X+, r0
	xTaskIncrementTick();
     49c:	0e 94 65 07 	call	0xeca	; 0xeca <xTaskIncrementTick>
	vTaskSwitchContext();
     4a0:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     4a4:	a0 91 66 08 	lds	r26, 0x0866	; 0x800866 <pxCurrentTCB>
     4a8:	b0 91 67 08 	lds	r27, 0x0867	; 0x800867 <pxCurrentTCB+0x1>
     4ac:	cd 91       	ld	r28, X+
     4ae:	cd bf       	out	0x3d, r28	; 61
     4b0:	dd 91       	ld	r29, X+
     4b2:	de bf       	out	0x3e, r29	; 62
     4b4:	ff 91       	pop	r31
     4b6:	ef 91       	pop	r30
     4b8:	df 91       	pop	r29
     4ba:	cf 91       	pop	r28
     4bc:	bf 91       	pop	r27
     4be:	af 91       	pop	r26
     4c0:	9f 91       	pop	r25
     4c2:	8f 91       	pop	r24
     4c4:	7f 91       	pop	r23
     4c6:	6f 91       	pop	r22
     4c8:	5f 91       	pop	r21
     4ca:	4f 91       	pop	r20
     4cc:	3f 91       	pop	r19
     4ce:	2f 91       	pop	r18
     4d0:	1f 91       	pop	r17
     4d2:	0f 91       	pop	r16
     4d4:	ff 90       	pop	r15
     4d6:	ef 90       	pop	r14
     4d8:	df 90       	pop	r13
     4da:	cf 90       	pop	r12
     4dc:	bf 90       	pop	r11
     4de:	af 90       	pop	r10
     4e0:	9f 90       	pop	r9
     4e2:	8f 90       	pop	r8
     4e4:	7f 90       	pop	r7
     4e6:	6f 90       	pop	r6
     4e8:	5f 90       	pop	r5
     4ea:	4f 90       	pop	r4
     4ec:	3f 90       	pop	r3
     4ee:	2f 90       	pop	r2
     4f0:	1f 90       	pop	r1
     4f2:	0f 90       	pop	r0
     4f4:	0f be       	out	0x3f, r0	; 63
     4f6:	0f 90       	pop	r0

	asm volatile ( "ret" );
     4f8:	08 95       	ret

000004fa <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     4fa:	0e 94 22 02 	call	0x444	; 0x444 <vPortYieldFromTick>
		asm volatile ( "reti" );
     4fe:	18 95       	reti

00000500 <prvCopyDataToQueue>:
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
     500:	0f 93       	push	r16
     502:	1f 93       	push	r17
     504:	cf 93       	push	r28
     506:	df 93       	push	r29
     508:	ec 01       	movw	r28, r24
     50a:	04 2f       	mov	r16, r20
     50c:	1a 8d       	ldd	r17, Y+26	; 0x1a
     50e:	4c 8d       	ldd	r20, Y+28	; 0x1c
     510:	44 23       	and	r20, r20
     512:	b9 f1       	breq	.+110    	; 0x582 <prvCopyDataToQueue+0x82>
     514:	01 11       	cpse	r16, r1
     516:	16 c0       	rjmp	.+44     	; 0x544 <prvCopyDataToQueue+0x44>
     518:	50 e0       	ldi	r21, 0x00	; 0
     51a:	8c 81       	ldd	r24, Y+4	; 0x04
     51c:	9d 81       	ldd	r25, Y+5	; 0x05
     51e:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <memcpy>
     522:	2c 8d       	ldd	r18, Y+28	; 0x1c
     524:	8c 81       	ldd	r24, Y+4	; 0x04
     526:	9d 81       	ldd	r25, Y+5	; 0x05
     528:	82 0f       	add	r24, r18
     52a:	91 1d       	adc	r25, r1
     52c:	9d 83       	std	Y+5, r25	; 0x05
     52e:	8c 83       	std	Y+4, r24	; 0x04
     530:	2a 81       	ldd	r18, Y+2	; 0x02
     532:	3b 81       	ldd	r19, Y+3	; 0x03
     534:	82 17       	cp	r24, r18
     536:	93 07       	cpc	r25, r19
     538:	20 f1       	brcs	.+72     	; 0x582 <prvCopyDataToQueue+0x82>
     53a:	88 81       	ld	r24, Y
     53c:	99 81       	ldd	r25, Y+1	; 0x01
     53e:	9d 83       	std	Y+5, r25	; 0x05
     540:	8c 83       	std	Y+4, r24	; 0x04
     542:	1f c0       	rjmp	.+62     	; 0x582 <prvCopyDataToQueue+0x82>
     544:	50 e0       	ldi	r21, 0x00	; 0
     546:	8e 81       	ldd	r24, Y+6	; 0x06
     548:	9f 81       	ldd	r25, Y+7	; 0x07
     54a:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <memcpy>
     54e:	8c 8d       	ldd	r24, Y+28	; 0x1c
     550:	90 e0       	ldi	r25, 0x00	; 0
     552:	91 95       	neg	r25
     554:	81 95       	neg	r24
     556:	91 09       	sbc	r25, r1
     558:	2e 81       	ldd	r18, Y+6	; 0x06
     55a:	3f 81       	ldd	r19, Y+7	; 0x07
     55c:	28 0f       	add	r18, r24
     55e:	39 1f       	adc	r19, r25
     560:	3f 83       	std	Y+7, r19	; 0x07
     562:	2e 83       	std	Y+6, r18	; 0x06
     564:	48 81       	ld	r20, Y
     566:	59 81       	ldd	r21, Y+1	; 0x01
     568:	24 17       	cp	r18, r20
     56a:	35 07       	cpc	r19, r21
     56c:	30 f4       	brcc	.+12     	; 0x57a <prvCopyDataToQueue+0x7a>
     56e:	2a 81       	ldd	r18, Y+2	; 0x02
     570:	3b 81       	ldd	r19, Y+3	; 0x03
     572:	82 0f       	add	r24, r18
     574:	93 1f       	adc	r25, r19
     576:	9f 83       	std	Y+7, r25	; 0x07
     578:	8e 83       	std	Y+6, r24	; 0x06
     57a:	02 30       	cpi	r16, 0x02	; 2
     57c:	11 f4       	brne	.+4      	; 0x582 <prvCopyDataToQueue+0x82>
     57e:	11 11       	cpse	r17, r1
     580:	11 50       	subi	r17, 0x01	; 1
     582:	1f 5f       	subi	r17, 0xFF	; 255
     584:	1a 8f       	std	Y+26, r17	; 0x1a
     586:	80 e0       	ldi	r24, 0x00	; 0
     588:	df 91       	pop	r29
     58a:	cf 91       	pop	r28
     58c:	1f 91       	pop	r17
     58e:	0f 91       	pop	r16
     590:	08 95       	ret

00000592 <prvCopyDataFromQueue>:
     592:	fc 01       	movw	r30, r24
     594:	44 8d       	ldd	r20, Z+28	; 0x1c
     596:	44 23       	and	r20, r20
     598:	a9 f0       	breq	.+42     	; 0x5c4 <prvCopyDataFromQueue+0x32>
     59a:	50 e0       	ldi	r21, 0x00	; 0
     59c:	26 81       	ldd	r18, Z+6	; 0x06
     59e:	37 81       	ldd	r19, Z+7	; 0x07
     5a0:	24 0f       	add	r18, r20
     5a2:	35 1f       	adc	r19, r21
     5a4:	37 83       	std	Z+7, r19	; 0x07
     5a6:	26 83       	std	Z+6, r18	; 0x06
     5a8:	82 81       	ldd	r24, Z+2	; 0x02
     5aa:	93 81       	ldd	r25, Z+3	; 0x03
     5ac:	28 17       	cp	r18, r24
     5ae:	39 07       	cpc	r19, r25
     5b0:	20 f0       	brcs	.+8      	; 0x5ba <prvCopyDataFromQueue+0x28>
     5b2:	80 81       	ld	r24, Z
     5b4:	91 81       	ldd	r25, Z+1	; 0x01
     5b6:	97 83       	std	Z+7, r25	; 0x07
     5b8:	86 83       	std	Z+6, r24	; 0x06
     5ba:	cb 01       	movw	r24, r22
     5bc:	66 81       	ldd	r22, Z+6	; 0x06
     5be:	77 81       	ldd	r23, Z+7	; 0x07
     5c0:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <memcpy>
     5c4:	08 95       	ret

000005c6 <prvUnlockQueue>:
     5c6:	ef 92       	push	r14
     5c8:	ff 92       	push	r15
     5ca:	0f 93       	push	r16
     5cc:	1f 93       	push	r17
     5ce:	cf 93       	push	r28
     5d0:	8c 01       	movw	r16, r24
     5d2:	0f b6       	in	r0, 0x3f	; 63
     5d4:	f8 94       	cli
     5d6:	0f 92       	push	r0
     5d8:	fc 01       	movw	r30, r24
     5da:	c6 8d       	ldd	r28, Z+30	; 0x1e
     5dc:	1c 16       	cp	r1, r28
     5de:	ac f4       	brge	.+42     	; 0x60a <prvUnlockQueue+0x44>
     5e0:	81 89       	ldd	r24, Z+17	; 0x11
     5e2:	81 11       	cpse	r24, r1
     5e4:	06 c0       	rjmp	.+12     	; 0x5f2 <prvUnlockQueue+0x2c>
     5e6:	11 c0       	rjmp	.+34     	; 0x60a <prvUnlockQueue+0x44>
     5e8:	f8 01       	movw	r30, r16
     5ea:	81 89       	ldd	r24, Z+17	; 0x11
     5ec:	81 11       	cpse	r24, r1
     5ee:	05 c0       	rjmp	.+10     	; 0x5fa <prvUnlockQueue+0x34>
     5f0:	0c c0       	rjmp	.+24     	; 0x60a <prvUnlockQueue+0x44>
     5f2:	78 01       	movw	r14, r16
     5f4:	f1 e1       	ldi	r31, 0x11	; 17
     5f6:	ef 0e       	add	r14, r31
     5f8:	f1 1c       	adc	r15, r1
     5fa:	c7 01       	movw	r24, r14
     5fc:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <xTaskRemoveFromEventList>
     600:	81 11       	cpse	r24, r1
     602:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <vTaskMissedYield>
     606:	c1 50       	subi	r28, 0x01	; 1
     608:	79 f7       	brne	.-34     	; 0x5e8 <prvUnlockQueue+0x22>
     60a:	8f ef       	ldi	r24, 0xFF	; 255
     60c:	f8 01       	movw	r30, r16
     60e:	86 8f       	std	Z+30, r24	; 0x1e
     610:	0f 90       	pop	r0
     612:	0f be       	out	0x3f, r0	; 63
     614:	0f b6       	in	r0, 0x3f	; 63
     616:	f8 94       	cli
     618:	0f 92       	push	r0
     61a:	c5 8d       	ldd	r28, Z+29	; 0x1d
     61c:	1c 16       	cp	r1, r28
     61e:	ac f4       	brge	.+42     	; 0x64a <prvUnlockQueue+0x84>
     620:	80 85       	ldd	r24, Z+8	; 0x08
     622:	81 11       	cpse	r24, r1
     624:	06 c0       	rjmp	.+12     	; 0x632 <prvUnlockQueue+0x6c>
     626:	11 c0       	rjmp	.+34     	; 0x64a <prvUnlockQueue+0x84>
     628:	f8 01       	movw	r30, r16
     62a:	80 85       	ldd	r24, Z+8	; 0x08
     62c:	81 11       	cpse	r24, r1
     62e:	05 c0       	rjmp	.+10     	; 0x63a <prvUnlockQueue+0x74>
     630:	0c c0       	rjmp	.+24     	; 0x64a <prvUnlockQueue+0x84>
     632:	78 01       	movw	r14, r16
     634:	f8 e0       	ldi	r31, 0x08	; 8
     636:	ef 0e       	add	r14, r31
     638:	f1 1c       	adc	r15, r1
     63a:	c7 01       	movw	r24, r14
     63c:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <xTaskRemoveFromEventList>
     640:	81 11       	cpse	r24, r1
     642:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <vTaskMissedYield>
     646:	c1 50       	subi	r28, 0x01	; 1
     648:	79 f7       	brne	.-34     	; 0x628 <prvUnlockQueue+0x62>
     64a:	8f ef       	ldi	r24, 0xFF	; 255
     64c:	f8 01       	movw	r30, r16
     64e:	85 8f       	std	Z+29, r24	; 0x1d
     650:	0f 90       	pop	r0
     652:	0f be       	out	0x3f, r0	; 63
     654:	cf 91       	pop	r28
     656:	1f 91       	pop	r17
     658:	0f 91       	pop	r16
     65a:	ff 90       	pop	r15
     65c:	ef 90       	pop	r14
     65e:	08 95       	ret

00000660 <xQueueGenericReset>:
     660:	cf 93       	push	r28
     662:	df 93       	push	r29
     664:	ec 01       	movw	r28, r24
     666:	0f b6       	in	r0, 0x3f	; 63
     668:	f8 94       	cli
     66a:	0f 92       	push	r0
     66c:	48 81       	ld	r20, Y
     66e:	59 81       	ldd	r21, Y+1	; 0x01
     670:	2c 8d       	ldd	r18, Y+28	; 0x1c
     672:	30 e0       	ldi	r19, 0x00	; 0
     674:	7b 8d       	ldd	r23, Y+27	; 0x1b
     676:	72 9f       	mul	r23, r18
     678:	c0 01       	movw	r24, r0
     67a:	73 9f       	mul	r23, r19
     67c:	90 0d       	add	r25, r0
     67e:	11 24       	eor	r1, r1
     680:	fa 01       	movw	r30, r20
     682:	e8 0f       	add	r30, r24
     684:	f9 1f       	adc	r31, r25
     686:	fb 83       	std	Y+3, r31	; 0x03
     688:	ea 83       	std	Y+2, r30	; 0x02
     68a:	1a 8e       	std	Y+26, r1	; 0x1a
     68c:	5d 83       	std	Y+5, r21	; 0x05
     68e:	4c 83       	std	Y+4, r20	; 0x04
     690:	82 1b       	sub	r24, r18
     692:	93 0b       	sbc	r25, r19
     694:	84 0f       	add	r24, r20
     696:	95 1f       	adc	r25, r21
     698:	9f 83       	std	Y+7, r25	; 0x07
     69a:	8e 83       	std	Y+6, r24	; 0x06
     69c:	8f ef       	ldi	r24, 0xFF	; 255
     69e:	8d 8f       	std	Y+29, r24	; 0x1d
     6a0:	8e 8f       	std	Y+30, r24	; 0x1e
     6a2:	61 11       	cpse	r22, r1
     6a4:	0c c0       	rjmp	.+24     	; 0x6be <xQueueGenericReset+0x5e>
     6a6:	88 85       	ldd	r24, Y+8	; 0x08
     6a8:	88 23       	and	r24, r24
     6aa:	89 f0       	breq	.+34     	; 0x6ce <xQueueGenericReset+0x6e>
     6ac:	ce 01       	movw	r24, r28
     6ae:	08 96       	adiw	r24, 0x08	; 8
     6b0:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <xTaskRemoveFromEventList>
     6b4:	88 23       	and	r24, r24
     6b6:	59 f0       	breq	.+22     	; 0x6ce <xQueueGenericReset+0x6e>
     6b8:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     6bc:	08 c0       	rjmp	.+16     	; 0x6ce <xQueueGenericReset+0x6e>
     6be:	ce 01       	movw	r24, r28
     6c0:	08 96       	adiw	r24, 0x08	; 8
     6c2:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     6c6:	ce 01       	movw	r24, r28
     6c8:	41 96       	adiw	r24, 0x11	; 17
     6ca:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     6ce:	0f 90       	pop	r0
     6d0:	0f be       	out	0x3f, r0	; 63
     6d2:	81 e0       	ldi	r24, 0x01	; 1
     6d4:	df 91       	pop	r29
     6d6:	cf 91       	pop	r28
     6d8:	08 95       	ret

000006da <xQueueGenericCreate>:
     6da:	0f 93       	push	r16
     6dc:	1f 93       	push	r17
     6de:	cf 93       	push	r28
     6e0:	df 93       	push	r29
     6e2:	08 2f       	mov	r16, r24
     6e4:	16 2f       	mov	r17, r22
     6e6:	66 23       	and	r22, r22
     6e8:	c1 f0       	breq	.+48     	; 0x71a <xQueueGenericCreate+0x40>
     6ea:	86 9f       	mul	r24, r22
     6ec:	c0 01       	movw	r24, r0
     6ee:	11 24       	eor	r1, r1
     6f0:	4f 96       	adiw	r24, 0x1f	; 31
     6f2:	0e 94 e7 00 	call	0x1ce	; 0x1ce <pvPortMalloc>
     6f6:	ec 01       	movw	r28, r24
     6f8:	00 97       	sbiw	r24, 0x00	; 0
     6fa:	41 f4       	brne	.+16     	; 0x70c <xQueueGenericCreate+0x32>
     6fc:	15 c0       	rjmp	.+42     	; 0x728 <xQueueGenericCreate+0x4e>
     6fe:	0b 8f       	std	Y+27, r16	; 0x1b
     700:	1c 8f       	std	Y+28, r17	; 0x1c
     702:	61 e0       	ldi	r22, 0x01	; 1
     704:	ce 01       	movw	r24, r28
     706:	0e 94 30 03 	call	0x660	; 0x660 <xQueueGenericReset>
     70a:	0e c0       	rjmp	.+28     	; 0x728 <xQueueGenericCreate+0x4e>
     70c:	4f 96       	adiw	r24, 0x1f	; 31
     70e:	99 83       	std	Y+1, r25	; 0x01
     710:	88 83       	st	Y, r24
     712:	f5 cf       	rjmp	.-22     	; 0x6fe <xQueueGenericCreate+0x24>
     714:	d9 83       	std	Y+1, r29	; 0x01
     716:	c8 83       	st	Y, r28
     718:	f2 cf       	rjmp	.-28     	; 0x6fe <xQueueGenericCreate+0x24>
     71a:	8f e1       	ldi	r24, 0x1F	; 31
     71c:	90 e0       	ldi	r25, 0x00	; 0
     71e:	0e 94 e7 00 	call	0x1ce	; 0x1ce <pvPortMalloc>
     722:	ec 01       	movw	r28, r24
     724:	89 2b       	or	r24, r25
     726:	b1 f7       	brne	.-20     	; 0x714 <xQueueGenericCreate+0x3a>
     728:	ce 01       	movw	r24, r28
     72a:	df 91       	pop	r29
     72c:	cf 91       	pop	r28
     72e:	1f 91       	pop	r17
     730:	0f 91       	pop	r16
     732:	08 95       	ret

00000734 <xQueueGenericSend>:
     734:	9f 92       	push	r9
     736:	af 92       	push	r10
     738:	bf 92       	push	r11
     73a:	cf 92       	push	r12
     73c:	df 92       	push	r13
     73e:	ef 92       	push	r14
     740:	ff 92       	push	r15
     742:	0f 93       	push	r16
     744:	1f 93       	push	r17
     746:	cf 93       	push	r28
     748:	df 93       	push	r29
     74a:	00 d0       	rcall	.+0      	; 0x74c <xQueueGenericSend+0x18>
     74c:	00 d0       	rcall	.+0      	; 0x74e <xQueueGenericSend+0x1a>
     74e:	1f 92       	push	r1
     750:	cd b7       	in	r28, 0x3d	; 61
     752:	de b7       	in	r29, 0x3e	; 62
     754:	8c 01       	movw	r16, r24
     756:	6b 01       	movw	r12, r22
     758:	5d 83       	std	Y+5, r21	; 0x05
     75a:	4c 83       	std	Y+4, r20	; 0x04
     75c:	a2 2e       	mov	r10, r18
     75e:	b1 2c       	mov	r11, r1
     760:	99 24       	eor	r9, r9
     762:	93 94       	inc	r9
     764:	7c 01       	movw	r14, r24
     766:	88 e0       	ldi	r24, 0x08	; 8
     768:	e8 0e       	add	r14, r24
     76a:	f1 1c       	adc	r15, r1
     76c:	0f b6       	in	r0, 0x3f	; 63
     76e:	f8 94       	cli
     770:	0f 92       	push	r0
     772:	f8 01       	movw	r30, r16
     774:	92 8d       	ldd	r25, Z+26	; 0x1a
     776:	83 8d       	ldd	r24, Z+27	; 0x1b
     778:	98 17       	cp	r25, r24
     77a:	18 f0       	brcs	.+6      	; 0x782 <xQueueGenericSend+0x4e>
     77c:	f2 e0       	ldi	r31, 0x02	; 2
     77e:	af 12       	cpse	r10, r31
     780:	19 c0       	rjmp	.+50     	; 0x7b4 <xQueueGenericSend+0x80>
     782:	4a 2d       	mov	r20, r10
     784:	b6 01       	movw	r22, r12
     786:	c8 01       	movw	r24, r16
     788:	0e 94 80 02 	call	0x500	; 0x500 <prvCopyDataToQueue>
     78c:	f8 01       	movw	r30, r16
     78e:	91 89       	ldd	r25, Z+17	; 0x11
     790:	99 23       	and	r25, r25
     792:	49 f0       	breq	.+18     	; 0x7a6 <xQueueGenericSend+0x72>
     794:	c8 01       	movw	r24, r16
     796:	41 96       	adiw	r24, 0x11	; 17
     798:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <xTaskRemoveFromEventList>
     79c:	88 23       	and	r24, r24
     79e:	31 f0       	breq	.+12     	; 0x7ac <xQueueGenericSend+0x78>
     7a0:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     7a4:	03 c0       	rjmp	.+6      	; 0x7ac <xQueueGenericSend+0x78>
     7a6:	81 11       	cpse	r24, r1
     7a8:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     7ac:	0f 90       	pop	r0
     7ae:	0f be       	out	0x3f, r0	; 63
     7b0:	81 e0       	ldi	r24, 0x01	; 1
     7b2:	50 c0       	rjmp	.+160    	; 0x854 <xQueueGenericSend+0x120>
     7b4:	8c 81       	ldd	r24, Y+4	; 0x04
     7b6:	9d 81       	ldd	r25, Y+5	; 0x05
     7b8:	89 2b       	or	r24, r25
     7ba:	21 f4       	brne	.+8      	; 0x7c4 <xQueueGenericSend+0x90>
     7bc:	0f 90       	pop	r0
     7be:	0f be       	out	0x3f, r0	; 63
     7c0:	80 e0       	ldi	r24, 0x00	; 0
     7c2:	48 c0       	rjmp	.+144    	; 0x854 <xQueueGenericSend+0x120>
     7c4:	b1 10       	cpse	r11, r1
     7c6:	05 c0       	rjmp	.+10     	; 0x7d2 <xQueueGenericSend+0x9e>
     7c8:	ce 01       	movw	r24, r28
     7ca:	01 96       	adiw	r24, 0x01	; 1
     7cc:	0e 94 19 0a 	call	0x1432	; 0x1432 <vTaskSetTimeOutState>
     7d0:	b9 2c       	mov	r11, r9
     7d2:	0f 90       	pop	r0
     7d4:	0f be       	out	0x3f, r0	; 63
     7d6:	0e 94 55 07 	call	0xeaa	; 0xeaa <vTaskSuspendAll>
     7da:	0f b6       	in	r0, 0x3f	; 63
     7dc:	f8 94       	cli
     7de:	0f 92       	push	r0
     7e0:	f8 01       	movw	r30, r16
     7e2:	85 8d       	ldd	r24, Z+29	; 0x1d
     7e4:	8f 3f       	cpi	r24, 0xFF	; 255
     7e6:	09 f4       	brne	.+2      	; 0x7ea <xQueueGenericSend+0xb6>
     7e8:	15 8e       	std	Z+29, r1	; 0x1d
     7ea:	f8 01       	movw	r30, r16
     7ec:	86 8d       	ldd	r24, Z+30	; 0x1e
     7ee:	8f 3f       	cpi	r24, 0xFF	; 255
     7f0:	09 f4       	brne	.+2      	; 0x7f4 <xQueueGenericSend+0xc0>
     7f2:	16 8e       	std	Z+30, r1	; 0x1e
     7f4:	0f 90       	pop	r0
     7f6:	0f be       	out	0x3f, r0	; 63
     7f8:	be 01       	movw	r22, r28
     7fa:	6c 5f       	subi	r22, 0xFC	; 252
     7fc:	7f 4f       	sbci	r23, 0xFF	; 255
     7fe:	ce 01       	movw	r24, r28
     800:	01 96       	adiw	r24, 0x01	; 1
     802:	0e 94 24 0a 	call	0x1448	; 0x1448 <xTaskCheckForTimeOut>
     806:	81 11       	cpse	r24, r1
     808:	1f c0       	rjmp	.+62     	; 0x848 <xQueueGenericSend+0x114>
     80a:	0f b6       	in	r0, 0x3f	; 63
     80c:	f8 94       	cli
     80e:	0f 92       	push	r0
     810:	f8 01       	movw	r30, r16
     812:	92 8d       	ldd	r25, Z+26	; 0x1a
     814:	0f 90       	pop	r0
     816:	0f be       	out	0x3f, r0	; 63
     818:	83 8d       	ldd	r24, Z+27	; 0x1b
     81a:	98 13       	cpse	r25, r24
     81c:	0f c0       	rjmp	.+30     	; 0x83c <xQueueGenericSend+0x108>
     81e:	6c 81       	ldd	r22, Y+4	; 0x04
     820:	7d 81       	ldd	r23, Y+5	; 0x05
     822:	c7 01       	movw	r24, r14
     824:	0e 94 a6 09 	call	0x134c	; 0x134c <vTaskPlaceOnEventList>
     828:	c8 01       	movw	r24, r16
     82a:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <prvUnlockQueue>
     82e:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
     832:	81 11       	cpse	r24, r1
     834:	9b cf       	rjmp	.-202    	; 0x76c <xQueueGenericSend+0x38>
     836:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     83a:	98 cf       	rjmp	.-208    	; 0x76c <xQueueGenericSend+0x38>
     83c:	c8 01       	movw	r24, r16
     83e:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <prvUnlockQueue>
     842:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
     846:	92 cf       	rjmp	.-220    	; 0x76c <xQueueGenericSend+0x38>
     848:	c8 01       	movw	r24, r16
     84a:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <prvUnlockQueue>
     84e:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
     852:	80 e0       	ldi	r24, 0x00	; 0
     854:	0f 90       	pop	r0
     856:	0f 90       	pop	r0
     858:	0f 90       	pop	r0
     85a:	0f 90       	pop	r0
     85c:	0f 90       	pop	r0
     85e:	df 91       	pop	r29
     860:	cf 91       	pop	r28
     862:	1f 91       	pop	r17
     864:	0f 91       	pop	r16
     866:	ff 90       	pop	r15
     868:	ef 90       	pop	r14
     86a:	df 90       	pop	r13
     86c:	cf 90       	pop	r12
     86e:	bf 90       	pop	r11
     870:	af 90       	pop	r10
     872:	9f 90       	pop	r9
     874:	08 95       	ret

00000876 <xQueueGenericSendFromISR>:
     876:	ef 92       	push	r14
     878:	ff 92       	push	r15
     87a:	0f 93       	push	r16
     87c:	1f 93       	push	r17
     87e:	cf 93       	push	r28
     880:	df 93       	push	r29
     882:	8a 01       	movw	r16, r20
     884:	fc 01       	movw	r30, r24
     886:	52 8d       	ldd	r21, Z+26	; 0x1a
     888:	33 8d       	ldd	r19, Z+27	; 0x1b
     88a:	53 17       	cp	r21, r19
     88c:	10 f0       	brcs	.+4      	; 0x892 <xQueueGenericSendFromISR+0x1c>
     88e:	22 30       	cpi	r18, 0x02	; 2
     890:	f1 f4       	brne	.+60     	; 0x8ce <xQueueGenericSendFromISR+0x58>
     892:	42 2f       	mov	r20, r18
     894:	78 01       	movw	r14, r16
     896:	ec 01       	movw	r28, r24
     898:	1e 8d       	ldd	r17, Y+30	; 0x1e
     89a:	0e 94 80 02 	call	0x500	; 0x500 <prvCopyDataToQueue>
     89e:	1f 3f       	cpi	r17, 0xFF	; 255
     8a0:	81 f4       	brne	.+32     	; 0x8c2 <xQueueGenericSendFromISR+0x4c>
     8a2:	89 89       	ldd	r24, Y+17	; 0x11
     8a4:	88 23       	and	r24, r24
     8a6:	a9 f0       	breq	.+42     	; 0x8d2 <xQueueGenericSendFromISR+0x5c>
     8a8:	ce 01       	movw	r24, r28
     8aa:	41 96       	adiw	r24, 0x11	; 17
     8ac:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <xTaskRemoveFromEventList>
     8b0:	88 23       	and	r24, r24
     8b2:	89 f0       	breq	.+34     	; 0x8d6 <xQueueGenericSendFromISR+0x60>
     8b4:	e1 14       	cp	r14, r1
     8b6:	f1 04       	cpc	r15, r1
     8b8:	81 f0       	breq	.+32     	; 0x8da <xQueueGenericSendFromISR+0x64>
     8ba:	81 e0       	ldi	r24, 0x01	; 1
     8bc:	f7 01       	movw	r30, r14
     8be:	80 83       	st	Z, r24
     8c0:	0d c0       	rjmp	.+26     	; 0x8dc <xQueueGenericSendFromISR+0x66>
     8c2:	ff 24       	eor	r15, r15
     8c4:	f3 94       	inc	r15
     8c6:	f1 0e       	add	r15, r17
     8c8:	fe 8e       	std	Y+30, r15	; 0x1e
     8ca:	81 e0       	ldi	r24, 0x01	; 1
     8cc:	07 c0       	rjmp	.+14     	; 0x8dc <xQueueGenericSendFromISR+0x66>
     8ce:	80 e0       	ldi	r24, 0x00	; 0
     8d0:	05 c0       	rjmp	.+10     	; 0x8dc <xQueueGenericSendFromISR+0x66>
     8d2:	81 e0       	ldi	r24, 0x01	; 1
     8d4:	03 c0       	rjmp	.+6      	; 0x8dc <xQueueGenericSendFromISR+0x66>
     8d6:	81 e0       	ldi	r24, 0x01	; 1
     8d8:	01 c0       	rjmp	.+2      	; 0x8dc <xQueueGenericSendFromISR+0x66>
     8da:	81 e0       	ldi	r24, 0x01	; 1
     8dc:	df 91       	pop	r29
     8de:	cf 91       	pop	r28
     8e0:	1f 91       	pop	r17
     8e2:	0f 91       	pop	r16
     8e4:	ff 90       	pop	r15
     8e6:	ef 90       	pop	r14
     8e8:	08 95       	ret

000008ea <xQueueGenericReceive>:
     8ea:	8f 92       	push	r8
     8ec:	9f 92       	push	r9
     8ee:	af 92       	push	r10
     8f0:	bf 92       	push	r11
     8f2:	cf 92       	push	r12
     8f4:	df 92       	push	r13
     8f6:	ef 92       	push	r14
     8f8:	ff 92       	push	r15
     8fa:	0f 93       	push	r16
     8fc:	1f 93       	push	r17
     8fe:	cf 93       	push	r28
     900:	df 93       	push	r29
     902:	00 d0       	rcall	.+0      	; 0x904 <__stack+0x5>
     904:	00 d0       	rcall	.+0      	; 0x906 <__stack+0x7>
     906:	1f 92       	push	r1
     908:	cd b7       	in	r28, 0x3d	; 61
     90a:	de b7       	in	r29, 0x3e	; 62
     90c:	8c 01       	movw	r16, r24
     90e:	5b 01       	movw	r10, r22
     910:	5d 83       	std	Y+5, r21	; 0x05
     912:	4c 83       	std	Y+4, r20	; 0x04
     914:	82 2e       	mov	r8, r18
     916:	e1 2c       	mov	r14, r1
     918:	99 24       	eor	r9, r9
     91a:	93 94       	inc	r9
     91c:	6c 01       	movw	r12, r24
     91e:	81 e1       	ldi	r24, 0x11	; 17
     920:	c8 0e       	add	r12, r24
     922:	d1 1c       	adc	r13, r1
     924:	0f b6       	in	r0, 0x3f	; 63
     926:	f8 94       	cli
     928:	0f 92       	push	r0
     92a:	f8 01       	movw	r30, r16
     92c:	f2 8c       	ldd	r15, Z+26	; 0x1a
     92e:	ff 20       	and	r15, r15
     930:	41 f1       	breq	.+80     	; 0x982 <__stack+0x83>
     932:	c6 80       	ldd	r12, Z+6	; 0x06
     934:	d7 80       	ldd	r13, Z+7	; 0x07
     936:	b5 01       	movw	r22, r10
     938:	c8 01       	movw	r24, r16
     93a:	0e 94 c9 02 	call	0x592	; 0x592 <prvCopyDataFromQueue>
     93e:	81 10       	cpse	r8, r1
     940:	0f c0       	rjmp	.+30     	; 0x960 <__stack+0x61>
     942:	fa 94       	dec	r15
     944:	f8 01       	movw	r30, r16
     946:	f2 8e       	std	Z+26, r15	; 0x1a
     948:	80 85       	ldd	r24, Z+8	; 0x08
     94a:	88 23       	and	r24, r24
     94c:	b1 f0       	breq	.+44     	; 0x97a <__stack+0x7b>
     94e:	c8 01       	movw	r24, r16
     950:	08 96       	adiw	r24, 0x08	; 8
     952:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <xTaskRemoveFromEventList>
     956:	88 23       	and	r24, r24
     958:	81 f0       	breq	.+32     	; 0x97a <__stack+0x7b>
     95a:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     95e:	0d c0       	rjmp	.+26     	; 0x97a <__stack+0x7b>
     960:	f8 01       	movw	r30, r16
     962:	d7 82       	std	Z+7, r13	; 0x07
     964:	c6 82       	std	Z+6, r12	; 0x06
     966:	81 89       	ldd	r24, Z+17	; 0x11
     968:	88 23       	and	r24, r24
     96a:	39 f0       	breq	.+14     	; 0x97a <__stack+0x7b>
     96c:	c8 01       	movw	r24, r16
     96e:	41 96       	adiw	r24, 0x11	; 17
     970:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <xTaskRemoveFromEventList>
     974:	81 11       	cpse	r24, r1
     976:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     97a:	0f 90       	pop	r0
     97c:	0f be       	out	0x3f, r0	; 63
     97e:	81 e0       	ldi	r24, 0x01	; 1
     980:	57 c0       	rjmp	.+174    	; 0xa30 <__stack+0x131>
     982:	8c 81       	ldd	r24, Y+4	; 0x04
     984:	9d 81       	ldd	r25, Y+5	; 0x05
     986:	89 2b       	or	r24, r25
     988:	21 f4       	brne	.+8      	; 0x992 <__stack+0x93>
     98a:	0f 90       	pop	r0
     98c:	0f be       	out	0x3f, r0	; 63
     98e:	80 e0       	ldi	r24, 0x00	; 0
     990:	4f c0       	rjmp	.+158    	; 0xa30 <__stack+0x131>
     992:	e1 10       	cpse	r14, r1
     994:	05 c0       	rjmp	.+10     	; 0x9a0 <__stack+0xa1>
     996:	ce 01       	movw	r24, r28
     998:	01 96       	adiw	r24, 0x01	; 1
     99a:	0e 94 19 0a 	call	0x1432	; 0x1432 <vTaskSetTimeOutState>
     99e:	e9 2c       	mov	r14, r9
     9a0:	0f 90       	pop	r0
     9a2:	0f be       	out	0x3f, r0	; 63
     9a4:	0e 94 55 07 	call	0xeaa	; 0xeaa <vTaskSuspendAll>
     9a8:	0f b6       	in	r0, 0x3f	; 63
     9aa:	f8 94       	cli
     9ac:	0f 92       	push	r0
     9ae:	f8 01       	movw	r30, r16
     9b0:	85 8d       	ldd	r24, Z+29	; 0x1d
     9b2:	8f 3f       	cpi	r24, 0xFF	; 255
     9b4:	09 f4       	brne	.+2      	; 0x9b8 <__stack+0xb9>
     9b6:	15 8e       	std	Z+29, r1	; 0x1d
     9b8:	f8 01       	movw	r30, r16
     9ba:	86 8d       	ldd	r24, Z+30	; 0x1e
     9bc:	8f 3f       	cpi	r24, 0xFF	; 255
     9be:	09 f4       	brne	.+2      	; 0x9c2 <__stack+0xc3>
     9c0:	16 8e       	std	Z+30, r1	; 0x1e
     9c2:	0f 90       	pop	r0
     9c4:	0f be       	out	0x3f, r0	; 63
     9c6:	be 01       	movw	r22, r28
     9c8:	6c 5f       	subi	r22, 0xFC	; 252
     9ca:	7f 4f       	sbci	r23, 0xFF	; 255
     9cc:	ce 01       	movw	r24, r28
     9ce:	01 96       	adiw	r24, 0x01	; 1
     9d0:	0e 94 24 0a 	call	0x1448	; 0x1448 <xTaskCheckForTimeOut>
     9d4:	81 11       	cpse	r24, r1
     9d6:	1e c0       	rjmp	.+60     	; 0xa14 <__stack+0x115>
     9d8:	0f b6       	in	r0, 0x3f	; 63
     9da:	f8 94       	cli
     9dc:	0f 92       	push	r0
     9de:	f8 01       	movw	r30, r16
     9e0:	82 8d       	ldd	r24, Z+26	; 0x1a
     9e2:	0f 90       	pop	r0
     9e4:	0f be       	out	0x3f, r0	; 63
     9e6:	81 11       	cpse	r24, r1
     9e8:	0f c0       	rjmp	.+30     	; 0xa08 <__stack+0x109>
     9ea:	6c 81       	ldd	r22, Y+4	; 0x04
     9ec:	7d 81       	ldd	r23, Y+5	; 0x05
     9ee:	c6 01       	movw	r24, r12
     9f0:	0e 94 a6 09 	call	0x134c	; 0x134c <vTaskPlaceOnEventList>
     9f4:	c8 01       	movw	r24, r16
     9f6:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <prvUnlockQueue>
     9fa:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
     9fe:	81 11       	cpse	r24, r1
     a00:	91 cf       	rjmp	.-222    	; 0x924 <__stack+0x25>
     a02:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     a06:	8e cf       	rjmp	.-228    	; 0x924 <__stack+0x25>
     a08:	c8 01       	movw	r24, r16
     a0a:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <prvUnlockQueue>
     a0e:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
     a12:	88 cf       	rjmp	.-240    	; 0x924 <__stack+0x25>
     a14:	c8 01       	movw	r24, r16
     a16:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <prvUnlockQueue>
     a1a:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
     a1e:	0f b6       	in	r0, 0x3f	; 63
     a20:	f8 94       	cli
     a22:	0f 92       	push	r0
     a24:	f8 01       	movw	r30, r16
     a26:	82 8d       	ldd	r24, Z+26	; 0x1a
     a28:	0f 90       	pop	r0
     a2a:	0f be       	out	0x3f, r0	; 63
     a2c:	81 11       	cpse	r24, r1
     a2e:	7a cf       	rjmp	.-268    	; 0x924 <__stack+0x25>
     a30:	0f 90       	pop	r0
     a32:	0f 90       	pop	r0
     a34:	0f 90       	pop	r0
     a36:	0f 90       	pop	r0
     a38:	0f 90       	pop	r0
     a3a:	df 91       	pop	r29
     a3c:	cf 91       	pop	r28
     a3e:	1f 91       	pop	r17
     a40:	0f 91       	pop	r16
     a42:	ff 90       	pop	r15
     a44:	ef 90       	pop	r14
     a46:	df 90       	pop	r13
     a48:	cf 90       	pop	r12
     a4a:	bf 90       	pop	r11
     a4c:	af 90       	pop	r10
     a4e:	9f 90       	pop	r9
     a50:	8f 90       	pop	r8
     a52:	08 95       	ret

00000a54 <vQueueAddToRegistry>:
     a54:	20 91 84 08 	lds	r18, 0x0884	; 0x800884 <xQueueRegistry>
     a58:	30 91 85 08 	lds	r19, 0x0885	; 0x800885 <xQueueRegistry+0x1>
     a5c:	23 2b       	or	r18, r19
     a5e:	31 f4       	brne	.+12     	; 0xa6c <vQueueAddToRegistry+0x18>
     a60:	e4 e8       	ldi	r30, 0x84	; 132
     a62:	f8 e0       	ldi	r31, 0x08	; 8
     a64:	71 83       	std	Z+1, r23	; 0x01
     a66:	60 83       	st	Z, r22
     a68:	93 83       	std	Z+3, r25	; 0x03
     a6a:	82 83       	std	Z+2, r24	; 0x02
     a6c:	08 95       	ret

00000a6e <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
     a6e:	cf 93       	push	r28
     a70:	df 93       	push	r29
     a72:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
     a74:	0f b6       	in	r0, 0x3f	; 63
     a76:	f8 94       	cli
     a78:	0f 92       	push	r0
     a7a:	8d 8d       	ldd	r24, Y+29	; 0x1d
     a7c:	8f 3f       	cpi	r24, 0xFF	; 255
     a7e:	09 f4       	brne	.+2      	; 0xa82 <vQueueWaitForMessageRestricted+0x14>
     a80:	1d 8e       	std	Y+29, r1	; 0x1d
     a82:	8e 8d       	ldd	r24, Y+30	; 0x1e
     a84:	8f 3f       	cpi	r24, 0xFF	; 255
     a86:	09 f4       	brne	.+2      	; 0xa8a <vQueueWaitForMessageRestricted+0x1c>
     a88:	1e 8e       	std	Y+30, r1	; 0x1e
     a8a:	0f 90       	pop	r0
     a8c:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
     a8e:	8a 8d       	ldd	r24, Y+26	; 0x1a
     a90:	81 11       	cpse	r24, r1
     a92:	04 c0       	rjmp	.+8      	; 0xa9c <vQueueWaitForMessageRestricted+0x2e>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
     a94:	ce 01       	movw	r24, r28
     a96:	41 96       	adiw	r24, 0x11	; 17
     a98:	0e 94 b8 09 	call	0x1370	; 0x1370 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
     a9c:	ce 01       	movw	r24, r28
     a9e:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <prvUnlockQueue>
	}
     aa2:	df 91       	pop	r29
     aa4:	cf 91       	pop	r28
     aa6:	08 95       	ret

00000aa8 <prvResetNextTaskUnblockTime>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     aa8:	e0 91 2e 08 	lds	r30, 0x082E	; 0x80082e <pxDelayedTaskList>
     aac:	f0 91 2f 08 	lds	r31, 0x082F	; 0x80082f <pxDelayedTaskList+0x1>
     ab0:	80 81       	ld	r24, Z
     ab2:	81 11       	cpse	r24, r1
     ab4:	07 c0       	rjmp	.+14     	; 0xac4 <prvResetNextTaskUnblockTime+0x1c>
     ab6:	8f ef       	ldi	r24, 0xFF	; 255
     ab8:	9f ef       	ldi	r25, 0xFF	; 255
     aba:	90 93 06 08 	sts	0x0806, r25	; 0x800806 <xNextTaskUnblockTime+0x1>
     abe:	80 93 05 08 	sts	0x0805, r24	; 0x800805 <xNextTaskUnblockTime>
     ac2:	08 95       	ret
     ac4:	e0 91 2e 08 	lds	r30, 0x082E	; 0x80082e <pxDelayedTaskList>
     ac8:	f0 91 2f 08 	lds	r31, 0x082F	; 0x80082f <pxDelayedTaskList+0x1>
     acc:	05 80       	ldd	r0, Z+5	; 0x05
     ace:	f6 81       	ldd	r31, Z+6	; 0x06
     ad0:	e0 2d       	mov	r30, r0
     ad2:	06 80       	ldd	r0, Z+6	; 0x06
     ad4:	f7 81       	ldd	r31, Z+7	; 0x07
     ad6:	e0 2d       	mov	r30, r0
     ad8:	82 81       	ldd	r24, Z+2	; 0x02
     ada:	93 81       	ldd	r25, Z+3	; 0x03
     adc:	90 93 06 08 	sts	0x0806, r25	; 0x800806 <xNextTaskUnblockTime+0x1>
     ae0:	80 93 05 08 	sts	0x0805, r24	; 0x800805 <xNextTaskUnblockTime>
     ae4:	08 95       	ret

00000ae6 <prvAddCurrentTaskToDelayedList>:
     ae6:	ff 92       	push	r15
     ae8:	0f 93       	push	r16
     aea:	1f 93       	push	r17
     aec:	cf 93       	push	r28
     aee:	df 93       	push	r29
     af0:	ec 01       	movw	r28, r24
     af2:	f6 2e       	mov	r15, r22
     af4:	00 91 0d 08 	lds	r16, 0x080D	; 0x80080d <xTickCount>
     af8:	10 91 0e 08 	lds	r17, 0x080E	; 0x80080e <xTickCount+0x1>
     afc:	80 91 66 08 	lds	r24, 0x0866	; 0x800866 <pxCurrentTCB>
     b00:	90 91 67 08 	lds	r25, 0x0867	; 0x800867 <pxCurrentTCB+0x1>
     b04:	02 96       	adiw	r24, 0x02	; 2
     b06:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
     b0a:	cf 3f       	cpi	r28, 0xFF	; 255
     b0c:	8f ef       	ldi	r24, 0xFF	; 255
     b0e:	d8 07       	cpc	r29, r24
     b10:	69 f4       	brne	.+26     	; 0xb2c <prvAddCurrentTaskToDelayedList+0x46>
     b12:	ff 20       	and	r15, r15
     b14:	59 f0       	breq	.+22     	; 0xb2c <prvAddCurrentTaskToDelayedList+0x46>
     b16:	60 91 66 08 	lds	r22, 0x0866	; 0x800866 <pxCurrentTCB>
     b1a:	70 91 67 08 	lds	r23, 0x0867	; 0x800867 <pxCurrentTCB+0x1>
     b1e:	6e 5f       	subi	r22, 0xFE	; 254
     b20:	7f 4f       	sbci	r23, 0xFF	; 255
     b22:	80 e1       	ldi	r24, 0x10	; 16
     b24:	98 e0       	ldi	r25, 0x08	; 8
     b26:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
     b2a:	2f c0       	rjmp	.+94     	; 0xb8a <prvAddCurrentTaskToDelayedList+0xa4>
     b2c:	c0 0f       	add	r28, r16
     b2e:	d1 1f       	adc	r29, r17
     b30:	e0 91 66 08 	lds	r30, 0x0866	; 0x800866 <pxCurrentTCB>
     b34:	f0 91 67 08 	lds	r31, 0x0867	; 0x800867 <pxCurrentTCB+0x1>
     b38:	d3 83       	std	Z+3, r29	; 0x03
     b3a:	c2 83       	std	Z+2, r28	; 0x02
     b3c:	c0 17       	cp	r28, r16
     b3e:	d1 07       	cpc	r29, r17
     b40:	68 f4       	brcc	.+26     	; 0xb5c <prvAddCurrentTaskToDelayedList+0x76>
     b42:	60 91 66 08 	lds	r22, 0x0866	; 0x800866 <pxCurrentTCB>
     b46:	70 91 67 08 	lds	r23, 0x0867	; 0x800867 <pxCurrentTCB+0x1>
     b4a:	80 91 2c 08 	lds	r24, 0x082C	; 0x80082c <pxOverflowDelayedTaskList>
     b4e:	90 91 2d 08 	lds	r25, 0x082D	; 0x80082d <pxOverflowDelayedTaskList+0x1>
     b52:	6e 5f       	subi	r22, 0xFE	; 254
     b54:	7f 4f       	sbci	r23, 0xFF	; 255
     b56:	0e 94 90 00 	call	0x120	; 0x120 <vListInsert>
     b5a:	17 c0       	rjmp	.+46     	; 0xb8a <prvAddCurrentTaskToDelayedList+0xa4>
     b5c:	60 91 66 08 	lds	r22, 0x0866	; 0x800866 <pxCurrentTCB>
     b60:	70 91 67 08 	lds	r23, 0x0867	; 0x800867 <pxCurrentTCB+0x1>
     b64:	80 91 2e 08 	lds	r24, 0x082E	; 0x80082e <pxDelayedTaskList>
     b68:	90 91 2f 08 	lds	r25, 0x082F	; 0x80082f <pxDelayedTaskList+0x1>
     b6c:	6e 5f       	subi	r22, 0xFE	; 254
     b6e:	7f 4f       	sbci	r23, 0xFF	; 255
     b70:	0e 94 90 00 	call	0x120	; 0x120 <vListInsert>
     b74:	80 91 05 08 	lds	r24, 0x0805	; 0x800805 <xNextTaskUnblockTime>
     b78:	90 91 06 08 	lds	r25, 0x0806	; 0x800806 <xNextTaskUnblockTime+0x1>
     b7c:	c8 17       	cp	r28, r24
     b7e:	d9 07       	cpc	r29, r25
     b80:	20 f4       	brcc	.+8      	; 0xb8a <prvAddCurrentTaskToDelayedList+0xa4>
     b82:	d0 93 06 08 	sts	0x0806, r29	; 0x800806 <xNextTaskUnblockTime+0x1>
     b86:	c0 93 05 08 	sts	0x0805, r28	; 0x800805 <xNextTaskUnblockTime>
     b8a:	df 91       	pop	r29
     b8c:	cf 91       	pop	r28
     b8e:	1f 91       	pop	r17
     b90:	0f 91       	pop	r16
     b92:	ff 90       	pop	r15
     b94:	08 95       	ret

00000b96 <xTaskCreate>:
     b96:	4f 92       	push	r4
     b98:	5f 92       	push	r5
     b9a:	6f 92       	push	r6
     b9c:	7f 92       	push	r7
     b9e:	8f 92       	push	r8
     ba0:	9f 92       	push	r9
     ba2:	af 92       	push	r10
     ba4:	bf 92       	push	r11
     ba6:	cf 92       	push	r12
     ba8:	df 92       	push	r13
     baa:	ef 92       	push	r14
     bac:	ff 92       	push	r15
     bae:	0f 93       	push	r16
     bb0:	cf 93       	push	r28
     bb2:	df 93       	push	r29
     bb4:	4c 01       	movw	r8, r24
     bb6:	6b 01       	movw	r12, r22
     bb8:	5a 01       	movw	r10, r20
     bba:	29 01       	movw	r4, r18
     bbc:	ca 01       	movw	r24, r20
     bbe:	0e 94 e7 00 	call	0x1ce	; 0x1ce <pvPortMalloc>
     bc2:	3c 01       	movw	r6, r24
     bc4:	89 2b       	or	r24, r25
     bc6:	09 f4       	brne	.+2      	; 0xbca <xTaskCreate+0x34>
     bc8:	e2 c0       	rjmp	.+452    	; 0xd8e <xTaskCreate+0x1f8>
     bca:	86 e2       	ldi	r24, 0x26	; 38
     bcc:	90 e0       	ldi	r25, 0x00	; 0
     bce:	0e 94 e7 00 	call	0x1ce	; 0x1ce <pvPortMalloc>
     bd2:	ec 01       	movw	r28, r24
     bd4:	89 2b       	or	r24, r25
     bd6:	71 f0       	breq	.+28     	; 0xbf4 <xTaskCreate+0x5e>
     bd8:	78 8e       	std	Y+24, r7	; 0x18
     bda:	6f 8a       	std	Y+23, r6	; 0x17
     bdc:	81 e0       	ldi	r24, 0x01	; 1
     bde:	a8 1a       	sub	r10, r24
     be0:	b1 08       	sbc	r11, r1
     be2:	a6 0c       	add	r10, r6
     be4:	b7 1c       	adc	r11, r7
     be6:	d6 01       	movw	r26, r12
     be8:	8c 91       	ld	r24, X
     bea:	89 8f       	std	Y+25, r24	; 0x19
     bec:	8c 91       	ld	r24, X
     bee:	81 11       	cpse	r24, r1
     bf0:	05 c0       	rjmp	.+10     	; 0xbfc <xTaskCreate+0x66>
     bf2:	18 c0       	rjmp	.+48     	; 0xc24 <xTaskCreate+0x8e>
     bf4:	c3 01       	movw	r24, r6
     bf6:	0e 94 1c 01 	call	0x238	; 0x238 <vPortFree>
     bfa:	c9 c0       	rjmp	.+402    	; 0xd8e <xTaskCreate+0x1f8>
     bfc:	ae 01       	movw	r20, r28
     bfe:	46 5e       	subi	r20, 0xE6	; 230
     c00:	5f 4f       	sbci	r21, 0xFF	; 255
     c02:	f6 01       	movw	r30, r12
     c04:	31 96       	adiw	r30, 0x01	; 1
     c06:	b8 e0       	ldi	r27, 0x08	; 8
     c08:	cb 0e       	add	r12, r27
     c0a:	d1 1c       	adc	r13, r1
     c0c:	cf 01       	movw	r24, r30
     c0e:	21 91       	ld	r18, Z+
     c10:	da 01       	movw	r26, r20
     c12:	2d 93       	st	X+, r18
     c14:	ad 01       	movw	r20, r26
     c16:	dc 01       	movw	r26, r24
     c18:	8c 91       	ld	r24, X
     c1a:	88 23       	and	r24, r24
     c1c:	19 f0       	breq	.+6      	; 0xc24 <xTaskCreate+0x8e>
     c1e:	ec 15       	cp	r30, r12
     c20:	fd 05       	cpc	r31, r13
     c22:	a1 f7       	brne	.-24     	; 0xc0c <xTaskCreate+0x76>
     c24:	18 a2       	std	Y+32, r1	; 0x20
     c26:	04 30       	cpi	r16, 0x04	; 4
     c28:	08 f0       	brcs	.+2      	; 0xc2c <xTaskCreate+0x96>
     c2a:	03 e0       	ldi	r16, 0x03	; 3
     c2c:	0e 8b       	std	Y+22, r16	; 0x16
     c2e:	6e 01       	movw	r12, r28
     c30:	b2 e0       	ldi	r27, 0x02	; 2
     c32:	cb 0e       	add	r12, r27
     c34:	d1 1c       	adc	r13, r1
     c36:	c6 01       	movw	r24, r12
     c38:	0e 94 6b 00 	call	0xd6	; 0xd6 <vListInitialiseItem>
     c3c:	ce 01       	movw	r24, r28
     c3e:	0c 96       	adiw	r24, 0x0c	; 12
     c40:	0e 94 6b 00 	call	0xd6	; 0xd6 <vListInitialiseItem>
     c44:	d9 87       	std	Y+9, r29	; 0x09
     c46:	c8 87       	std	Y+8, r28	; 0x08
     c48:	84 e0       	ldi	r24, 0x04	; 4
     c4a:	90 e0       	ldi	r25, 0x00	; 0
     c4c:	80 1b       	sub	r24, r16
     c4e:	91 09       	sbc	r25, r1
     c50:	9d 87       	std	Y+13, r25	; 0x0d
     c52:	8c 87       	std	Y+12, r24	; 0x0c
     c54:	db 8b       	std	Y+19, r29	; 0x13
     c56:	ca 8b       	std	Y+18, r28	; 0x12
     c58:	19 a2       	std	Y+33, r1	; 0x21
     c5a:	1a a2       	std	Y+34, r1	; 0x22
     c5c:	1b a2       	std	Y+35, r1	; 0x23
     c5e:	1c a2       	std	Y+36, r1	; 0x24
     c60:	1d a2       	std	Y+37, r1	; 0x25
     c62:	a2 01       	movw	r20, r4
     c64:	b4 01       	movw	r22, r8
     c66:	c5 01       	movw	r24, r10
     c68:	0e 94 1d 01 	call	0x23a	; 0x23a <pxPortInitialiseStack>
     c6c:	99 83       	std	Y+1, r25	; 0x01
     c6e:	88 83       	st	Y, r24
     c70:	e1 14       	cp	r14, r1
     c72:	f1 04       	cpc	r15, r1
     c74:	19 f0       	breq	.+6      	; 0xc7c <xTaskCreate+0xe6>
     c76:	f7 01       	movw	r30, r14
     c78:	d1 83       	std	Z+1, r29	; 0x01
     c7a:	c0 83       	st	Z, r28
     c7c:	0f b6       	in	r0, 0x3f	; 63
     c7e:	f8 94       	cli
     c80:	0f 92       	push	r0
     c82:	80 91 0f 08 	lds	r24, 0x080F	; 0x80080f <uxCurrentNumberOfTasks>
     c86:	8f 5f       	subi	r24, 0xFF	; 255
     c88:	80 93 0f 08 	sts	0x080F, r24	; 0x80080f <uxCurrentNumberOfTasks>
     c8c:	80 91 66 08 	lds	r24, 0x0866	; 0x800866 <pxCurrentTCB>
     c90:	90 91 67 08 	lds	r25, 0x0867	; 0x800867 <pxCurrentTCB+0x1>
     c94:	89 2b       	or	r24, r25
     c96:	d1 f5       	brne	.+116    	; 0xd0c <xTaskCreate+0x176>
     c98:	d0 93 67 08 	sts	0x0867, r29	; 0x800867 <pxCurrentTCB+0x1>
     c9c:	c0 93 66 08 	sts	0x0866, r28	; 0x800866 <pxCurrentTCB>
     ca0:	80 91 0f 08 	lds	r24, 0x080F	; 0x80080f <uxCurrentNumberOfTasks>
     ca4:	81 30       	cpi	r24, 0x01	; 1
     ca6:	09 f0       	breq	.+2      	; 0xcaa <xTaskCreate+0x114>
     ca8:	41 c0       	rjmp	.+130    	; 0xd2c <xTaskCreate+0x196>
     caa:	82 e4       	ldi	r24, 0x42	; 66
     cac:	98 e0       	ldi	r25, 0x08	; 8
     cae:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     cb2:	8b e4       	ldi	r24, 0x4B	; 75
     cb4:	98 e0       	ldi	r25, 0x08	; 8
     cb6:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     cba:	84 e5       	ldi	r24, 0x54	; 84
     cbc:	98 e0       	ldi	r25, 0x08	; 8
     cbe:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     cc2:	8d e5       	ldi	r24, 0x5D	; 93
     cc4:	98 e0       	ldi	r25, 0x08	; 8
     cc6:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     cca:	89 e3       	ldi	r24, 0x39	; 57
     ccc:	98 e0       	ldi	r25, 0x08	; 8
     cce:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     cd2:	80 e3       	ldi	r24, 0x30	; 48
     cd4:	98 e0       	ldi	r25, 0x08	; 8
     cd6:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     cda:	83 e2       	ldi	r24, 0x23	; 35
     cdc:	98 e0       	ldi	r25, 0x08	; 8
     cde:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     ce2:	8a e1       	ldi	r24, 0x1A	; 26
     ce4:	98 e0       	ldi	r25, 0x08	; 8
     ce6:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     cea:	80 e1       	ldi	r24, 0x10	; 16
     cec:	98 e0       	ldi	r25, 0x08	; 8
     cee:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
     cf2:	89 e3       	ldi	r24, 0x39	; 57
     cf4:	98 e0       	ldi	r25, 0x08	; 8
     cf6:	90 93 2f 08 	sts	0x082F, r25	; 0x80082f <pxDelayedTaskList+0x1>
     cfa:	80 93 2e 08 	sts	0x082E, r24	; 0x80082e <pxDelayedTaskList>
     cfe:	80 e3       	ldi	r24, 0x30	; 48
     d00:	98 e0       	ldi	r25, 0x08	; 8
     d02:	90 93 2d 08 	sts	0x082D, r25	; 0x80082d <pxOverflowDelayedTaskList+0x1>
     d06:	80 93 2c 08 	sts	0x082C, r24	; 0x80082c <pxOverflowDelayedTaskList>
     d0a:	10 c0       	rjmp	.+32     	; 0xd2c <xTaskCreate+0x196>
     d0c:	80 91 0b 08 	lds	r24, 0x080B	; 0x80080b <xSchedulerRunning>
     d10:	81 11       	cpse	r24, r1
     d12:	0c c0       	rjmp	.+24     	; 0xd2c <xTaskCreate+0x196>
     d14:	e0 91 66 08 	lds	r30, 0x0866	; 0x800866 <pxCurrentTCB>
     d18:	f0 91 67 08 	lds	r31, 0x0867	; 0x800867 <pxCurrentTCB+0x1>
     d1c:	96 89       	ldd	r25, Z+22	; 0x16
     d1e:	8e 89       	ldd	r24, Y+22	; 0x16
     d20:	89 17       	cp	r24, r25
     d22:	20 f0       	brcs	.+8      	; 0xd2c <xTaskCreate+0x196>
     d24:	d0 93 67 08 	sts	0x0867, r29	; 0x800867 <pxCurrentTCB+0x1>
     d28:	c0 93 66 08 	sts	0x0866, r28	; 0x800866 <pxCurrentTCB>
     d2c:	80 91 07 08 	lds	r24, 0x0807	; 0x800807 <uxTaskNumber>
     d30:	8f 5f       	subi	r24, 0xFF	; 255
     d32:	80 93 07 08 	sts	0x0807, r24	; 0x800807 <uxTaskNumber>
     d36:	8e 89       	ldd	r24, Y+22	; 0x16
     d38:	90 91 0c 08 	lds	r25, 0x080C	; 0x80080c <uxTopReadyPriority>
     d3c:	98 17       	cp	r25, r24
     d3e:	10 f4       	brcc	.+4      	; 0xd44 <xTaskCreate+0x1ae>
     d40:	80 93 0c 08 	sts	0x080C, r24	; 0x80080c <uxTopReadyPriority>
     d44:	90 e0       	ldi	r25, 0x00	; 0
     d46:	9c 01       	movw	r18, r24
     d48:	22 0f       	add	r18, r18
     d4a:	33 1f       	adc	r19, r19
     d4c:	22 0f       	add	r18, r18
     d4e:	33 1f       	adc	r19, r19
     d50:	22 0f       	add	r18, r18
     d52:	33 1f       	adc	r19, r19
     d54:	82 0f       	add	r24, r18
     d56:	93 1f       	adc	r25, r19
     d58:	b6 01       	movw	r22, r12
     d5a:	8e 5b       	subi	r24, 0xBE	; 190
     d5c:	97 4f       	sbci	r25, 0xF7	; 247
     d5e:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
     d62:	0f 90       	pop	r0
     d64:	0f be       	out	0x3f, r0	; 63
     d66:	80 91 0b 08 	lds	r24, 0x080B	; 0x80080b <xSchedulerRunning>
     d6a:	88 23       	and	r24, r24
     d6c:	61 f0       	breq	.+24     	; 0xd86 <xTaskCreate+0x1f0>
     d6e:	e0 91 66 08 	lds	r30, 0x0866	; 0x800866 <pxCurrentTCB>
     d72:	f0 91 67 08 	lds	r31, 0x0867	; 0x800867 <pxCurrentTCB+0x1>
     d76:	96 89       	ldd	r25, Z+22	; 0x16
     d78:	8e 89       	ldd	r24, Y+22	; 0x16
     d7a:	98 17       	cp	r25, r24
     d7c:	30 f4       	brcc	.+12     	; 0xd8a <xTaskCreate+0x1f4>
     d7e:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     d82:	81 e0       	ldi	r24, 0x01	; 1
     d84:	05 c0       	rjmp	.+10     	; 0xd90 <xTaskCreate+0x1fa>
     d86:	81 e0       	ldi	r24, 0x01	; 1
     d88:	03 c0       	rjmp	.+6      	; 0xd90 <xTaskCreate+0x1fa>
     d8a:	81 e0       	ldi	r24, 0x01	; 1
     d8c:	01 c0       	rjmp	.+2      	; 0xd90 <xTaskCreate+0x1fa>
     d8e:	8f ef       	ldi	r24, 0xFF	; 255
     d90:	df 91       	pop	r29
     d92:	cf 91       	pop	r28
     d94:	0f 91       	pop	r16
     d96:	ff 90       	pop	r15
     d98:	ef 90       	pop	r14
     d9a:	df 90       	pop	r13
     d9c:	cf 90       	pop	r12
     d9e:	bf 90       	pop	r11
     da0:	af 90       	pop	r10
     da2:	9f 90       	pop	r9
     da4:	8f 90       	pop	r8
     da6:	7f 90       	pop	r7
     da8:	6f 90       	pop	r6
     daa:	5f 90       	pop	r5
     dac:	4f 90       	pop	r4
     dae:	08 95       	ret

00000db0 <vTaskResume>:
     db0:	0f 93       	push	r16
     db2:	1f 93       	push	r17
     db4:	cf 93       	push	r28
     db6:	df 93       	push	r29
     db8:	00 97       	sbiw	r24, 0x00	; 0
     dba:	09 f4       	brne	.+2      	; 0xdbe <vTaskResume+0xe>
     dbc:	43 c0       	rjmp	.+134    	; 0xe44 <vTaskResume+0x94>
     dbe:	20 91 66 08 	lds	r18, 0x0866	; 0x800866 <pxCurrentTCB>
     dc2:	30 91 67 08 	lds	r19, 0x0867	; 0x800867 <pxCurrentTCB+0x1>
     dc6:	82 17       	cp	r24, r18
     dc8:	93 07       	cpc	r25, r19
     dca:	09 f4       	brne	.+2      	; 0xdce <vTaskResume+0x1e>
     dcc:	3b c0       	rjmp	.+118    	; 0xe44 <vTaskResume+0x94>
     dce:	0f b6       	in	r0, 0x3f	; 63
     dd0:	f8 94       	cli
     dd2:	0f 92       	push	r0
     dd4:	fc 01       	movw	r30, r24
     dd6:	22 85       	ldd	r18, Z+10	; 0x0a
     dd8:	33 85       	ldd	r19, Z+11	; 0x0b
     dda:	20 51       	subi	r18, 0x10	; 16
     ddc:	38 40       	sbci	r19, 0x08	; 8
     dde:	81 f5       	brne	.+96     	; 0xe40 <vTaskResume+0x90>
     de0:	fc 01       	movw	r30, r24
     de2:	24 89       	ldd	r18, Z+20	; 0x14
     de4:	35 89       	ldd	r19, Z+21	; 0x15
     de6:	f8 e0       	ldi	r31, 0x08	; 8
     de8:	23 32       	cpi	r18, 0x23	; 35
     dea:	3f 07       	cpc	r19, r31
     dec:	49 f1       	breq	.+82     	; 0xe40 <vTaskResume+0x90>
     dee:	23 2b       	or	r18, r19
     df0:	39 f5       	brne	.+78     	; 0xe40 <vTaskResume+0x90>
     df2:	ec 01       	movw	r28, r24
     df4:	8c 01       	movw	r16, r24
     df6:	0e 5f       	subi	r16, 0xFE	; 254
     df8:	1f 4f       	sbci	r17, 0xFF	; 255
     dfa:	c8 01       	movw	r24, r16
     dfc:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
     e00:	8e 89       	ldd	r24, Y+22	; 0x16
     e02:	90 91 0c 08 	lds	r25, 0x080C	; 0x80080c <uxTopReadyPriority>
     e06:	98 17       	cp	r25, r24
     e08:	10 f4       	brcc	.+4      	; 0xe0e <vTaskResume+0x5e>
     e0a:	80 93 0c 08 	sts	0x080C, r24	; 0x80080c <uxTopReadyPriority>
     e0e:	90 e0       	ldi	r25, 0x00	; 0
     e10:	9c 01       	movw	r18, r24
     e12:	22 0f       	add	r18, r18
     e14:	33 1f       	adc	r19, r19
     e16:	22 0f       	add	r18, r18
     e18:	33 1f       	adc	r19, r19
     e1a:	22 0f       	add	r18, r18
     e1c:	33 1f       	adc	r19, r19
     e1e:	82 0f       	add	r24, r18
     e20:	93 1f       	adc	r25, r19
     e22:	b8 01       	movw	r22, r16
     e24:	8e 5b       	subi	r24, 0xBE	; 190
     e26:	97 4f       	sbci	r25, 0xF7	; 247
     e28:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
     e2c:	e0 91 66 08 	lds	r30, 0x0866	; 0x800866 <pxCurrentTCB>
     e30:	f0 91 67 08 	lds	r31, 0x0867	; 0x800867 <pxCurrentTCB+0x1>
     e34:	9e 89       	ldd	r25, Y+22	; 0x16
     e36:	86 89       	ldd	r24, Z+22	; 0x16
     e38:	98 17       	cp	r25, r24
     e3a:	10 f0       	brcs	.+4      	; 0xe40 <vTaskResume+0x90>
     e3c:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
     e40:	0f 90       	pop	r0
     e42:	0f be       	out	0x3f, r0	; 63
     e44:	df 91       	pop	r29
     e46:	cf 91       	pop	r28
     e48:	1f 91       	pop	r17
     e4a:	0f 91       	pop	r16
     e4c:	08 95       	ret

00000e4e <vTaskStartScheduler>:
     e4e:	ef 92       	push	r14
     e50:	ff 92       	push	r15
     e52:	0f 93       	push	r16
     e54:	0f 2e       	mov	r0, r31
     e56:	f3 e0       	ldi	r31, 0x03	; 3
     e58:	ef 2e       	mov	r14, r31
     e5a:	f8 e0       	ldi	r31, 0x08	; 8
     e5c:	ff 2e       	mov	r15, r31
     e5e:	f0 2d       	mov	r31, r0
     e60:	00 e0       	ldi	r16, 0x00	; 0
     e62:	20 e0       	ldi	r18, 0x00	; 0
     e64:	30 e0       	ldi	r19, 0x00	; 0
     e66:	45 e5       	ldi	r20, 0x55	; 85
     e68:	50 e0       	ldi	r21, 0x00	; 0
     e6a:	66 e0       	ldi	r22, 0x06	; 6
     e6c:	71 e0       	ldi	r23, 0x01	; 1
     e6e:	83 eb       	ldi	r24, 0xB3	; 179
     e70:	98 e0       	ldi	r25, 0x08	; 8
     e72:	0e 94 cb 05 	call	0xb96	; 0xb96 <xTaskCreate>
     e76:	81 30       	cpi	r24, 0x01	; 1
     e78:	a1 f4       	brne	.+40     	; 0xea2 <vTaskStartScheduler+0x54>
     e7a:	0e 94 cd 0a 	call	0x159a	; 0x159a <xTimerCreateTimerTask>
     e7e:	81 30       	cpi	r24, 0x01	; 1
     e80:	81 f4       	brne	.+32     	; 0xea2 <vTaskStartScheduler+0x54>
     e82:	f8 94       	cli
     e84:	8f ef       	ldi	r24, 0xFF	; 255
     e86:	9f ef       	ldi	r25, 0xFF	; 255
     e88:	90 93 06 08 	sts	0x0806, r25	; 0x800806 <xNextTaskUnblockTime+0x1>
     e8c:	80 93 05 08 	sts	0x0805, r24	; 0x800805 <xNextTaskUnblockTime>
     e90:	81 e0       	ldi	r24, 0x01	; 1
     e92:	80 93 0b 08 	sts	0x080B, r24	; 0x80080b <xSchedulerRunning>
     e96:	10 92 0e 08 	sts	0x080E, r1	; 0x80080e <xTickCount+0x1>
     e9a:	10 92 0d 08 	sts	0x080D, r1	; 0x80080d <xTickCount>
     e9e:	0e 94 89 01 	call	0x312	; 0x312 <xPortStartScheduler>
     ea2:	0f 91       	pop	r16
     ea4:	ff 90       	pop	r15
     ea6:	ef 90       	pop	r14
     ea8:	08 95       	ret

00000eaa <vTaskSuspendAll>:
     eaa:	80 91 02 08 	lds	r24, 0x0802	; 0x800802 <uxSchedulerSuspended>
     eae:	8f 5f       	subi	r24, 0xFF	; 255
     eb0:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <uxSchedulerSuspended>
     eb4:	08 95       	ret

00000eb6 <xTaskGetTickCount>:
     eb6:	0f b6       	in	r0, 0x3f	; 63
     eb8:	f8 94       	cli
     eba:	0f 92       	push	r0
     ebc:	80 91 0d 08 	lds	r24, 0x080D	; 0x80080d <xTickCount>
     ec0:	90 91 0e 08 	lds	r25, 0x080E	; 0x80080e <xTickCount+0x1>
     ec4:	0f 90       	pop	r0
     ec6:	0f be       	out	0x3f, r0	; 63
     ec8:	08 95       	ret

00000eca <xTaskIncrementTick>:
     eca:	cf 92       	push	r12
     ecc:	df 92       	push	r13
     ece:	ef 92       	push	r14
     ed0:	ff 92       	push	r15
     ed2:	0f 93       	push	r16
     ed4:	1f 93       	push	r17
     ed6:	cf 93       	push	r28
     ed8:	df 93       	push	r29
     eda:	80 91 02 08 	lds	r24, 0x0802	; 0x800802 <uxSchedulerSuspended>
     ede:	81 11       	cpse	r24, r1
     ee0:	99 c0       	rjmp	.+306    	; 0x1014 <xTaskIncrementTick+0x14a>
     ee2:	e0 90 0d 08 	lds	r14, 0x080D	; 0x80080d <xTickCount>
     ee6:	f0 90 0e 08 	lds	r15, 0x080E	; 0x80080e <xTickCount+0x1>
     eea:	8f ef       	ldi	r24, 0xFF	; 255
     eec:	e8 1a       	sub	r14, r24
     eee:	f8 0a       	sbc	r15, r24
     ef0:	f0 92 0e 08 	sts	0x080E, r15	; 0x80080e <xTickCount+0x1>
     ef4:	e0 92 0d 08 	sts	0x080D, r14	; 0x80080d <xTickCount>
     ef8:	e1 14       	cp	r14, r1
     efa:	f1 04       	cpc	r15, r1
     efc:	b9 f4       	brne	.+46     	; 0xf2c <xTaskIncrementTick+0x62>
     efe:	80 91 2e 08 	lds	r24, 0x082E	; 0x80082e <pxDelayedTaskList>
     f02:	90 91 2f 08 	lds	r25, 0x082F	; 0x80082f <pxDelayedTaskList+0x1>
     f06:	20 91 2c 08 	lds	r18, 0x082C	; 0x80082c <pxOverflowDelayedTaskList>
     f0a:	30 91 2d 08 	lds	r19, 0x082D	; 0x80082d <pxOverflowDelayedTaskList+0x1>
     f0e:	30 93 2f 08 	sts	0x082F, r19	; 0x80082f <pxDelayedTaskList+0x1>
     f12:	20 93 2e 08 	sts	0x082E, r18	; 0x80082e <pxDelayedTaskList>
     f16:	90 93 2d 08 	sts	0x082D, r25	; 0x80082d <pxOverflowDelayedTaskList+0x1>
     f1a:	80 93 2c 08 	sts	0x082C, r24	; 0x80082c <pxOverflowDelayedTaskList>
     f1e:	80 91 08 08 	lds	r24, 0x0808	; 0x800808 <xNumOfOverflows>
     f22:	8f 5f       	subi	r24, 0xFF	; 255
     f24:	80 93 08 08 	sts	0x0808, r24	; 0x800808 <xNumOfOverflows>
     f28:	0e 94 54 05 	call	0xaa8	; 0xaa8 <prvResetNextTaskUnblockTime>
     f2c:	80 91 05 08 	lds	r24, 0x0805	; 0x800805 <xNextTaskUnblockTime>
     f30:	90 91 06 08 	lds	r25, 0x0806	; 0x800806 <xNextTaskUnblockTime+0x1>
     f34:	e8 16       	cp	r14, r24
     f36:	f9 06       	cpc	r15, r25
     f38:	10 f4       	brcc	.+4      	; 0xf3e <xTaskIncrementTick+0x74>
     f3a:	d1 2c       	mov	r13, r1
     f3c:	53 c0       	rjmp	.+166    	; 0xfe4 <xTaskIncrementTick+0x11a>
     f3e:	d1 2c       	mov	r13, r1
     f40:	cc 24       	eor	r12, r12
     f42:	c3 94       	inc	r12
     f44:	e0 91 2e 08 	lds	r30, 0x082E	; 0x80082e <pxDelayedTaskList>
     f48:	f0 91 2f 08 	lds	r31, 0x082F	; 0x80082f <pxDelayedTaskList+0x1>
     f4c:	80 81       	ld	r24, Z
     f4e:	81 11       	cpse	r24, r1
     f50:	07 c0       	rjmp	.+14     	; 0xf60 <xTaskIncrementTick+0x96>
     f52:	8f ef       	ldi	r24, 0xFF	; 255
     f54:	9f ef       	ldi	r25, 0xFF	; 255
     f56:	90 93 06 08 	sts	0x0806, r25	; 0x800806 <xNextTaskUnblockTime+0x1>
     f5a:	80 93 05 08 	sts	0x0805, r24	; 0x800805 <xNextTaskUnblockTime>
     f5e:	42 c0       	rjmp	.+132    	; 0xfe4 <xTaskIncrementTick+0x11a>
     f60:	e0 91 2e 08 	lds	r30, 0x082E	; 0x80082e <pxDelayedTaskList>
     f64:	f0 91 2f 08 	lds	r31, 0x082F	; 0x80082f <pxDelayedTaskList+0x1>
     f68:	05 80       	ldd	r0, Z+5	; 0x05
     f6a:	f6 81       	ldd	r31, Z+6	; 0x06
     f6c:	e0 2d       	mov	r30, r0
     f6e:	c6 81       	ldd	r28, Z+6	; 0x06
     f70:	d7 81       	ldd	r29, Z+7	; 0x07
     f72:	8a 81       	ldd	r24, Y+2	; 0x02
     f74:	9b 81       	ldd	r25, Y+3	; 0x03
     f76:	e8 16       	cp	r14, r24
     f78:	f9 06       	cpc	r15, r25
     f7a:	28 f4       	brcc	.+10     	; 0xf86 <xTaskIncrementTick+0xbc>
     f7c:	90 93 06 08 	sts	0x0806, r25	; 0x800806 <xNextTaskUnblockTime+0x1>
     f80:	80 93 05 08 	sts	0x0805, r24	; 0x800805 <xNextTaskUnblockTime>
     f84:	2f c0       	rjmp	.+94     	; 0xfe4 <xTaskIncrementTick+0x11a>
     f86:	8e 01       	movw	r16, r28
     f88:	0e 5f       	subi	r16, 0xFE	; 254
     f8a:	1f 4f       	sbci	r17, 0xFF	; 255
     f8c:	c8 01       	movw	r24, r16
     f8e:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
     f92:	8c 89       	ldd	r24, Y+20	; 0x14
     f94:	9d 89       	ldd	r25, Y+21	; 0x15
     f96:	89 2b       	or	r24, r25
     f98:	21 f0       	breq	.+8      	; 0xfa2 <xTaskIncrementTick+0xd8>
     f9a:	ce 01       	movw	r24, r28
     f9c:	0c 96       	adiw	r24, 0x0c	; 12
     f9e:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
     fa2:	8e 89       	ldd	r24, Y+22	; 0x16
     fa4:	90 91 0c 08 	lds	r25, 0x080C	; 0x80080c <uxTopReadyPriority>
     fa8:	98 17       	cp	r25, r24
     faa:	10 f4       	brcc	.+4      	; 0xfb0 <xTaskIncrementTick+0xe6>
     fac:	80 93 0c 08 	sts	0x080C, r24	; 0x80080c <uxTopReadyPriority>
     fb0:	90 e0       	ldi	r25, 0x00	; 0
     fb2:	9c 01       	movw	r18, r24
     fb4:	22 0f       	add	r18, r18
     fb6:	33 1f       	adc	r19, r19
     fb8:	22 0f       	add	r18, r18
     fba:	33 1f       	adc	r19, r19
     fbc:	22 0f       	add	r18, r18
     fbe:	33 1f       	adc	r19, r19
     fc0:	82 0f       	add	r24, r18
     fc2:	93 1f       	adc	r25, r19
     fc4:	b8 01       	movw	r22, r16
     fc6:	8e 5b       	subi	r24, 0xBE	; 190
     fc8:	97 4f       	sbci	r25, 0xF7	; 247
     fca:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
     fce:	e0 91 66 08 	lds	r30, 0x0866	; 0x800866 <pxCurrentTCB>
     fd2:	f0 91 67 08 	lds	r31, 0x0867	; 0x800867 <pxCurrentTCB+0x1>
     fd6:	9e 89       	ldd	r25, Y+22	; 0x16
     fd8:	86 89       	ldd	r24, Z+22	; 0x16
     fda:	98 17       	cp	r25, r24
     fdc:	08 f4       	brcc	.+2      	; 0xfe0 <xTaskIncrementTick+0x116>
     fde:	b2 cf       	rjmp	.-156    	; 0xf44 <xTaskIncrementTick+0x7a>
     fe0:	dc 2c       	mov	r13, r12
     fe2:	b0 cf       	rjmp	.-160    	; 0xf44 <xTaskIncrementTick+0x7a>
     fe4:	e0 91 66 08 	lds	r30, 0x0866	; 0x800866 <pxCurrentTCB>
     fe8:	f0 91 67 08 	lds	r31, 0x0867	; 0x800867 <pxCurrentTCB+0x1>
     fec:	86 89       	ldd	r24, Z+22	; 0x16
     fee:	90 e0       	ldi	r25, 0x00	; 0
     ff0:	fc 01       	movw	r30, r24
     ff2:	ee 0f       	add	r30, r30
     ff4:	ff 1f       	adc	r31, r31
     ff6:	ee 0f       	add	r30, r30
     ff8:	ff 1f       	adc	r31, r31
     ffa:	ee 0f       	add	r30, r30
     ffc:	ff 1f       	adc	r31, r31
     ffe:	8e 0f       	add	r24, r30
    1000:	9f 1f       	adc	r25, r31
    1002:	fc 01       	movw	r30, r24
    1004:	ee 5b       	subi	r30, 0xBE	; 190
    1006:	f7 4f       	sbci	r31, 0xF7	; 247
    1008:	80 81       	ld	r24, Z
    100a:	82 30       	cpi	r24, 0x02	; 2
    100c:	48 f0       	brcs	.+18     	; 0x1020 <xTaskIncrementTick+0x156>
    100e:	dd 24       	eor	r13, r13
    1010:	d3 94       	inc	r13
    1012:	06 c0       	rjmp	.+12     	; 0x1020 <xTaskIncrementTick+0x156>
    1014:	80 91 0a 08 	lds	r24, 0x080A	; 0x80080a <uxPendedTicks>
    1018:	8f 5f       	subi	r24, 0xFF	; 255
    101a:	80 93 0a 08 	sts	0x080A, r24	; 0x80080a <uxPendedTicks>
    101e:	d1 2c       	mov	r13, r1
    1020:	80 91 09 08 	lds	r24, 0x0809	; 0x800809 <xYieldPending>
    1024:	88 23       	and	r24, r24
    1026:	11 f0       	breq	.+4      	; 0x102c <xTaskIncrementTick+0x162>
    1028:	dd 24       	eor	r13, r13
    102a:	d3 94       	inc	r13
    102c:	8d 2d       	mov	r24, r13
    102e:	df 91       	pop	r29
    1030:	cf 91       	pop	r28
    1032:	1f 91       	pop	r17
    1034:	0f 91       	pop	r16
    1036:	ff 90       	pop	r15
    1038:	ef 90       	pop	r14
    103a:	df 90       	pop	r13
    103c:	cf 90       	pop	r12
    103e:	08 95       	ret

00001040 <xTaskResumeAll>:
    1040:	df 92       	push	r13
    1042:	ef 92       	push	r14
    1044:	ff 92       	push	r15
    1046:	0f 93       	push	r16
    1048:	1f 93       	push	r17
    104a:	cf 93       	push	r28
    104c:	df 93       	push	r29
    104e:	0f b6       	in	r0, 0x3f	; 63
    1050:	f8 94       	cli
    1052:	0f 92       	push	r0
    1054:	80 91 02 08 	lds	r24, 0x0802	; 0x800802 <uxSchedulerSuspended>
    1058:	81 50       	subi	r24, 0x01	; 1
    105a:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <uxSchedulerSuspended>
    105e:	80 91 02 08 	lds	r24, 0x0802	; 0x800802 <uxSchedulerSuspended>
    1062:	81 11       	cpse	r24, r1
    1064:	5f c0       	rjmp	.+190    	; 0x1124 <xTaskResumeAll+0xe4>
    1066:	80 91 0f 08 	lds	r24, 0x080F	; 0x80080f <uxCurrentNumberOfTasks>
    106a:	81 11       	cpse	r24, r1
    106c:	33 c0       	rjmp	.+102    	; 0x10d4 <xTaskResumeAll+0x94>
    106e:	5d c0       	rjmp	.+186    	; 0x112a <xTaskResumeAll+0xea>
    1070:	d7 01       	movw	r26, r14
    1072:	15 96       	adiw	r26, 0x05	; 5
    1074:	ed 91       	ld	r30, X+
    1076:	fc 91       	ld	r31, X
    1078:	16 97       	sbiw	r26, 0x06	; 6
    107a:	c6 81       	ldd	r28, Z+6	; 0x06
    107c:	d7 81       	ldd	r29, Z+7	; 0x07
    107e:	ce 01       	movw	r24, r28
    1080:	0c 96       	adiw	r24, 0x0c	; 12
    1082:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
    1086:	8e 01       	movw	r16, r28
    1088:	0e 5f       	subi	r16, 0xFE	; 254
    108a:	1f 4f       	sbci	r17, 0xFF	; 255
    108c:	c8 01       	movw	r24, r16
    108e:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
    1092:	8e 89       	ldd	r24, Y+22	; 0x16
    1094:	90 91 0c 08 	lds	r25, 0x080C	; 0x80080c <uxTopReadyPriority>
    1098:	98 17       	cp	r25, r24
    109a:	10 f4       	brcc	.+4      	; 0x10a0 <xTaskResumeAll+0x60>
    109c:	80 93 0c 08 	sts	0x080C, r24	; 0x80080c <uxTopReadyPriority>
    10a0:	90 e0       	ldi	r25, 0x00	; 0
    10a2:	9c 01       	movw	r18, r24
    10a4:	22 0f       	add	r18, r18
    10a6:	33 1f       	adc	r19, r19
    10a8:	22 0f       	add	r18, r18
    10aa:	33 1f       	adc	r19, r19
    10ac:	22 0f       	add	r18, r18
    10ae:	33 1f       	adc	r19, r19
    10b0:	82 0f       	add	r24, r18
    10b2:	93 1f       	adc	r25, r19
    10b4:	b8 01       	movw	r22, r16
    10b6:	8e 5b       	subi	r24, 0xBE	; 190
    10b8:	97 4f       	sbci	r25, 0xF7	; 247
    10ba:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
    10be:	e0 91 66 08 	lds	r30, 0x0866	; 0x800866 <pxCurrentTCB>
    10c2:	f0 91 67 08 	lds	r31, 0x0867	; 0x800867 <pxCurrentTCB+0x1>
    10c6:	9e 89       	ldd	r25, Y+22	; 0x16
    10c8:	86 89       	ldd	r24, Z+22	; 0x16
    10ca:	98 17       	cp	r25, r24
    10cc:	68 f0       	brcs	.+26     	; 0x10e8 <xTaskResumeAll+0xa8>
    10ce:	d0 92 09 08 	sts	0x0809, r13	; 0x800809 <xYieldPending>
    10d2:	0a c0       	rjmp	.+20     	; 0x10e8 <xTaskResumeAll+0xa8>
    10d4:	c0 e0       	ldi	r28, 0x00	; 0
    10d6:	d0 e0       	ldi	r29, 0x00	; 0
    10d8:	0f 2e       	mov	r0, r31
    10da:	f3 e2       	ldi	r31, 0x23	; 35
    10dc:	ef 2e       	mov	r14, r31
    10de:	f8 e0       	ldi	r31, 0x08	; 8
    10e0:	ff 2e       	mov	r15, r31
    10e2:	f0 2d       	mov	r31, r0
    10e4:	dd 24       	eor	r13, r13
    10e6:	d3 94       	inc	r13
    10e8:	f7 01       	movw	r30, r14
    10ea:	80 81       	ld	r24, Z
    10ec:	81 11       	cpse	r24, r1
    10ee:	c0 cf       	rjmp	.-128    	; 0x1070 <xTaskResumeAll+0x30>
    10f0:	cd 2b       	or	r28, r29
    10f2:	11 f0       	breq	.+4      	; 0x10f8 <xTaskResumeAll+0xb8>
    10f4:	0e 94 54 05 	call	0xaa8	; 0xaa8 <prvResetNextTaskUnblockTime>
    10f8:	c0 91 0a 08 	lds	r28, 0x080A	; 0x80080a <uxPendedTicks>
    10fc:	cc 23       	and	r28, r28
    10fe:	51 f0       	breq	.+20     	; 0x1114 <xTaskResumeAll+0xd4>
    1100:	d1 e0       	ldi	r29, 0x01	; 1
    1102:	0e 94 65 07 	call	0xeca	; 0xeca <xTaskIncrementTick>
    1106:	81 11       	cpse	r24, r1
    1108:	d0 93 09 08 	sts	0x0809, r29	; 0x800809 <xYieldPending>
    110c:	c1 50       	subi	r28, 0x01	; 1
    110e:	c9 f7       	brne	.-14     	; 0x1102 <xTaskResumeAll+0xc2>
    1110:	10 92 0a 08 	sts	0x080A, r1	; 0x80080a <uxPendedTicks>
    1114:	80 91 09 08 	lds	r24, 0x0809	; 0x800809 <xYieldPending>
    1118:	88 23       	and	r24, r24
    111a:	31 f0       	breq	.+12     	; 0x1128 <xTaskResumeAll+0xe8>
    111c:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
    1120:	81 e0       	ldi	r24, 0x01	; 1
    1122:	03 c0       	rjmp	.+6      	; 0x112a <xTaskResumeAll+0xea>
    1124:	80 e0       	ldi	r24, 0x00	; 0
    1126:	01 c0       	rjmp	.+2      	; 0x112a <xTaskResumeAll+0xea>
    1128:	80 e0       	ldi	r24, 0x00	; 0
    112a:	0f 90       	pop	r0
    112c:	0f be       	out	0x3f, r0	; 63
    112e:	df 91       	pop	r29
    1130:	cf 91       	pop	r28
    1132:	1f 91       	pop	r17
    1134:	0f 91       	pop	r16
    1136:	ff 90       	pop	r15
    1138:	ef 90       	pop	r14
    113a:	df 90       	pop	r13
    113c:	08 95       	ret

0000113e <vTaskDelay>:
    113e:	cf 93       	push	r28
    1140:	df 93       	push	r29
    1142:	ec 01       	movw	r28, r24
    1144:	89 2b       	or	r24, r25
    1146:	51 f0       	breq	.+20     	; 0x115c <vTaskDelay+0x1e>
    1148:	0e 94 55 07 	call	0xeaa	; 0xeaa <vTaskSuspendAll>
    114c:	60 e0       	ldi	r22, 0x00	; 0
    114e:	ce 01       	movw	r24, r28
    1150:	0e 94 73 05 	call	0xae6	; 0xae6 <prvAddCurrentTaskToDelayedList>
    1154:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
    1158:	81 11       	cpse	r24, r1
    115a:	02 c0       	rjmp	.+4      	; 0x1160 <vTaskDelay+0x22>
    115c:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
    1160:	df 91       	pop	r29
    1162:	cf 91       	pop	r28
    1164:	08 95       	ret

00001166 <prvIdleTask>:
    1166:	0a e1       	ldi	r16, 0x1A	; 26
    1168:	18 e0       	ldi	r17, 0x08	; 8
    116a:	0f 2e       	mov	r0, r31
    116c:	f2 e4       	ldi	r31, 0x42	; 66
    116e:	ef 2e       	mov	r14, r31
    1170:	f8 e0       	ldi	r31, 0x08	; 8
    1172:	ff 2e       	mov	r15, r31
    1174:	f0 2d       	mov	r31, r0
    1176:	29 c0       	rjmp	.+82     	; 0x11ca <prvIdleTask+0x64>
    1178:	0e 94 55 07 	call	0xeaa	; 0xeaa <vTaskSuspendAll>
    117c:	d8 01       	movw	r26, r16
    117e:	cc 91       	ld	r28, X
    1180:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
    1184:	cc 23       	and	r28, r28
    1186:	09 f1       	breq	.+66     	; 0x11ca <prvIdleTask+0x64>
    1188:	0f b6       	in	r0, 0x3f	; 63
    118a:	f8 94       	cli
    118c:	0f 92       	push	r0
    118e:	d8 01       	movw	r26, r16
    1190:	15 96       	adiw	r26, 0x05	; 5
    1192:	ed 91       	ld	r30, X+
    1194:	fc 91       	ld	r31, X
    1196:	16 97       	sbiw	r26, 0x06	; 6
    1198:	c6 81       	ldd	r28, Z+6	; 0x06
    119a:	d7 81       	ldd	r29, Z+7	; 0x07
    119c:	ce 01       	movw	r24, r28
    119e:	02 96       	adiw	r24, 0x02	; 2
    11a0:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
    11a4:	80 91 0f 08 	lds	r24, 0x080F	; 0x80080f <uxCurrentNumberOfTasks>
    11a8:	81 50       	subi	r24, 0x01	; 1
    11aa:	80 93 0f 08 	sts	0x080F, r24	; 0x80080f <uxCurrentNumberOfTasks>
    11ae:	80 91 19 08 	lds	r24, 0x0819	; 0x800819 <uxDeletedTasksWaitingCleanUp>
    11b2:	81 50       	subi	r24, 0x01	; 1
    11b4:	80 93 19 08 	sts	0x0819, r24	; 0x800819 <uxDeletedTasksWaitingCleanUp>
    11b8:	0f 90       	pop	r0
    11ba:	0f be       	out	0x3f, r0	; 63
    11bc:	8f 89       	ldd	r24, Y+23	; 0x17
    11be:	98 8d       	ldd	r25, Y+24	; 0x18
    11c0:	0e 94 1c 01 	call	0x238	; 0x238 <vPortFree>
    11c4:	ce 01       	movw	r24, r28
    11c6:	0e 94 1c 01 	call	0x238	; 0x238 <vPortFree>
    11ca:	80 91 19 08 	lds	r24, 0x0819	; 0x800819 <uxDeletedTasksWaitingCleanUp>
    11ce:	81 11       	cpse	r24, r1
    11d0:	d3 cf       	rjmp	.-90     	; 0x1178 <prvIdleTask+0x12>
    11d2:	f7 01       	movw	r30, r14
    11d4:	80 81       	ld	r24, Z
    11d6:	82 30       	cpi	r24, 0x02	; 2
    11d8:	10 f0       	brcs	.+4      	; 0x11de <prvIdleTask+0x78>
    11da:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
    11de:	0e 94 ac 11 	call	0x2358	; 0x2358 <vApplicationIdleHook>
    11e2:	f3 cf       	rjmp	.-26     	; 0x11ca <prvIdleTask+0x64>

000011e4 <vTaskSwitchContext>:
    11e4:	80 91 02 08 	lds	r24, 0x0802	; 0x800802 <uxSchedulerSuspended>
    11e8:	88 23       	and	r24, r24
    11ea:	21 f0       	breq	.+8      	; 0x11f4 <vTaskSwitchContext+0x10>
    11ec:	81 e0       	ldi	r24, 0x01	; 1
    11ee:	80 93 09 08 	sts	0x0809, r24	; 0x800809 <xYieldPending>
    11f2:	08 95       	ret
    11f4:	10 92 09 08 	sts	0x0809, r1	; 0x800809 <xYieldPending>
    11f8:	20 91 0c 08 	lds	r18, 0x080C	; 0x80080c <uxTopReadyPriority>
    11fc:	82 2f       	mov	r24, r18
    11fe:	90 e0       	ldi	r25, 0x00	; 0
    1200:	fc 01       	movw	r30, r24
    1202:	ee 0f       	add	r30, r30
    1204:	ff 1f       	adc	r31, r31
    1206:	ee 0f       	add	r30, r30
    1208:	ff 1f       	adc	r31, r31
    120a:	ee 0f       	add	r30, r30
    120c:	ff 1f       	adc	r31, r31
    120e:	e8 0f       	add	r30, r24
    1210:	f9 1f       	adc	r31, r25
    1212:	ee 5b       	subi	r30, 0xBE	; 190
    1214:	f7 4f       	sbci	r31, 0xF7	; 247
    1216:	30 81       	ld	r19, Z
    1218:	31 11       	cpse	r19, r1
    121a:	11 c0       	rjmp	.+34     	; 0x123e <vTaskSwitchContext+0x5a>
    121c:	21 50       	subi	r18, 0x01	; 1
    121e:	82 2f       	mov	r24, r18
    1220:	90 e0       	ldi	r25, 0x00	; 0
    1222:	fc 01       	movw	r30, r24
    1224:	ee 0f       	add	r30, r30
    1226:	ff 1f       	adc	r31, r31
    1228:	ee 0f       	add	r30, r30
    122a:	ff 1f       	adc	r31, r31
    122c:	ee 0f       	add	r30, r30
    122e:	ff 1f       	adc	r31, r31
    1230:	e8 0f       	add	r30, r24
    1232:	f9 1f       	adc	r31, r25
    1234:	ee 5b       	subi	r30, 0xBE	; 190
    1236:	f7 4f       	sbci	r31, 0xF7	; 247
    1238:	30 81       	ld	r19, Z
    123a:	33 23       	and	r19, r19
    123c:	79 f3       	breq	.-34     	; 0x121c <vTaskSwitchContext+0x38>
    123e:	ac 01       	movw	r20, r24
    1240:	44 0f       	add	r20, r20
    1242:	55 1f       	adc	r21, r21
    1244:	44 0f       	add	r20, r20
    1246:	55 1f       	adc	r21, r21
    1248:	44 0f       	add	r20, r20
    124a:	55 1f       	adc	r21, r21
    124c:	48 0f       	add	r20, r24
    124e:	59 1f       	adc	r21, r25
    1250:	da 01       	movw	r26, r20
    1252:	ae 5b       	subi	r26, 0xBE	; 190
    1254:	b7 4f       	sbci	r27, 0xF7	; 247
    1256:	11 96       	adiw	r26, 0x01	; 1
    1258:	ed 91       	ld	r30, X+
    125a:	fc 91       	ld	r31, X
    125c:	12 97       	sbiw	r26, 0x02	; 2
    125e:	02 80       	ldd	r0, Z+2	; 0x02
    1260:	f3 81       	ldd	r31, Z+3	; 0x03
    1262:	e0 2d       	mov	r30, r0
    1264:	12 96       	adiw	r26, 0x02	; 2
    1266:	fc 93       	st	X, r31
    1268:	ee 93       	st	-X, r30
    126a:	11 97       	sbiw	r26, 0x01	; 1
    126c:	4b 5b       	subi	r20, 0xBB	; 187
    126e:	57 4f       	sbci	r21, 0xF7	; 247
    1270:	e4 17       	cp	r30, r20
    1272:	f5 07       	cpc	r31, r21
    1274:	29 f4       	brne	.+10     	; 0x1280 <vTaskSwitchContext+0x9c>
    1276:	42 81       	ldd	r20, Z+2	; 0x02
    1278:	53 81       	ldd	r21, Z+3	; 0x03
    127a:	fd 01       	movw	r30, r26
    127c:	52 83       	std	Z+2, r21	; 0x02
    127e:	41 83       	std	Z+1, r20	; 0x01
    1280:	fc 01       	movw	r30, r24
    1282:	ee 0f       	add	r30, r30
    1284:	ff 1f       	adc	r31, r31
    1286:	ee 0f       	add	r30, r30
    1288:	ff 1f       	adc	r31, r31
    128a:	ee 0f       	add	r30, r30
    128c:	ff 1f       	adc	r31, r31
    128e:	8e 0f       	add	r24, r30
    1290:	9f 1f       	adc	r25, r31
    1292:	fc 01       	movw	r30, r24
    1294:	ee 5b       	subi	r30, 0xBE	; 190
    1296:	f7 4f       	sbci	r31, 0xF7	; 247
    1298:	01 80       	ldd	r0, Z+1	; 0x01
    129a:	f2 81       	ldd	r31, Z+2	; 0x02
    129c:	e0 2d       	mov	r30, r0
    129e:	86 81       	ldd	r24, Z+6	; 0x06
    12a0:	97 81       	ldd	r25, Z+7	; 0x07
    12a2:	90 93 67 08 	sts	0x0867, r25	; 0x800867 <pxCurrentTCB+0x1>
    12a6:	80 93 66 08 	sts	0x0866, r24	; 0x800866 <pxCurrentTCB>
    12aa:	20 93 0c 08 	sts	0x080C, r18	; 0x80080c <uxTopReadyPriority>
    12ae:	08 95       	ret

000012b0 <vTaskSuspend>:
    12b0:	0f 93       	push	r16
    12b2:	1f 93       	push	r17
    12b4:	cf 93       	push	r28
    12b6:	df 93       	push	r29
    12b8:	ec 01       	movw	r28, r24
    12ba:	0f b6       	in	r0, 0x3f	; 63
    12bc:	f8 94       	cli
    12be:	0f 92       	push	r0
    12c0:	89 2b       	or	r24, r25
    12c2:	21 f4       	brne	.+8      	; 0x12cc <vTaskSuspend+0x1c>
    12c4:	c0 91 66 08 	lds	r28, 0x0866	; 0x800866 <pxCurrentTCB>
    12c8:	d0 91 67 08 	lds	r29, 0x0867	; 0x800867 <pxCurrentTCB+0x1>
    12cc:	8e 01       	movw	r16, r28
    12ce:	0e 5f       	subi	r16, 0xFE	; 254
    12d0:	1f 4f       	sbci	r17, 0xFF	; 255
    12d2:	c8 01       	movw	r24, r16
    12d4:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
    12d8:	8c 89       	ldd	r24, Y+20	; 0x14
    12da:	9d 89       	ldd	r25, Y+21	; 0x15
    12dc:	89 2b       	or	r24, r25
    12de:	21 f0       	breq	.+8      	; 0x12e8 <vTaskSuspend+0x38>
    12e0:	ce 01       	movw	r24, r28
    12e2:	0c 96       	adiw	r24, 0x0c	; 12
    12e4:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
    12e8:	b8 01       	movw	r22, r16
    12ea:	80 e1       	ldi	r24, 0x10	; 16
    12ec:	98 e0       	ldi	r25, 0x08	; 8
    12ee:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
    12f2:	0f 90       	pop	r0
    12f4:	0f be       	out	0x3f, r0	; 63
    12f6:	80 91 0b 08 	lds	r24, 0x080B	; 0x80080b <xSchedulerRunning>
    12fa:	88 23       	and	r24, r24
    12fc:	39 f0       	breq	.+14     	; 0x130c <vTaskSuspend+0x5c>
    12fe:	0f b6       	in	r0, 0x3f	; 63
    1300:	f8 94       	cli
    1302:	0f 92       	push	r0
    1304:	0e 94 54 05 	call	0xaa8	; 0xaa8 <prvResetNextTaskUnblockTime>
    1308:	0f 90       	pop	r0
    130a:	0f be       	out	0x3f, r0	; 63
    130c:	80 91 66 08 	lds	r24, 0x0866	; 0x800866 <pxCurrentTCB>
    1310:	90 91 67 08 	lds	r25, 0x0867	; 0x800867 <pxCurrentTCB+0x1>
    1314:	c8 17       	cp	r28, r24
    1316:	d9 07       	cpc	r29, r25
    1318:	a1 f4       	brne	.+40     	; 0x1342 <vTaskSuspend+0x92>
    131a:	80 91 0b 08 	lds	r24, 0x080B	; 0x80080b <xSchedulerRunning>
    131e:	88 23       	and	r24, r24
    1320:	19 f0       	breq	.+6      	; 0x1328 <vTaskSuspend+0x78>
    1322:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
    1326:	0d c0       	rjmp	.+26     	; 0x1342 <vTaskSuspend+0x92>
    1328:	80 91 0f 08 	lds	r24, 0x080F	; 0x80080f <uxCurrentNumberOfTasks>
    132c:	90 91 10 08 	lds	r25, 0x0810	; 0x800810 <xSuspendedTaskList>
    1330:	98 13       	cpse	r25, r24
    1332:	05 c0       	rjmp	.+10     	; 0x133e <vTaskSuspend+0x8e>
    1334:	10 92 67 08 	sts	0x0867, r1	; 0x800867 <pxCurrentTCB+0x1>
    1338:	10 92 66 08 	sts	0x0866, r1	; 0x800866 <pxCurrentTCB>
    133c:	02 c0       	rjmp	.+4      	; 0x1342 <vTaskSuspend+0x92>
    133e:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <vTaskSwitchContext>
    1342:	df 91       	pop	r29
    1344:	cf 91       	pop	r28
    1346:	1f 91       	pop	r17
    1348:	0f 91       	pop	r16
    134a:	08 95       	ret

0000134c <vTaskPlaceOnEventList>:
    134c:	cf 93       	push	r28
    134e:	df 93       	push	r29
    1350:	eb 01       	movw	r28, r22
    1352:	60 91 66 08 	lds	r22, 0x0866	; 0x800866 <pxCurrentTCB>
    1356:	70 91 67 08 	lds	r23, 0x0867	; 0x800867 <pxCurrentTCB+0x1>
    135a:	64 5f       	subi	r22, 0xF4	; 244
    135c:	7f 4f       	sbci	r23, 0xFF	; 255
    135e:	0e 94 90 00 	call	0x120	; 0x120 <vListInsert>
    1362:	61 e0       	ldi	r22, 0x01	; 1
    1364:	ce 01       	movw	r24, r28
    1366:	0e 94 73 05 	call	0xae6	; 0xae6 <prvAddCurrentTaskToDelayedList>
    136a:	df 91       	pop	r29
    136c:	cf 91       	pop	r28
    136e:	08 95       	ret

00001370 <vTaskPlaceOnEventListRestricted>:
    1370:	0f 93       	push	r16
    1372:	1f 93       	push	r17
    1374:	cf 93       	push	r28
    1376:	8b 01       	movw	r16, r22
    1378:	c4 2f       	mov	r28, r20
    137a:	60 91 66 08 	lds	r22, 0x0866	; 0x800866 <pxCurrentTCB>
    137e:	70 91 67 08 	lds	r23, 0x0867	; 0x800867 <pxCurrentTCB+0x1>
    1382:	64 5f       	subi	r22, 0xF4	; 244
    1384:	7f 4f       	sbci	r23, 0xFF	; 255
    1386:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
    138a:	cc 23       	and	r28, r28
    138c:	11 f0       	breq	.+4      	; 0x1392 <vTaskPlaceOnEventListRestricted+0x22>
    138e:	0f ef       	ldi	r16, 0xFF	; 255
    1390:	1f ef       	ldi	r17, 0xFF	; 255
    1392:	6c 2f       	mov	r22, r28
    1394:	c8 01       	movw	r24, r16
    1396:	0e 94 73 05 	call	0xae6	; 0xae6 <prvAddCurrentTaskToDelayedList>
    139a:	cf 91       	pop	r28
    139c:	1f 91       	pop	r17
    139e:	0f 91       	pop	r16
    13a0:	08 95       	ret

000013a2 <xTaskRemoveFromEventList>:
    13a2:	0f 93       	push	r16
    13a4:	1f 93       	push	r17
    13a6:	cf 93       	push	r28
    13a8:	df 93       	push	r29
    13aa:	dc 01       	movw	r26, r24
    13ac:	15 96       	adiw	r26, 0x05	; 5
    13ae:	ed 91       	ld	r30, X+
    13b0:	fc 91       	ld	r31, X
    13b2:	16 97       	sbiw	r26, 0x06	; 6
    13b4:	c6 81       	ldd	r28, Z+6	; 0x06
    13b6:	d7 81       	ldd	r29, Z+7	; 0x07
    13b8:	8e 01       	movw	r16, r28
    13ba:	04 5f       	subi	r16, 0xF4	; 244
    13bc:	1f 4f       	sbci	r17, 0xFF	; 255
    13be:	c8 01       	movw	r24, r16
    13c0:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
    13c4:	80 91 02 08 	lds	r24, 0x0802	; 0x800802 <uxSchedulerSuspended>
    13c8:	81 11       	cpse	r24, r1
    13ca:	1c c0       	rjmp	.+56     	; 0x1404 <xTaskRemoveFromEventList+0x62>
    13cc:	0a 50       	subi	r16, 0x0A	; 10
    13ce:	11 09       	sbc	r17, r1
    13d0:	c8 01       	movw	r24, r16
    13d2:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
    13d6:	8e 89       	ldd	r24, Y+22	; 0x16
    13d8:	90 91 0c 08 	lds	r25, 0x080C	; 0x80080c <uxTopReadyPriority>
    13dc:	98 17       	cp	r25, r24
    13de:	10 f4       	brcc	.+4      	; 0x13e4 <xTaskRemoveFromEventList+0x42>
    13e0:	80 93 0c 08 	sts	0x080C, r24	; 0x80080c <uxTopReadyPriority>
    13e4:	90 e0       	ldi	r25, 0x00	; 0
    13e6:	9c 01       	movw	r18, r24
    13e8:	22 0f       	add	r18, r18
    13ea:	33 1f       	adc	r19, r19
    13ec:	22 0f       	add	r18, r18
    13ee:	33 1f       	adc	r19, r19
    13f0:	22 0f       	add	r18, r18
    13f2:	33 1f       	adc	r19, r19
    13f4:	82 0f       	add	r24, r18
    13f6:	93 1f       	adc	r25, r19
    13f8:	b8 01       	movw	r22, r16
    13fa:	8e 5b       	subi	r24, 0xBE	; 190
    13fc:	97 4f       	sbci	r25, 0xF7	; 247
    13fe:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
    1402:	05 c0       	rjmp	.+10     	; 0x140e <xTaskRemoveFromEventList+0x6c>
    1404:	b8 01       	movw	r22, r16
    1406:	83 e2       	ldi	r24, 0x23	; 35
    1408:	98 e0       	ldi	r25, 0x08	; 8
    140a:	0e 94 6f 00 	call	0xde	; 0xde <vListInsertEnd>
    140e:	e0 91 66 08 	lds	r30, 0x0866	; 0x800866 <pxCurrentTCB>
    1412:	f0 91 67 08 	lds	r31, 0x0867	; 0x800867 <pxCurrentTCB+0x1>
    1416:	9e 89       	ldd	r25, Y+22	; 0x16
    1418:	86 89       	ldd	r24, Z+22	; 0x16
    141a:	89 17       	cp	r24, r25
    141c:	20 f4       	brcc	.+8      	; 0x1426 <xTaskRemoveFromEventList+0x84>
    141e:	81 e0       	ldi	r24, 0x01	; 1
    1420:	80 93 09 08 	sts	0x0809, r24	; 0x800809 <xYieldPending>
    1424:	01 c0       	rjmp	.+2      	; 0x1428 <xTaskRemoveFromEventList+0x86>
    1426:	80 e0       	ldi	r24, 0x00	; 0
    1428:	df 91       	pop	r29
    142a:	cf 91       	pop	r28
    142c:	1f 91       	pop	r17
    142e:	0f 91       	pop	r16
    1430:	08 95       	ret

00001432 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1432:	20 91 08 08 	lds	r18, 0x0808	; 0x800808 <xNumOfOverflows>
    1436:	fc 01       	movw	r30, r24
    1438:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    143a:	20 91 0d 08 	lds	r18, 0x080D	; 0x80080d <xTickCount>
    143e:	30 91 0e 08 	lds	r19, 0x080E	; 0x80080e <xTickCount+0x1>
    1442:	32 83       	std	Z+2, r19	; 0x02
    1444:	21 83       	std	Z+1, r18	; 0x01
    1446:	08 95       	ret

00001448 <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1448:	0f b6       	in	r0, 0x3f	; 63
    144a:	f8 94       	cli
    144c:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    144e:	40 91 0d 08 	lds	r20, 0x080D	; 0x80080d <xTickCount>
    1452:	50 91 0e 08 	lds	r21, 0x080E	; 0x80080e <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    1456:	db 01       	movw	r26, r22
    1458:	2d 91       	ld	r18, X+
    145a:	3c 91       	ld	r19, X
    145c:	2f 3f       	cpi	r18, 0xFF	; 255
    145e:	bf ef       	ldi	r27, 0xFF	; 255
    1460:	3b 07       	cpc	r19, r27
    1462:	19 f1       	breq	.+70     	; 0x14aa <xTaskCheckForTimeOut+0x62>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1464:	e0 91 08 08 	lds	r30, 0x0808	; 0x800808 <xNumOfOverflows>
    1468:	dc 01       	movw	r26, r24
    146a:	fc 91       	ld	r31, X
    146c:	fe 17       	cp	r31, r30
    146e:	39 f0       	breq	.+14     	; 0x147e <xTaskCheckForTimeOut+0x36>
    1470:	11 96       	adiw	r26, 0x01	; 1
    1472:	ed 91       	ld	r30, X+
    1474:	fc 91       	ld	r31, X
    1476:	12 97       	sbiw	r26, 0x02	; 2
    1478:	4e 17       	cp	r20, r30
    147a:	5f 07       	cpc	r21, r31
    147c:	c0 f4       	brcc	.+48     	; 0x14ae <xTaskCheckForTimeOut+0x66>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    147e:	dc 01       	movw	r26, r24
    1480:	11 96       	adiw	r26, 0x01	; 1
    1482:	ed 91       	ld	r30, X+
    1484:	fc 91       	ld	r31, X
    1486:	12 97       	sbiw	r26, 0x02	; 2
    1488:	da 01       	movw	r26, r20
    148a:	ae 1b       	sub	r26, r30
    148c:	bf 0b       	sbc	r27, r31
    148e:	a2 17       	cp	r26, r18
    1490:	b3 07       	cpc	r27, r19
    1492:	78 f4       	brcc	.+30     	; 0x14b2 <xTaskCheckForTimeOut+0x6a>
    1494:	db 01       	movw	r26, r22
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    1496:	e4 1b       	sub	r30, r20
    1498:	f5 0b       	sbc	r31, r21
    149a:	2e 0f       	add	r18, r30
    149c:	3f 1f       	adc	r19, r31
    149e:	2d 93       	st	X+, r18
    14a0:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    14a2:	0e 94 19 0a 	call	0x1432	; 0x1432 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    14a6:	80 e0       	ldi	r24, 0x00	; 0
    14a8:	05 c0       	rjmp	.+10     	; 0x14b4 <xTaskCheckForTimeOut+0x6c>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    14aa:	80 e0       	ldi	r24, 0x00	; 0
    14ac:	03 c0       	rjmp	.+6      	; 0x14b4 <xTaskCheckForTimeOut+0x6c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    14ae:	81 e0       	ldi	r24, 0x01	; 1
    14b0:	01 c0       	rjmp	.+2      	; 0x14b4 <xTaskCheckForTimeOut+0x6c>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    14b2:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    14b4:	0f 90       	pop	r0
    14b6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    14b8:	08 95       	ret

000014ba <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    14ba:	81 e0       	ldi	r24, 0x01	; 1
    14bc:	80 93 09 08 	sts	0x0809, r24	; 0x800809 <xYieldPending>
    14c0:	08 95       	ret

000014c2 <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    14c2:	80 91 0b 08 	lds	r24, 0x080B	; 0x80080b <xSchedulerRunning>
    14c6:	88 23       	and	r24, r24
    14c8:	31 f0       	breq	.+12     	; 0x14d6 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    14ca:	80 91 02 08 	lds	r24, 0x0802	; 0x800802 <uxSchedulerSuspended>
    14ce:	88 23       	and	r24, r24
    14d0:	21 f0       	breq	.+8      	; 0x14da <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    14d2:	80 e0       	ldi	r24, 0x00	; 0
    14d4:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    14d6:	81 e0       	ldi	r24, 0x01	; 1
    14d8:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    14da:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    14dc:	08 95       	ret

000014de <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    14de:	fc 01       	movw	r30, r24
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    14e0:	73 83       	std	Z+3, r23	; 0x03
    14e2:	62 83       	std	Z+2, r22	; 0x02
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    14e4:	91 87       	std	Z+9, r25	; 0x09
    14e6:	80 87       	std	Z+8, r24	; 0x08

	if( xNextExpiryTime <= xTimeNow )
    14e8:	46 17       	cp	r20, r22
    14ea:	57 07       	cpc	r21, r23
    14ec:	90 f0       	brcs	.+36     	; 0x1512 <prvInsertTimerInActiveList+0x34>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    14ee:	42 1b       	sub	r20, r18
    14f0:	53 0b       	sbc	r21, r19
    14f2:	84 85       	ldd	r24, Z+12	; 0x0c
    14f4:	95 85       	ldd	r25, Z+13	; 0x0d
    14f6:	48 17       	cp	r20, r24
    14f8:	59 07       	cpc	r21, r25
    14fa:	e0 f4       	brcc	.+56     	; 0x1534 <prvInsertTimerInActiveList+0x56>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    14fc:	bf 01       	movw	r22, r30
    14fe:	6e 5f       	subi	r22, 0xFE	; 254
    1500:	7f 4f       	sbci	r23, 0xFF	; 255
    1502:	80 91 6e 08 	lds	r24, 0x086E	; 0x80086e <pxOverflowTimerList>
    1506:	90 91 6f 08 	lds	r25, 0x086F	; 0x80086f <pxOverflowTimerList+0x1>
    150a:	0e 94 90 00 	call	0x120	; 0x120 <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    150e:	80 e0       	ldi	r24, 0x00	; 0
    1510:	08 95       	ret
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    1512:	42 17       	cp	r20, r18
    1514:	53 07       	cpc	r21, r19
    1516:	18 f4       	brcc	.+6      	; 0x151e <prvInsertTimerInActiveList+0x40>
    1518:	62 17       	cp	r22, r18
    151a:	73 07       	cpc	r23, r19
    151c:	68 f4       	brcc	.+26     	; 0x1538 <prvInsertTimerInActiveList+0x5a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    151e:	bf 01       	movw	r22, r30
    1520:	6e 5f       	subi	r22, 0xFE	; 254
    1522:	7f 4f       	sbci	r23, 0xFF	; 255
    1524:	80 91 70 08 	lds	r24, 0x0870	; 0x800870 <pxCurrentTimerList>
    1528:	90 91 71 08 	lds	r25, 0x0871	; 0x800871 <pxCurrentTimerList+0x1>
    152c:	0e 94 90 00 	call	0x120	; 0x120 <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    1530:	80 e0       	ldi	r24, 0x00	; 0
    1532:	08 95       	ret
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    1534:	81 e0       	ldi	r24, 0x01	; 1
    1536:	08 95       	ret
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    1538:	81 e0       	ldi	r24, 0x01	; 1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
    153a:	08 95       	ret

0000153c <prvCheckForValidListAndQueue>:
static void prvCheckForValidListAndQueue( void )
{
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    153c:	0f b6       	in	r0, 0x3f	; 63
    153e:	f8 94       	cli
    1540:	0f 92       	push	r0
	{
		if( xTimerQueue == NULL )
    1542:	80 91 6c 08 	lds	r24, 0x086C	; 0x80086c <xTimerQueue>
    1546:	90 91 6d 08 	lds	r25, 0x086D	; 0x80086d <xTimerQueue+0x1>
    154a:	89 2b       	or	r24, r25
    154c:	19 f5       	brne	.+70     	; 0x1594 <prvCheckForValidListAndQueue+0x58>
		{
			vListInitialise( &xActiveTimerList1 );
    154e:	8b e7       	ldi	r24, 0x7B	; 123
    1550:	98 e0       	ldi	r25, 0x08	; 8
    1552:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
    1556:	82 e7       	ldi	r24, 0x72	; 114
    1558:	98 e0       	ldi	r25, 0x08	; 8
    155a:	0e 94 5d 00 	call	0xba	; 0xba <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
    155e:	8b e7       	ldi	r24, 0x7B	; 123
    1560:	98 e0       	ldi	r25, 0x08	; 8
    1562:	90 93 71 08 	sts	0x0871, r25	; 0x800871 <pxCurrentTimerList+0x1>
    1566:	80 93 70 08 	sts	0x0870, r24	; 0x800870 <pxCurrentTimerList>
			pxOverflowTimerList = &xActiveTimerList2;
    156a:	82 e7       	ldi	r24, 0x72	; 114
    156c:	98 e0       	ldi	r25, 0x08	; 8
    156e:	90 93 6f 08 	sts	0x086F, r25	; 0x80086f <pxOverflowTimerList+0x1>
    1572:	80 93 6e 08 	sts	0x086E, r24	; 0x80086e <pxOverflowTimerList>

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
			}
			#else
			{
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    1576:	40 e0       	ldi	r20, 0x00	; 0
    1578:	65 e0       	ldi	r22, 0x05	; 5
    157a:	85 e0       	ldi	r24, 0x05	; 5
    157c:	0e 94 6d 03 	call	0x6da	; 0x6da <xQueueGenericCreate>
    1580:	90 93 6d 08 	sts	0x086D, r25	; 0x80086d <xTimerQueue+0x1>
    1584:	80 93 6c 08 	sts	0x086C, r24	; 0x80086c <xTimerQueue>
			}
			#endif

			#if ( configQUEUE_REGISTRY_SIZE > 0 )
			{
				if( xTimerQueue != NULL )
    1588:	00 97       	sbiw	r24, 0x00	; 0
    158a:	21 f0       	breq	.+8      	; 0x1594 <prvCheckForValidListAndQueue+0x58>
				{
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
    158c:	6b e0       	ldi	r22, 0x0B	; 11
    158e:	71 e0       	ldi	r23, 0x01	; 1
    1590:	0e 94 2a 05 	call	0xa54	; 0xa54 <vQueueAddToRegistry>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    1594:	0f 90       	pop	r0
    1596:	0f be       	out	0x3f, r0	; 63
    1598:	08 95       	ret

0000159a <xTimerCreateTimerTask>:
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
    159a:	ef 92       	push	r14
    159c:	ff 92       	push	r15
    159e:	0f 93       	push	r16

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
    15a0:	0e 94 9e 0a 	call	0x153c	; 0x153c <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
    15a4:	80 91 6c 08 	lds	r24, 0x086C	; 0x80086c <xTimerQueue>
    15a8:	90 91 6d 08 	lds	r25, 0x086D	; 0x80086d <xTimerQueue+0x1>
    15ac:	89 2b       	or	r24, r25
    15ae:	91 f0       	breq	.+36     	; 0x15d4 <xTimerCreateTimerTask+0x3a>
				xReturn = pdPASS;
			}
		}
		#else
		{
			xReturn = xTaskCreate(	prvTimerTask,
    15b0:	0f 2e       	mov	r0, r31
    15b2:	fa e6       	ldi	r31, 0x6A	; 106
    15b4:	ef 2e       	mov	r14, r31
    15b6:	f8 e0       	ldi	r31, 0x08	; 8
    15b8:	ff 2e       	mov	r15, r31
    15ba:	f0 2d       	mov	r31, r0
    15bc:	02 e0       	ldi	r16, 0x02	; 2
    15be:	20 e0       	ldi	r18, 0x00	; 0
    15c0:	30 e0       	ldi	r19, 0x00	; 0
    15c2:	45 e5       	ldi	r20, 0x55	; 85
    15c4:	50 e0       	ldi	r21, 0x00	; 0
    15c6:	60 e1       	ldi	r22, 0x10	; 16
    15c8:	71 e0       	ldi	r23, 0x01	; 1
    15ca:	89 ed       	ldi	r24, 0xD9	; 217
    15cc:	9b e0       	ldi	r25, 0x0B	; 11
    15ce:	0e 94 cb 05 	call	0xb96	; 0xb96 <xTaskCreate>
    15d2:	01 c0       	rjmp	.+2      	; 0x15d6 <xTimerCreateTimerTask+0x3c>
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
BaseType_t xReturn = pdFAIL;
    15d4:	80 e0       	ldi	r24, 0x00	; 0
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
	return xReturn;
}
    15d6:	0f 91       	pop	r16
    15d8:	ff 90       	pop	r15
    15da:	ef 90       	pop	r14
    15dc:	08 95       	ret

000015de <xTimerCreate>:
	TimerHandle_t xTimerCreate(	const char * const pcTimerName,
								const TickType_t xTimerPeriodInTicks,
								const UBaseType_t uxAutoReload,
								void * const pvTimerID,
								TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    15de:	9f 92       	push	r9
    15e0:	af 92       	push	r10
    15e2:	bf 92       	push	r11
    15e4:	cf 92       	push	r12
    15e6:	df 92       	push	r13
    15e8:	ef 92       	push	r14
    15ea:	ff 92       	push	r15
    15ec:	0f 93       	push	r16
    15ee:	1f 93       	push	r17
    15f0:	cf 93       	push	r28
    15f2:	df 93       	push	r29
    15f4:	5c 01       	movw	r10, r24
    15f6:	6b 01       	movw	r12, r22
    15f8:	94 2e       	mov	r9, r20
    15fa:	79 01       	movw	r14, r18
	Timer_t *pxNewTimer;

		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
    15fc:	83 e1       	ldi	r24, 0x13	; 19
    15fe:	90 e0       	ldi	r25, 0x00	; 0
    1600:	0e 94 e7 00 	call	0x1ce	; 0x1ce <pvPortMalloc>
    1604:	ec 01       	movw	r28, r24
									Timer_t *pxNewTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	if( pxNewTimer != NULL )
    1606:	89 2b       	or	r24, r25
    1608:	79 f0       	breq	.+30     	; 0x1628 <xTimerCreate+0x4a>
	{
		/* Ensure the infrastructure used by the timer service task has been
		created/initialised. */
		prvCheckForValidListAndQueue();
    160a:	0e 94 9e 0a 	call	0x153c	; 0x153c <prvCheckForValidListAndQueue>

		/* Initialise the timer structure members using the function
		parameters. */
		pxNewTimer->pcTimerName = pcTimerName;
    160e:	b9 82       	std	Y+1, r11	; 0x01
    1610:	a8 82       	st	Y, r10
		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    1612:	dd 86       	std	Y+13, r13	; 0x0d
    1614:	cc 86       	std	Y+12, r12	; 0x0c
		pxNewTimer->uxAutoReload = uxAutoReload;
    1616:	9e 86       	std	Y+14, r9	; 0x0e
		pxNewTimer->pvTimerID = pvTimerID;
    1618:	f8 8a       	std	Y+16, r15	; 0x10
    161a:	ef 86       	std	Y+15, r14	; 0x0f
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    161c:	1a 8b       	std	Y+18, r17	; 0x12
    161e:	09 8b       	std	Y+17, r16	; 0x11
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    1620:	ce 01       	movw	r24, r28
    1622:	02 96       	adiw	r24, 0x02	; 2
    1624:	0e 94 6b 00 	call	0xd6	; 0xd6 <vListInitialiseItem>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */
		}

		return pxNewTimer;
	}
    1628:	ce 01       	movw	r24, r28
    162a:	df 91       	pop	r29
    162c:	cf 91       	pop	r28
    162e:	1f 91       	pop	r17
    1630:	0f 91       	pop	r16
    1632:	ff 90       	pop	r15
    1634:	ef 90       	pop	r14
    1636:	df 90       	pop	r13
    1638:	cf 90       	pop	r12
    163a:	bf 90       	pop	r11
    163c:	af 90       	pop	r10
    163e:	9f 90       	pop	r9
    1640:	08 95       	ret

00001642 <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    1642:	0f 93       	push	r16
    1644:	1f 93       	push	r17
    1646:	cf 93       	push	r28
    1648:	df 93       	push	r29
    164a:	00 d0       	rcall	.+0      	; 0x164c <xTimerGenericCommand+0xa>
    164c:	00 d0       	rcall	.+0      	; 0x164e <xTimerGenericCommand+0xc>
    164e:	1f 92       	push	r1
    1650:	cd b7       	in	r28, 0x3d	; 61
    1652:	de b7       	in	r29, 0x3e	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    1654:	e0 91 6c 08 	lds	r30, 0x086C	; 0x80086c <xTimerQueue>
    1658:	f0 91 6d 08 	lds	r31, 0x086D	; 0x80086d <xTimerQueue+0x1>
    165c:	30 97       	sbiw	r30, 0x00	; 0
    165e:	71 f1       	breq	.+92     	; 0x16bc <xTimerGenericCommand+0x7a>
    1660:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    1662:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    1664:	5b 83       	std	Y+3, r21	; 0x03
    1666:	4a 83       	std	Y+2, r20	; 0x02
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    1668:	9d 83       	std	Y+5, r25	; 0x05
    166a:	8c 83       	std	Y+4, r24	; 0x04

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    166c:	66 30       	cpi	r22, 0x06	; 6
    166e:	ec f4       	brge	.+58     	; 0x16aa <xTimerGenericCommand+0x68>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    1670:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <xTaskGetSchedulerState>
    1674:	82 30       	cpi	r24, 0x02	; 2
    1676:	61 f4       	brne	.+24     	; 0x1690 <xTimerGenericCommand+0x4e>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    1678:	20 e0       	ldi	r18, 0x00	; 0
    167a:	a8 01       	movw	r20, r16
    167c:	be 01       	movw	r22, r28
    167e:	6f 5f       	subi	r22, 0xFF	; 255
    1680:	7f 4f       	sbci	r23, 0xFF	; 255
    1682:	80 91 6c 08 	lds	r24, 0x086C	; 0x80086c <xTimerQueue>
    1686:	90 91 6d 08 	lds	r25, 0x086D	; 0x80086d <xTimerQueue+0x1>
    168a:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
    168e:	17 c0       	rjmp	.+46     	; 0x16be <xTimerGenericCommand+0x7c>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    1690:	20 e0       	ldi	r18, 0x00	; 0
    1692:	40 e0       	ldi	r20, 0x00	; 0
    1694:	50 e0       	ldi	r21, 0x00	; 0
    1696:	be 01       	movw	r22, r28
    1698:	6f 5f       	subi	r22, 0xFF	; 255
    169a:	7f 4f       	sbci	r23, 0xFF	; 255
    169c:	80 91 6c 08 	lds	r24, 0x086C	; 0x80086c <xTimerQueue>
    16a0:	90 91 6d 08 	lds	r25, 0x086D	; 0x80086d <xTimerQueue+0x1>
    16a4:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
    16a8:	0a c0       	rjmp	.+20     	; 0x16be <xTimerGenericCommand+0x7c>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    16aa:	20 e0       	ldi	r18, 0x00	; 0
    16ac:	ad 01       	movw	r20, r26
    16ae:	be 01       	movw	r22, r28
    16b0:	6f 5f       	subi	r22, 0xFF	; 255
    16b2:	7f 4f       	sbci	r23, 0xFF	; 255
    16b4:	cf 01       	movw	r24, r30
    16b6:	0e 94 3b 04 	call	0x876	; 0x876 <xQueueGenericSendFromISR>
    16ba:	01 c0       	rjmp	.+2      	; 0x16be <xTimerGenericCommand+0x7c>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    16bc:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    16be:	0f 90       	pop	r0
    16c0:	0f 90       	pop	r0
    16c2:	0f 90       	pop	r0
    16c4:	0f 90       	pop	r0
    16c6:	0f 90       	pop	r0
    16c8:	df 91       	pop	r29
    16ca:	cf 91       	pop	r28
    16cc:	1f 91       	pop	r17
    16ce:	0f 91       	pop	r16
    16d0:	08 95       	ret

000016d2 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    16d2:	af 92       	push	r10
    16d4:	bf 92       	push	r11
    16d6:	cf 92       	push	r12
    16d8:	df 92       	push	r13
    16da:	ef 92       	push	r14
    16dc:	ff 92       	push	r15
    16de:	0f 93       	push	r16
    16e0:	1f 93       	push	r17
    16e2:	cf 93       	push	r28
    16e4:	df 93       	push	r29
    16e6:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    16e8:	0e 94 5b 07 	call	0xeb6	; 0xeb6 <xTaskGetTickCount>
    16ec:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    16ee:	80 91 68 08 	lds	r24, 0x0868	; 0x800868 <xLastTime.2351>
    16f2:	90 91 69 08 	lds	r25, 0x0869	; 0x800869 <xLastTime.2351+0x1>
    16f6:	e8 16       	cp	r14, r24
    16f8:	f9 06       	cpc	r15, r25
    16fa:	08 f0       	brcs	.+2      	; 0x16fe <prvSampleTimeNow+0x2c>
    16fc:	48 c0       	rjmp	.+144    	; 0x178e <prvSampleTimeNow+0xbc>
    16fe:	30 c0       	rjmp	.+96     	; 0x1760 <prvSampleTimeNow+0x8e>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1700:	05 80       	ldd	r0, Z+5	; 0x05
    1702:	f6 81       	ldd	r31, Z+6	; 0x06
    1704:	e0 2d       	mov	r30, r0
    1706:	a0 80       	ld	r10, Z
    1708:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    170a:	c6 81       	ldd	r28, Z+6	; 0x06
    170c:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    170e:	8e 01       	movw	r16, r28
    1710:	0e 5f       	subi	r16, 0xFE	; 254
    1712:	1f 4f       	sbci	r17, 0xFF	; 255
    1714:	c8 01       	movw	r24, r16
    1716:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    171a:	e9 89       	ldd	r30, Y+17	; 0x11
    171c:	fa 89       	ldd	r31, Y+18	; 0x12
    171e:	ce 01       	movw	r24, r28
    1720:	09 95       	icall

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1722:	8e 85       	ldd	r24, Y+14	; 0x0e
    1724:	81 30       	cpi	r24, 0x01	; 1
    1726:	e1 f4       	brne	.+56     	; 0x1760 <prvSampleTimeNow+0x8e>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    1728:	8c 85       	ldd	r24, Y+12	; 0x0c
    172a:	9d 85       	ldd	r25, Y+13	; 0x0d
    172c:	8a 0d       	add	r24, r10
    172e:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    1730:	a8 16       	cp	r10, r24
    1732:	b9 06       	cpc	r11, r25
    1734:	60 f4       	brcc	.+24     	; 0x174e <prvSampleTimeNow+0x7c>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    1736:	9b 83       	std	Y+3, r25	; 0x03
    1738:	8a 83       	std	Y+2, r24	; 0x02
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    173a:	d9 87       	std	Y+9, r29	; 0x09
    173c:	c8 87       	std	Y+8, r28	; 0x08
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    173e:	b8 01       	movw	r22, r16
    1740:	80 91 70 08 	lds	r24, 0x0870	; 0x800870 <pxCurrentTimerList>
    1744:	90 91 71 08 	lds	r25, 0x0871	; 0x800871 <pxCurrentTimerList+0x1>
    1748:	0e 94 90 00 	call	0x120	; 0x120 <vListInsert>
    174c:	09 c0       	rjmp	.+18     	; 0x1760 <prvSampleTimeNow+0x8e>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    174e:	00 e0       	ldi	r16, 0x00	; 0
    1750:	10 e0       	ldi	r17, 0x00	; 0
    1752:	20 e0       	ldi	r18, 0x00	; 0
    1754:	30 e0       	ldi	r19, 0x00	; 0
    1756:	a5 01       	movw	r20, r10
    1758:	60 e0       	ldi	r22, 0x00	; 0
    175a:	ce 01       	movw	r24, r28
    175c:	0e 94 21 0b 	call	0x1642	; 0x1642 <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    1760:	e0 91 70 08 	lds	r30, 0x0870	; 0x800870 <pxCurrentTimerList>
    1764:	f0 91 71 08 	lds	r31, 0x0871	; 0x800871 <pxCurrentTimerList+0x1>
    1768:	80 81       	ld	r24, Z
    176a:	81 11       	cpse	r24, r1
    176c:	c9 cf       	rjmp	.-110    	; 0x1700 <prvSampleTimeNow+0x2e>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    176e:	80 91 6e 08 	lds	r24, 0x086E	; 0x80086e <pxOverflowTimerList>
    1772:	90 91 6f 08 	lds	r25, 0x086F	; 0x80086f <pxOverflowTimerList+0x1>
    1776:	90 93 71 08 	sts	0x0871, r25	; 0x800871 <pxCurrentTimerList+0x1>
    177a:	80 93 70 08 	sts	0x0870, r24	; 0x800870 <pxCurrentTimerList>
	pxOverflowTimerList = pxTemp;
    177e:	f0 93 6f 08 	sts	0x086F, r31	; 0x80086f <pxOverflowTimerList+0x1>
    1782:	e0 93 6e 08 	sts	0x086E, r30	; 0x80086e <pxOverflowTimerList>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    1786:	81 e0       	ldi	r24, 0x01	; 1
    1788:	f6 01       	movw	r30, r12
    178a:	80 83       	st	Z, r24
    178c:	02 c0       	rjmp	.+4      	; 0x1792 <prvSampleTimeNow+0xc0>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    178e:	f6 01       	movw	r30, r12
    1790:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    1792:	f0 92 69 08 	sts	0x0869, r15	; 0x800869 <xLastTime.2351+0x1>
    1796:	e0 92 68 08 	sts	0x0868, r14	; 0x800868 <xLastTime.2351>

	return xTimeNow;
}
    179a:	c7 01       	movw	r24, r14
    179c:	df 91       	pop	r29
    179e:	cf 91       	pop	r28
    17a0:	1f 91       	pop	r17
    17a2:	0f 91       	pop	r16
    17a4:	ff 90       	pop	r15
    17a6:	ef 90       	pop	r14
    17a8:	df 90       	pop	r13
    17aa:	cf 90       	pop	r12
    17ac:	bf 90       	pop	r11
    17ae:	af 90       	pop	r10
    17b0:	08 95       	ret

000017b2 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    17b2:	cf 93       	push	r28
    17b4:	df 93       	push	r29
    17b6:	00 d0       	rcall	.+0      	; 0x17b8 <prvTimerTask+0x6>
    17b8:	00 d0       	rcall	.+0      	; 0x17ba <prvTimerTask+0x8>
    17ba:	00 d0       	rcall	.+0      	; 0x17bc <prvTimerTask+0xa>
    17bc:	cd b7       	in	r28, 0x3d	; 61
    17be:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    17c0:	ce 01       	movw	r24, r28
    17c2:	01 96       	adiw	r24, 0x01	; 1
    17c4:	4c 01       	movw	r8, r24
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    17c6:	44 24       	eor	r4, r4
    17c8:	43 94       	inc	r4
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    17ca:	d1 2c       	mov	r13, r1
    17cc:	e1 2c       	mov	r14, r1
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    17ce:	f1 2c       	mov	r15, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    17d0:	58 2e       	mov	r5, r24
    17d2:	c9 2c       	mov	r12, r9
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    17d4:	e0 91 70 08 	lds	r30, 0x0870	; 0x800870 <pxCurrentTimerList>
    17d8:	f0 91 71 08 	lds	r31, 0x0871	; 0x800871 <pxCurrentTimerList+0x1>
	if( *pxListWasEmpty == pdFALSE )
    17dc:	80 81       	ld	r24, Z
    17de:	88 23       	and	r24, r24
    17e0:	09 f4       	brne	.+2      	; 0x17e4 <prvTimerTask+0x32>
    17e2:	c3 c0       	rjmp	.+390    	; 0x196a <prvTimerTask+0x1b8>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    17e4:	05 80       	ldd	r0, Z+5	; 0x05
    17e6:	f6 81       	ldd	r31, Z+6	; 0x06
    17e8:	e0 2d       	mov	r30, r0
    17ea:	a0 80       	ld	r10, Z
    17ec:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    17ee:	0e 94 55 07 	call	0xeaa	; 0xeaa <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    17f2:	c4 01       	movw	r24, r8
    17f4:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <prvSampleTimeNow>
    17f8:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    17fa:	89 81       	ldd	r24, Y+1	; 0x01
    17fc:	81 11       	cpse	r24, r1
    17fe:	47 c0       	rjmp	.+142    	; 0x188e <prvTimerTask+0xdc>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    1800:	0a 15       	cp	r16, r10
    1802:	1b 05       	cpc	r17, r11
    1804:	98 f1       	brcs	.+102    	; 0x186c <prvTimerTask+0xba>
			{
				( void ) xTaskResumeAll();
    1806:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    180a:	e0 91 70 08 	lds	r30, 0x0870	; 0x800870 <pxCurrentTimerList>
    180e:	f0 91 71 08 	lds	r31, 0x0871	; 0x800871 <pxCurrentTimerList+0x1>
    1812:	05 80       	ldd	r0, Z+5	; 0x05
    1814:	f6 81       	ldd	r31, Z+6	; 0x06
    1816:	e0 2d       	mov	r30, r0
    1818:	66 80       	ldd	r6, Z+6	; 0x06
    181a:	77 80       	ldd	r7, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    181c:	c3 01       	movw	r24, r6
    181e:	02 96       	adiw	r24, 0x02	; 2
    1820:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1824:	d3 01       	movw	r26, r6
    1826:	1e 96       	adiw	r26, 0x0e	; 14
    1828:	8c 91       	ld	r24, X
    182a:	1e 97       	sbiw	r26, 0x0e	; 14
    182c:	81 30       	cpi	r24, 0x01	; 1
    182e:	b1 f4       	brne	.+44     	; 0x185c <prvTimerTask+0xaa>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    1830:	1c 96       	adiw	r26, 0x0c	; 12
    1832:	6d 91       	ld	r22, X+
    1834:	7c 91       	ld	r23, X
    1836:	1d 97       	sbiw	r26, 0x0d	; 13
    1838:	6a 0d       	add	r22, r10
    183a:	7b 1d       	adc	r23, r11
    183c:	95 01       	movw	r18, r10
    183e:	a8 01       	movw	r20, r16
    1840:	c3 01       	movw	r24, r6
    1842:	0e 94 6f 0a 	call	0x14de	; 0x14de <prvInsertTimerInActiveList>
    1846:	88 23       	and	r24, r24
    1848:	49 f0       	breq	.+18     	; 0x185c <prvTimerTask+0xaa>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    184a:	0d 2d       	mov	r16, r13
    184c:	1e 2d       	mov	r17, r14
    184e:	2d 2d       	mov	r18, r13
    1850:	3e 2d       	mov	r19, r14
    1852:	a5 01       	movw	r20, r10
    1854:	6f 2d       	mov	r22, r15
    1856:	c3 01       	movw	r24, r6
    1858:	0e 94 21 0b 	call	0x1642	; 0x1642 <xTimerGenericCommand>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    185c:	d3 01       	movw	r26, r6
    185e:	51 96       	adiw	r26, 0x11	; 17
    1860:	ed 91       	ld	r30, X+
    1862:	fc 91       	ld	r31, X
    1864:	52 97       	sbiw	r26, 0x12	; 18
    1866:	c3 01       	movw	r24, r6
    1868:	09 95       	icall
    186a:	71 c0       	rjmp	.+226    	; 0x194e <prvTimerTask+0x19c>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    186c:	4f 2d       	mov	r20, r15
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    186e:	b5 01       	movw	r22, r10
    1870:	60 1b       	sub	r22, r16
    1872:	71 0b       	sbc	r23, r17
    1874:	80 91 6c 08 	lds	r24, 0x086C	; 0x80086c <xTimerQueue>
    1878:	90 91 6d 08 	lds	r25, 0x086D	; 0x80086d <xTimerQueue+0x1>
    187c:	0e 94 37 05 	call	0xa6e	; 0xa6e <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    1880:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
    1884:	81 11       	cpse	r24, r1
    1886:	63 c0       	rjmp	.+198    	; 0x194e <prvTimerTask+0x19c>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    1888:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
    188c:	60 c0       	rjmp	.+192    	; 0x194e <prvTimerTask+0x19c>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    188e:	0e 94 20 08 	call	0x1040	; 0x1040 <xTaskResumeAll>
    1892:	5d c0       	rjmp	.+186    	; 0x194e <prvTimerTask+0x19c>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    1894:	89 81       	ldd	r24, Y+1	; 0x01
    1896:	88 23       	and	r24, r24
    1898:	0c f4       	brge	.+2      	; 0x189c <prvTimerTask+0xea>
    189a:	59 c0       	rjmp	.+178    	; 0x194e <prvTimerTask+0x19c>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    189c:	ac 80       	ldd	r10, Y+4	; 0x04
    189e:	bd 80       	ldd	r11, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    18a0:	f5 01       	movw	r30, r10
    18a2:	82 85       	ldd	r24, Z+10	; 0x0a
    18a4:	93 85       	ldd	r25, Z+11	; 0x0b
    18a6:	89 2b       	or	r24, r25
    18a8:	21 f0       	breq	.+8      	; 0x18b2 <prvTimerTask+0x100>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    18aa:	c5 01       	movw	r24, r10
    18ac:	02 96       	adiw	r24, 0x02	; 2
    18ae:	0e 94 c1 00 	call	0x182	; 0x182 <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    18b2:	ce 01       	movw	r24, r28
    18b4:	06 96       	adiw	r24, 0x06	; 6
    18b6:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <prvSampleTimeNow>

			switch( xMessage.xMessageID )
    18ba:	e9 81       	ldd	r30, Y+1	; 0x01
    18bc:	0e 2f       	mov	r16, r30
    18be:	ee 0f       	add	r30, r30
    18c0:	11 0b       	sbc	r17, r17
    18c2:	22 0b       	sbc	r18, r18
    18c4:	33 0b       	sbc	r19, r19
    18c6:	0a 30       	cpi	r16, 0x0A	; 10
    18c8:	11 05       	cpc	r17, r1
    18ca:	08 f0       	brcs	.+2      	; 0x18ce <prvTimerTask+0x11c>
    18cc:	40 c0       	rjmp	.+128    	; 0x194e <prvTimerTask+0x19c>
    18ce:	f8 01       	movw	r30, r16
    18d0:	ec 5c       	subi	r30, 0xCC	; 204
    18d2:	ff 4f       	sbci	r31, 0xFF	; 255
    18d4:	0c 94 1f 14 	jmp	0x283e	; 0x283e <__tablejump2__>
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    18d8:	2a 81       	ldd	r18, Y+2	; 0x02
    18da:	3b 81       	ldd	r19, Y+3	; 0x03
    18dc:	d5 01       	movw	r26, r10
    18de:	1c 96       	adiw	r26, 0x0c	; 12
    18e0:	6d 91       	ld	r22, X+
    18e2:	7c 91       	ld	r23, X
    18e4:	1d 97       	sbiw	r26, 0x0d	; 13
    18e6:	62 0f       	add	r22, r18
    18e8:	73 1f       	adc	r23, r19
    18ea:	ac 01       	movw	r20, r24
    18ec:	c5 01       	movw	r24, r10
    18ee:	0e 94 6f 0a 	call	0x14de	; 0x14de <prvInsertTimerInActiveList>
    18f2:	88 23       	and	r24, r24
    18f4:	61 f1       	breq	.+88     	; 0x194e <prvTimerTask+0x19c>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    18f6:	d5 01       	movw	r26, r10
    18f8:	51 96       	adiw	r26, 0x11	; 17
    18fa:	ed 91       	ld	r30, X+
    18fc:	fc 91       	ld	r31, X
    18fe:	52 97       	sbiw	r26, 0x12	; 18
    1900:	c5 01       	movw	r24, r10
    1902:	09 95       	icall
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1904:	f5 01       	movw	r30, r10
    1906:	86 85       	ldd	r24, Z+14	; 0x0e
    1908:	81 30       	cpi	r24, 0x01	; 1
    190a:	09 f5       	brne	.+66     	; 0x194e <prvTimerTask+0x19c>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    190c:	4a 81       	ldd	r20, Y+2	; 0x02
    190e:	5b 81       	ldd	r21, Y+3	; 0x03
    1910:	84 85       	ldd	r24, Z+12	; 0x0c
    1912:	95 85       	ldd	r25, Z+13	; 0x0d
    1914:	48 0f       	add	r20, r24
    1916:	59 1f       	adc	r21, r25
    1918:	0d 2d       	mov	r16, r13
    191a:	1e 2d       	mov	r17, r14
    191c:	2d 2d       	mov	r18, r13
    191e:	3e 2d       	mov	r19, r14
    1920:	6f 2d       	mov	r22, r15
    1922:	c5 01       	movw	r24, r10
    1924:	0e 94 21 0b 	call	0x1642	; 0x1642 <xTimerGenericCommand>
    1928:	12 c0       	rjmp	.+36     	; 0x194e <prvTimerTask+0x19c>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    192a:	6a 81       	ldd	r22, Y+2	; 0x02
    192c:	7b 81       	ldd	r23, Y+3	; 0x03
    192e:	d5 01       	movw	r26, r10
    1930:	1d 96       	adiw	r26, 0x0d	; 13
    1932:	7c 93       	st	X, r23
    1934:	6e 93       	st	-X, r22
    1936:	1c 97       	sbiw	r26, 0x0c	; 12
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    1938:	68 0f       	add	r22, r24
    193a:	79 1f       	adc	r23, r25
    193c:	9c 01       	movw	r18, r24
    193e:	ac 01       	movw	r20, r24
    1940:	c5 01       	movw	r24, r10
    1942:	0e 94 6f 0a 	call	0x14de	; 0x14de <prvInsertTimerInActiveList>
    1946:	03 c0       	rjmp	.+6      	; 0x194e <prvTimerTask+0x19c>
					allocated. */
					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
					{
						/* The timer can only have been allocated dynamically -
						free it again. */
						vPortFree( pxTimer );
    1948:	c5 01       	movw	r24, r10
    194a:	0e 94 1c 01 	call	0x238	; 0x238 <vPortFree>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    194e:	2f 2d       	mov	r18, r15
    1950:	4d 2d       	mov	r20, r13
    1952:	5e 2d       	mov	r21, r14
    1954:	65 2d       	mov	r22, r5
    1956:	7c 2d       	mov	r23, r12
    1958:	80 91 6c 08 	lds	r24, 0x086C	; 0x80086c <xTimerQueue>
    195c:	90 91 6d 08 	lds	r25, 0x086D	; 0x80086d <xTimerQueue+0x1>
    1960:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    1964:	81 11       	cpse	r24, r1
    1966:	96 cf       	rjmp	.-212    	; 0x1894 <prvTimerTask+0xe2>
    1968:	35 cf       	rjmp	.-406    	; 0x17d4 <prvTimerTask+0x22>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    196a:	0e 94 55 07 	call	0xeaa	; 0xeaa <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    196e:	c4 01       	movw	r24, r8
    1970:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <prvSampleTimeNow>
    1974:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    1976:	89 81       	ldd	r24, Y+1	; 0x01
    1978:	81 11       	cpse	r24, r1
    197a:	89 cf       	rjmp	.-238    	; 0x188e <prvTimerTask+0xdc>
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    197c:	e0 91 6e 08 	lds	r30, 0x086E	; 0x80086e <pxOverflowTimerList>
    1980:	f0 91 6f 08 	lds	r31, 0x086F	; 0x80086f <pxOverflowTimerList+0x1>
    1984:	44 2d       	mov	r20, r4
    1986:	80 81       	ld	r24, Z
    1988:	81 11       	cpse	r24, r1
    198a:	4f 2d       	mov	r20, r15
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    198c:	ad 2c       	mov	r10, r13
    198e:	be 2c       	mov	r11, r14
    1990:	6e cf       	rjmp	.-292    	; 0x186e <prvTimerTask+0xbc>

00001992 <buzzerToggle>:
			TCCR0A &= (~(1 << 1 | 1 << 7 | 1 << 8));
			TCCR0B &= (~(1 << 1 | 1 << 2));
		}
		else { //Esegui la PWM
		
		OCR0A = 127;
    1992:	3f e7       	ldi	r19, 0x7F	; 127
		TCCR0A = 0b11000001;
    1994:	21 ec       	ldi	r18, 0xC1	; 193
		TCCR0B = 0b00000011;
    1996:	93 e0       	ldi	r25, 0x03	; 3

static void buzzerToggle() {
	for (;;){
		
		//Se il buzzer non  impostato dall'esterno o il sistema non  in stato di allarme, il buzzer deve essere spento.
		if (stateBuzzer == 0){
    1998:	80 91 88 08 	lds	r24, 0x0888	; 0x800888 <stateBuzzer>
    199c:	81 11       	cpse	r24, r1
    199e:	07 c0       	rjmp	.+14     	; 0x19ae <buzzerToggle+0x1c>
			
			TCCR0A &= (~(1 << 1 | 1 << 7 | 1 << 8));
    19a0:	84 b5       	in	r24, 0x24	; 36
    19a2:	8d 77       	andi	r24, 0x7D	; 125
    19a4:	84 bd       	out	0x24, r24	; 36
			TCCR0B &= (~(1 << 1 | 1 << 2));
    19a6:	85 b5       	in	r24, 0x25	; 37
    19a8:	89 7f       	andi	r24, 0xF9	; 249
    19aa:	85 bd       	out	0x25, r24	; 37
    19ac:	f5 cf       	rjmp	.-22     	; 0x1998 <buzzerToggle+0x6>
		}
		else { //Esegui la PWM
		
		OCR0A = 127;
    19ae:	37 bd       	out	0x27, r19	; 39
		TCCR0A = 0b11000001;
    19b0:	24 bd       	out	0x24, r18	; 36
		TCCR0B = 0b00000011;
    19b2:	95 bd       	out	0x25, r25	; 37
    19b4:	f1 cf       	rjmp	.-30     	; 0x1998 <buzzerToggle+0x6>

000019b6 <fanToggle>:
	}
}

static void fanToggle() {
		//Se il buzzer non  impostato dall'esterno o il sistema non  in stato di allarme, il buzzer deve essere spento.
		if (stateFan == 0){
    19b6:	80 91 a6 08 	lds	r24, 0x08A6	; 0x8008a6 <stateFan>
    19ba:	81 11       	cpse	r24, r1
    19bc:	02 c0       	rjmp	.+4      	; 0x19c2 <fanToggle+0xc>
			PORTB &= (~(1 << PB3));
    19be:	2b 98       	cbi	0x05, 3	; 5
    19c0:	08 95       	ret
		}
		else {
			
			PORTB |= (1 << PB3); //ENABLE FAN
    19c2:	2b 9a       	sbi	0x05, 3	; 5
			
			PORTB |= (1 << PB2);
    19c4:	2a 9a       	sbi	0x05, 2	; 5
			PORTB &= (~(1<< PB4));
    19c6:	2c 98       	cbi	0x05, 4	; 5
    19c8:	08 95       	ret

000019ca <UART_sendString>:
	// Imposta il formato dei dati: 8 bit di dati, 1 bit di stop
	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);
}

static void UART_sendString(const char* data)
{
    19ca:	cf 93       	push	r28
    19cc:	df 93       	push	r29
	// Invia carattere per carattere fino a quando non si raggiunge il terminatore null
	while (*data != '\0')
    19ce:	fc 01       	movw	r30, r24
    19d0:	20 81       	ld	r18, Z
    19d2:	22 23       	and	r18, r18
    19d4:	69 f0       	breq	.+26     	; 0x19f0 <UART_sendString+0x26>
    19d6:	dc 01       	movw	r26, r24
    19d8:	11 96       	adiw	r26, 0x01	; 1
}

static void UART_sendChar(char data)
{
	// Attendi che il buffer di trasmissione sia vuoto
	while (!(UCSR0A & (1 << UDRE0)));
    19da:	e0 ec       	ldi	r30, 0xC0	; 192
    19dc:	f0 e0       	ldi	r31, 0x00	; 0
	
	// Carica il dato nel buffer di trasmissione
	UDR0 = data;
    19de:	c6 ec       	ldi	r28, 0xC6	; 198
    19e0:	d0 e0       	ldi	r29, 0x00	; 0
}

static void UART_sendChar(char data)
{
	// Attendi che il buffer di trasmissione sia vuoto
	while (!(UCSR0A & (1 << UDRE0)));
    19e2:	90 81       	ld	r25, Z
    19e4:	95 ff       	sbrs	r25, 5
    19e6:	fd cf       	rjmp	.-6      	; 0x19e2 <UART_sendString+0x18>
	
	// Carica il dato nel buffer di trasmissione
	UDR0 = data;
    19e8:	28 83       	st	Y, r18
}

static void UART_sendString(const char* data)
{
	// Invia carattere per carattere fino a quando non si raggiunge il terminatore null
	while (*data != '\0')
    19ea:	2d 91       	ld	r18, X+
    19ec:	21 11       	cpse	r18, r1
    19ee:	f9 cf       	rjmp	.-14     	; 0x19e2 <UART_sendString+0x18>
	{
		UART_sendChar(*data);
		data++;
	}
}
    19f0:	df 91       	pop	r29
    19f2:	cf 91       	pop	r28
    19f4:	08 95       	ret

000019f6 <alarmON>:

/* ----------------------------------- FUNCTION DEFINITIONS -------------------------------------*/

static void alarmON() {
				
		UART_sendString("{\"actuator\":\"alarm\",\"value\":\"on\"}\n");
    19f6:	88 e1       	ldi	r24, 0x18	; 24
    19f8:	91 e0       	ldi	r25, 0x01	; 1
    19fa:	0e 94 e5 0c 	call	0x19ca	; 0x19ca <UART_sendString>
		alarmState = ON;
    19fe:	10 92 a5 08 	sts	0x08A5, r1	; 0x8008a5 <alarmState>
		stateBuzzer = ON;
    1a02:	10 92 88 08 	sts	0x0888, r1	; 0x800888 <stateBuzzer>
		stateFan = ON;
    1a06:	10 92 a6 08 	sts	0x08A6, r1	; 0x8008a6 <stateFan>
		PORTD |= 1<<PD2;
    1a0a:	5a 9a       	sbi	0x0b, 2	; 11
		buzzerToggle();
    1a0c:	0e 94 c9 0c 	call	0x1992	; 0x1992 <buzzerToggle>

00001a10 <ADC_read>:
	
}

static float ADC_read(){

	ADCSRA |= (1<<ADSC); //Start conversion
    1a10:	ea e7       	ldi	r30, 0x7A	; 122
    1a12:	f0 e0       	ldi	r31, 0x00	; 0
    1a14:	80 81       	ld	r24, Z
    1a16:	80 64       	ori	r24, 0x40	; 64
    1a18:	80 83       	st	Z, r24
	while ((ADCSRA&(1<<ADIF)) ==0); //wait for end of conversion
    1a1a:	80 81       	ld	r24, Z
    1a1c:	84 ff       	sbrs	r24, 4
    1a1e:	fd cf       	rjmp	.-6      	; 0x1a1a <ADC_read+0xa>
	ADCSRA |= (1<<ADIF); //clear the ADIF flag
    1a20:	ea e7       	ldi	r30, 0x7A	; 122
    1a22:	f0 e0       	ldi	r31, 0x00	; 0
    1a24:	80 81       	ld	r24, Z
    1a26:	80 61       	ori	r24, 0x10	; 16
    1a28:	80 83       	st	Z, r24

	return (ADCL+(ADCH<<8));
    1a2a:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
    1a2e:	60 91 79 00 	lds	r22, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
    1a32:	70 e0       	ldi	r23, 0x00	; 0
    1a34:	76 2f       	mov	r23, r22
    1a36:	66 27       	eor	r22, r22
    1a38:	68 0f       	add	r22, r24
    1a3a:	71 1d       	adc	r23, r1
    1a3c:	07 2e       	mov	r0, r23
    1a3e:	00 0c       	add	r0, r0
    1a40:	88 0b       	sbc	r24, r24
    1a42:	99 0b       	sbc	r25, r25
    1a44:	0e 94 fd 12 	call	0x25fa	; 0x25fa <__floatsisf>
}
    1a48:	08 95       	ret

00001a4a <serialFromISRTask>:
	LCD_sendData(d3+ASCII_OFFSET);

	return generateArrayAir(d1, d2, d3);
}

void serialFromISRTask (void *parameters) {
    1a4a:	cf 93       	push	r28
    1a4c:	df 93       	push	r29
    1a4e:	00 d0       	rcall	.+0      	; 0x1a50 <serialFromISRTask+0x6>
    1a50:	cd b7       	in	r28, 0x3d	; 61
    1a52:	de b7       	in	r29, 0x3e	; 62
			stateBuzzer = 0;
			buzzerToggle();
			break;
			case FAN_ON:
			UART_sendString("{\"actuator\":\"fan\",\"value\":\"on\"}\n");
			stateFan = 1;
    1a54:	11 e0       	ldi	r17, 0x01	; 1
	char *pcString; //where the queue receive the msg.
	uint8_t commandReceived;
	
	for( ;; ) {
		/* Block on the queue to wait for data to arrive. */
		xQueueReceive( xCharQueue, &pcString, portMAX_DELAY );
    1a56:	20 e0       	ldi	r18, 0x00	; 0
    1a58:	4f ef       	ldi	r20, 0xFF	; 255
    1a5a:	5f ef       	ldi	r21, 0xFF	; 255
    1a5c:	be 01       	movw	r22, r28
    1a5e:	6f 5f       	subi	r22, 0xFF	; 255
    1a60:	7f 4f       	sbci	r23, 0xFF	; 255
    1a62:	80 91 9f 08 	lds	r24, 0x089F	; 0x80089f <xCharQueue>
    1a66:	90 91 a0 08 	lds	r25, 0x08A0	; 0x8008a0 <xCharQueue+0x1>
    1a6a:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
		
		commandReceived = pcString - ASCII_OFFSET; //Gives the number from exadecimal to Ascii
		
		switch (commandReceived) {
    1a6e:	89 81       	ldd	r24, Y+1	; 0x01
    1a70:	9a 81       	ldd	r25, Y+2	; 0x02
    1a72:	c0 97       	sbiw	r24, 0x30	; 48
    1a74:	99 27       	eor	r25, r25
    1a76:	82 30       	cpi	r24, 0x02	; 2
    1a78:	91 05       	cpc	r25, r1
    1a7a:	f9 f0       	breq	.+62     	; 0x1aba <serialFromISRTask+0x70>
    1a7c:	2c f4       	brge	.+10     	; 0x1a88 <serialFromISRTask+0x3e>
    1a7e:	00 97       	sbiw	r24, 0x00	; 0
    1a80:	51 f0       	breq	.+20     	; 0x1a96 <serialFromISRTask+0x4c>
    1a82:	01 97       	sbiw	r24, 0x01	; 1
    1a84:	51 f0       	breq	.+20     	; 0x1a9a <serialFromISRTask+0x50>
    1a86:	e7 cf       	rjmp	.-50     	; 0x1a56 <serialFromISRTask+0xc>
    1a88:	84 30       	cpi	r24, 0x04	; 4
    1a8a:	91 05       	cpc	r25, r1
    1a8c:	39 f1       	breq	.+78     	; 0x1adc <serialFromISRTask+0x92>
    1a8e:	f4 f0       	brlt	.+60     	; 0x1acc <serialFromISRTask+0x82>
    1a90:	05 97       	sbiw	r24, 0x05	; 5
    1a92:	69 f1       	breq	.+90     	; 0x1aee <serialFromISRTask+0xa4>
    1a94:	e0 cf       	rjmp	.-64     	; 0x1a56 <serialFromISRTask+0xc>
			case ALARM_ON:
			alarmON();
    1a96:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <alarmON>
		fanToggle();
}

static void alarmOFF() {
		
		UART_sendString("{\"actuator\":\"alarm\",\"value\":\"off\"}\n");
    1a9a:	8b e3       	ldi	r24, 0x3B	; 59
    1a9c:	91 e0       	ldi	r25, 0x01	; 1
    1a9e:	0e 94 e5 0c 	call	0x19ca	; 0x19ca <UART_sendString>
		alarmState = OFF;
    1aa2:	81 e0       	ldi	r24, 0x01	; 1
    1aa4:	80 93 a5 08 	sts	0x08A5, r24	; 0x8008a5 <alarmState>
		PORTD &= (~(1<< PD2));
    1aa8:	5a 98       	cbi	0x0b, 2	; 11
		
		stateBuzzer = OFF;
    1aaa:	80 93 88 08 	sts	0x0888, r24	; 0x800888 <stateBuzzer>
		stateFan = OFF;
    1aae:	80 93 a6 08 	sts	0x08A6, r24	; 0x8008a6 <stateFan>
		fanToggle();
    1ab2:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <fanToggle>
		buzzerToggle();
    1ab6:	0e 94 c9 0c 	call	0x1992	; 0x1992 <buzzerToggle>
			break;//causa l'uscita immediata dallo switch
			case ALARM_OFF:
			alarmOFF();
			break;
			case BUZZER_ON:
			UART_sendString("{\"actuator\":\"buzzer\",\"value\":\"on\"}\n");
    1aba:	8f e5       	ldi	r24, 0x5F	; 95
    1abc:	91 e0       	ldi	r25, 0x01	; 1
    1abe:	0e 94 e5 0c 	call	0x19ca	; 0x19ca <UART_sendString>
			stateBuzzer = 1;
    1ac2:	81 e0       	ldi	r24, 0x01	; 1
    1ac4:	80 93 88 08 	sts	0x0888, r24	; 0x800888 <stateBuzzer>
			buzzerToggle();
    1ac8:	0e 94 c9 0c 	call	0x1992	; 0x1992 <buzzerToggle>
			break;
			case BUZZER_OFF:
			UART_sendString("{\"actuator\":\"buzzer\",\"value\":\"off\"}\n");
    1acc:	83 e8       	ldi	r24, 0x83	; 131
    1ace:	91 e0       	ldi	r25, 0x01	; 1
    1ad0:	0e 94 e5 0c 	call	0x19ca	; 0x19ca <UART_sendString>
			stateBuzzer = 0;
    1ad4:	10 92 88 08 	sts	0x0888, r1	; 0x800888 <stateBuzzer>
			buzzerToggle();
    1ad8:	0e 94 c9 0c 	call	0x1992	; 0x1992 <buzzerToggle>
			break;
			case FAN_ON:
			UART_sendString("{\"actuator\":\"fan\",\"value\":\"on\"}\n");
    1adc:	88 ea       	ldi	r24, 0xA8	; 168
    1ade:	91 e0       	ldi	r25, 0x01	; 1
    1ae0:	0e 94 e5 0c 	call	0x19ca	; 0x19ca <UART_sendString>
			stateFan = 1;
    1ae4:	10 93 a6 08 	sts	0x08A6, r17	; 0x8008a6 <stateFan>
			fanToggle();
    1ae8:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <fanToggle>
			break;
    1aec:	b4 cf       	rjmp	.-152    	; 0x1a56 <serialFromISRTask+0xc>
			case FAN_OFF:
			UART_sendString("{\"actuator\":\"fan\",\"value\":\"off\"}\n");
    1aee:	89 ec       	ldi	r24, 0xC9	; 201
    1af0:	91 e0       	ldi	r25, 0x01	; 1
    1af2:	0e 94 e5 0c 	call	0x19ca	; 0x19ca <UART_sendString>
			stateFan = 0;
    1af6:	10 92 a6 08 	sts	0x08A6, r1	; 0x8008a6 <stateFan>
			fanToggle();
    1afa:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <fanToggle>
			break;
    1afe:	ab cf       	rjmp	.-170    	; 0x1a56 <serialFromISRTask+0xc>

00001b00 <temperatureReadTask>:
		}
		
	}
}

void temperatureReadTask(void* parameter) {
    1b00:	cf 93       	push	r28
    1b02:	df 93       	push	r29
    1b04:	00 d0       	rcall	.+0      	; 0x1b06 <temperatureReadTask+0x6>
    1b06:	00 d0       	rcall	.+0      	; 0x1b08 <temperatureReadTask+0x8>
    1b08:	cd b7       	in	r28, 0x3d	; 61
    1b0a:	de b7       	in	r29, 0x3e	; 62
	
}

static void ADC_setupTemp(void){
	DDRC&=~(1<<0);
	ADCSRA = 0x87; //make ADC enagle and select ck/128
    1b0c:	0f 2e       	mov	r0, r31
    1b0e:	fa e7       	ldi	r31, 0x7A	; 122
    1b10:	ef 2e       	mov	r14, r31
    1b12:	f1 2c       	mov	r15, r1
    1b14:	f0 2d       	mov	r31, r0
    1b16:	0f 2e       	mov	r0, r31
    1b18:	f7 e8       	ldi	r31, 0x87	; 135
    1b1a:	cf 2e       	mov	r12, r31
    1b1c:	f0 2d       	mov	r31, r0
	ADMUX = 0b11000000; //adc0
    1b1e:	0c e7       	ldi	r16, 0x7C	; 124
    1b20:	10 e0       	ldi	r17, 0x00	; 0
    1b22:	0f 2e       	mov	r0, r31
    1b24:	f0 ec       	ldi	r31, 0xC0	; 192
    1b26:	df 2e       	mov	r13, r31
    1b28:	f0 2d       	mov	r31, r0
	float threshold = 30.00;
	float temperature;
	
	for (;;){
		
		vTaskSuspend(NULL);
    1b2a:	80 e0       	ldi	r24, 0x00	; 0
    1b2c:	90 e0       	ldi	r25, 0x00	; 0
    1b2e:	0e 94 58 09 	call	0x12b0	; 0x12b0 <vTaskSuspend>
		
		if( xSemaphoreADC != NULL )
    1b32:	80 91 99 08 	lds	r24, 0x0899	; 0x800899 <xSemaphoreADC>
    1b36:	90 91 9a 08 	lds	r25, 0x089A	; 0x80089a <xSemaphoreADC+0x1>
    1b3a:	00 97       	sbiw	r24, 0x00	; 0
    1b3c:	09 f4       	brne	.+2      	; 0x1b40 <temperatureReadTask+0x40>
    1b3e:	41 c0       	rjmp	.+130    	; 0x1bc2 <temperatureReadTask+0xc2>
		{
        /* See if we can obtain the semaphore.  If the semaphore is not
        available wait 10 ticks to see if it becomes free. */
		
			if( xSemaphoreTake( xSemaphoreADC, ( TickType_t ) 100 ) == pdTRUE )
    1b40:	20 e0       	ldi	r18, 0x00	; 0
    1b42:	44 e6       	ldi	r20, 0x64	; 100
    1b44:	50 e0       	ldi	r21, 0x00	; 0
    1b46:	60 e0       	ldi	r22, 0x00	; 0
    1b48:	70 e0       	ldi	r23, 0x00	; 0
    1b4a:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    1b4e:	81 30       	cpi	r24, 0x01	; 1
    1b50:	c1 f5       	brne	.+112    	; 0x1bc2 <temperatureReadTask+0xc2>
	DDRB |= (1 << 3) | (1 << 2) | (1 << 4);
	
}

static void ADC_setupTemp(void){
	DDRC&=~(1<<0);
    1b52:	38 98       	cbi	0x07, 0	; 7
	ADCSRA = 0x87; //make ADC enagle and select ck/128
    1b54:	f7 01       	movw	r30, r14
    1b56:	c0 82       	st	Z, r12
	ADMUX = 0b11000000; //adc0
    1b58:	f8 01       	movw	r30, r16
    1b5a:	d0 82       	st	Z, r13
			if( xSemaphoreTake( xSemaphoreADC, ( TickType_t ) 100 ) == pdTRUE )
			{
				/* We were able to obtain the semaphore and can now access the
				shared resource. */
				ADC_setupTemp();
				temperature = ADC_read()*10/93-50;
    1b5c:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <ADC_read>
    1b60:	20 e0       	ldi	r18, 0x00	; 0
    1b62:	30 e0       	ldi	r19, 0x00	; 0
    1b64:	40 e2       	ldi	r20, 0x20	; 32
    1b66:	51 e4       	ldi	r21, 0x41	; 65
    1b68:	0e 94 8e 13 	call	0x271c	; 0x271c <__mulsf3>
    1b6c:	20 e0       	ldi	r18, 0x00	; 0
    1b6e:	30 e0       	ldi	r19, 0x00	; 0
    1b70:	4a eb       	ldi	r20, 0xBA	; 186
    1b72:	52 e4       	ldi	r21, 0x42	; 66
    1b74:	0e 94 5a 12 	call	0x24b4	; 0x24b4 <__divsf3>
    1b78:	20 e0       	ldi	r18, 0x00	; 0
    1b7a:	30 e0       	ldi	r19, 0x00	; 0
    1b7c:	48 e4       	ldi	r20, 0x48	; 72
    1b7e:	52 e4       	ldi	r21, 0x42	; 66
    1b80:	0e 94 ed 11 	call	0x23da	; 0x23da <__subsf3>
    1b84:	69 83       	std	Y+1, r22	; 0x01
    1b86:	7a 83       	std	Y+2, r23	; 0x02
    1b88:	8b 83       	std	Y+3, r24	; 0x03
    1b8a:	9c 83       	std	Y+4, r25	; 0x04
			
				/* We have finished accessing the shared resource.  Release the
				semaphore. */
				xSemaphoreGive( xSemaphoreADC );
    1b8c:	20 e0       	ldi	r18, 0x00	; 0
    1b8e:	40 e0       	ldi	r20, 0x00	; 0
    1b90:	50 e0       	ldi	r21, 0x00	; 0
    1b92:	60 e0       	ldi	r22, 0x00	; 0
    1b94:	70 e0       	ldi	r23, 0x00	; 0
    1b96:	80 91 99 08 	lds	r24, 0x0899	; 0x800899 <xSemaphoreADC>
    1b9a:	90 91 9a 08 	lds	r25, 0x089A	; 0x80089a <xSemaphoreADC+0x1>
    1b9e:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
			
				if (temperature >= threshold) {
    1ba2:	20 e0       	ldi	r18, 0x00	; 0
    1ba4:	30 e0       	ldi	r19, 0x00	; 0
    1ba6:	40 ef       	ldi	r20, 0xF0	; 240
    1ba8:	51 e4       	ldi	r21, 0x41	; 65
    1baa:	69 81       	ldd	r22, Y+1	; 0x01
    1bac:	7a 81       	ldd	r23, Y+2	; 0x02
    1bae:	8b 81       	ldd	r24, Y+3	; 0x03
    1bb0:	9c 81       	ldd	r25, Y+4	; 0x04
    1bb2:	0e 94 89 13 	call	0x2712	; 0x2712 <__gesf2>
    1bb6:	88 23       	and	r24, r24
    1bb8:	14 f0       	brlt	.+4      	; 0x1bbe <temperatureReadTask+0xbe>
					alarmON();
    1bba:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <alarmON>
				}
				else {
					if (alarmState = ON){
    1bbe:	10 92 a5 08 	sts	0x08A5, r1	; 0x8008a5 <alarmState>
				/* We could not obtain the semaphore and can therefore not access
				the shared resource safely. */
			}
		}
				
		if( xQueueTemperatureSendings != 0 )
    1bc2:	80 91 8f 08 	lds	r24, 0x088F	; 0x80088f <xQueueTemperatureSendings>
    1bc6:	90 91 90 08 	lds	r25, 0x0890	; 0x800890 <xQueueTemperatureSendings+0x1>
    1bca:	00 97       	sbiw	r24, 0x00	; 0
    1bcc:	09 f4       	brne	.+2      	; 0x1bd0 <temperatureReadTask+0xd0>
    1bce:	ad cf       	rjmp	.-166    	; 0x1b2a <temperatureReadTask+0x2a>
		{
        /* Send an unsigned long.  Wait for 10 ticks for space to become
        available if necessary. */
			if( xQueueSend( xQueueTemperatureSendings,
    1bd0:	20 e0       	ldi	r18, 0x00	; 0
    1bd2:	44 e6       	ldi	r20, 0x64	; 100
    1bd4:	50 e0       	ldi	r21, 0x00	; 0
    1bd6:	be 01       	movw	r22, r28
    1bd8:	6f 5f       	subi	r22, 0xFF	; 255
    1bda:	7f 4f       	sbci	r23, 0xFF	; 255
    1bdc:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
    1be0:	a4 cf       	rjmp	.-184    	; 0x1b2a <temperatureReadTask+0x2a>

00001be2 <airReadTask>:
		}
	
	}
}

void airReadTask(void* parameter) {
    1be2:	cf 93       	push	r28
    1be4:	df 93       	push	r29
    1be6:	00 d0       	rcall	.+0      	; 0x1be8 <airReadTask+0x6>
    1be8:	00 d0       	rcall	.+0      	; 0x1bea <airReadTask+0x8>
    1bea:	cd b7       	in	r28, 0x3d	; 61
    1bec:	de b7       	in	r29, 0x3e	; 62
	
}

static void ADC_setupAir(void){
	DDRC&=~(1<<1);
	ADCSRA = 0x87; //make ADC enagle and select ck/128
    1bee:	0f 2e       	mov	r0, r31
    1bf0:	fa e7       	ldi	r31, 0x7A	; 122
    1bf2:	ef 2e       	mov	r14, r31
    1bf4:	f1 2c       	mov	r15, r1
    1bf6:	f0 2d       	mov	r31, r0
    1bf8:	0f 2e       	mov	r0, r31
    1bfa:	f7 e8       	ldi	r31, 0x87	; 135
    1bfc:	cf 2e       	mov	r12, r31
    1bfe:	f0 2d       	mov	r31, r0
	ADMUX = 0b01000001; //adc1
    1c00:	0c e7       	ldi	r16, 0x7C	; 124
    1c02:	10 e0       	ldi	r17, 0x00	; 0
    1c04:	0f 2e       	mov	r0, r31
    1c06:	f1 e4       	ldi	r31, 0x41	; 65
    1c08:	df 2e       	mov	r13, r31
    1c0a:	f0 2d       	mov	r31, r0
	float threshold = 200.00;
	float air;
	
	for (;;)
	{
		vTaskSuspend(NULL);
    1c0c:	80 e0       	ldi	r24, 0x00	; 0
    1c0e:	90 e0       	ldi	r25, 0x00	; 0
    1c10:	0e 94 58 09 	call	0x12b0	; 0x12b0 <vTaskSuspend>
		
		if( xSemaphoreADC != NULL )
    1c14:	80 91 99 08 	lds	r24, 0x0899	; 0x800899 <xSemaphoreADC>
    1c18:	90 91 9a 08 	lds	r25, 0x089A	; 0x80089a <xSemaphoreADC+0x1>
    1c1c:	00 97       	sbiw	r24, 0x00	; 0
    1c1e:	79 f1       	breq	.+94     	; 0x1c7e <airReadTask+0x9c>
		{
			/* See if we can obtain the semaphore.  If the semaphore is not
			available wait 10 ticks to see if it becomes free. */
			if( xSemaphoreTake( xSemaphoreADC, ( TickType_t ) 100 ) == pdTRUE )
    1c20:	20 e0       	ldi	r18, 0x00	; 0
    1c22:	44 e6       	ldi	r20, 0x64	; 100
    1c24:	50 e0       	ldi	r21, 0x00	; 0
    1c26:	60 e0       	ldi	r22, 0x00	; 0
    1c28:	70 e0       	ldi	r23, 0x00	; 0
    1c2a:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    1c2e:	81 30       	cpi	r24, 0x01	; 1
    1c30:	31 f5       	brne	.+76     	; 0x1c7e <airReadTask+0x9c>
	ADMUX = 0b11000000; //adc0
	
}

static void ADC_setupAir(void){
	DDRC&=~(1<<1);
    1c32:	39 98       	cbi	0x07, 1	; 7
	ADCSRA = 0x87; //make ADC enagle and select ck/128
    1c34:	f7 01       	movw	r30, r14
    1c36:	c0 82       	st	Z, r12
	ADMUX = 0b01000001; //adc1
    1c38:	f8 01       	movw	r30, r16
    1c3a:	d0 82       	st	Z, r13
			{
				/* We were able to obtain the semaphore and can now access the
				shared resource. */

				ADC_setupAir();
				air = ADC_read();
    1c3c:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <ADC_read>
    1c40:	69 83       	std	Y+1, r22	; 0x01
    1c42:	7a 83       	std	Y+2, r23	; 0x02
    1c44:	8b 83       	std	Y+3, r24	; 0x03
    1c46:	9c 83       	std	Y+4, r25	; 0x04
			

				/* We have finished accessing the shared resource.  Release the
				semaphore. */
				xSemaphoreGive( xSemaphoreADC );
    1c48:	20 e0       	ldi	r18, 0x00	; 0
    1c4a:	40 e0       	ldi	r20, 0x00	; 0
    1c4c:	50 e0       	ldi	r21, 0x00	; 0
    1c4e:	60 e0       	ldi	r22, 0x00	; 0
    1c50:	70 e0       	ldi	r23, 0x00	; 0
    1c52:	80 91 99 08 	lds	r24, 0x0899	; 0x800899 <xSemaphoreADC>
    1c56:	90 91 9a 08 	lds	r25, 0x089A	; 0x80089a <xSemaphoreADC+0x1>
    1c5a:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
				
				if (air >= threshold) {
    1c5e:	20 e0       	ldi	r18, 0x00	; 0
    1c60:	30 e0       	ldi	r19, 0x00	; 0
    1c62:	48 e4       	ldi	r20, 0x48	; 72
    1c64:	53 e4       	ldi	r21, 0x43	; 67
    1c66:	69 81       	ldd	r22, Y+1	; 0x01
    1c68:	7a 81       	ldd	r23, Y+2	; 0x02
    1c6a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c6c:	9c 81       	ldd	r25, Y+4	; 0x04
    1c6e:	0e 94 89 13 	call	0x2712	; 0x2712 <__gesf2>
    1c72:	88 23       	and	r24, r24
    1c74:	14 f0       	brlt	.+4      	; 0x1c7a <airReadTask+0x98>
					alarmON();
    1c76:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <alarmON>
				}
				else {
					if (alarmState = ON){
    1c7a:	10 92 a5 08 	sts	0x08A5, r1	; 0x8008a5 <alarmState>
				/* We could not obtain the semaphore and can therefore not access
				the shared resource safely. */
			}
		}
		
		if( xQueueAirSendings != 0 )
    1c7e:	80 91 a3 08 	lds	r24, 0x08A3	; 0x8008a3 <xQueueAirSendings>
    1c82:	90 91 a4 08 	lds	r25, 0x08A4	; 0x8008a4 <xQueueAirSendings+0x1>
    1c86:	00 97       	sbiw	r24, 0x00	; 0
    1c88:	09 f2       	breq	.-126    	; 0x1c0c <airReadTask+0x2a>
		{
			/* Send an unsigned long.  Wait for 10 ticks for space to become
			available if necessary. */
			if( xQueueSend( xQueueAirSendings,
    1c8a:	20 e0       	ldi	r18, 0x00	; 0
    1c8c:	44 e6       	ldi	r20, 0x64	; 100
    1c8e:	50 e0       	ldi	r21, 0x00	; 0
    1c90:	be 01       	movw	r22, r28
    1c92:	6f 5f       	subi	r22, 0xFF	; 255
    1c94:	7f 4f       	sbci	r23, 0xFF	; 255
    1c96:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>
    1c9a:	b8 cf       	rjmp	.-144    	; 0x1c0c <airReadTask+0x2a>

00001c9c <LCD_putValue>:
	UDR0 = data;
}

static void LCD_putValue(unsigned char val)
{
  LCD_DPRT &= 0x0F;
    1c9c:	9b b1       	in	r25, 0x0b	; 11
    1c9e:	9f 70       	andi	r25, 0x0F	; 15
    1ca0:	9b b9       	out	0x0b, r25	; 11
  LCD_DPRT |= (val&0xF0);     //send cmnd to data port
    1ca2:	9b b1       	in	r25, 0x0b	; 11
    1ca4:	28 2f       	mov	r18, r24
    1ca6:	20 7f       	andi	r18, 0xF0	; 240
    1ca8:	92 2b       	or	r25, r18
    1caa:	9b b9       	out	0x0b, r25	; 11
  LCD_CPRT |= (1<<LCD_EN);    //EN = 1 for H-to-L pulse
    1cac:	29 9a       	sbi	0x05, 1	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1cae:	35 e0       	ldi	r19, 0x05	; 5
    1cb0:	3a 95       	dec	r19
    1cb2:	f1 f7       	brne	.-4      	; 0x1cb0 <LCD_putValue+0x14>
    1cb4:	00 00       	nop
  _delay_us(1);       //wait to make enable wide
  LCD_CPRT &= ~ (1<<LCD_EN);  //EN = 0 for H-to-L pulse
    1cb6:	29 98       	cbi	0x05, 1	; 5
    1cb8:	ef e8       	ldi	r30, 0x8F	; 143
    1cba:	f1 e0       	ldi	r31, 0x01	; 1
    1cbc:	31 97       	sbiw	r30, 0x01	; 1
    1cbe:	f1 f7       	brne	.-4      	; 0x1cbc <LCD_putValue+0x20>
    1cc0:	00 c0       	rjmp	.+0      	; 0x1cc2 <LCD_putValue+0x26>
    1cc2:	00 00       	nop
  _delay_us(100);     //wait to make enable wide

  LCD_DPRT &= 0x0F;
    1cc4:	9b b1       	in	r25, 0x0b	; 11
    1cc6:	9f 70       	andi	r25, 0x0F	; 15
    1cc8:	9b b9       	out	0x0b, r25	; 11
  LCD_DPRT |= val<<4;     //send cmnd to data port
    1cca:	2b b1       	in	r18, 0x0b	; 11
    1ccc:	f0 e1       	ldi	r31, 0x10	; 16
    1cce:	8f 9f       	mul	r24, r31
    1cd0:	c0 01       	movw	r24, r0
    1cd2:	11 24       	eor	r1, r1
    1cd4:	82 2b       	or	r24, r18
    1cd6:	8b b9       	out	0x0b, r24	; 11
  LCD_CPRT |= (1<<LCD_EN);    //EN = 1 for H-to-L pulse
    1cd8:	29 9a       	sbi	0x05, 1	; 5
    1cda:	35 e0       	ldi	r19, 0x05	; 5
    1cdc:	3a 95       	dec	r19
    1cde:	f1 f7       	brne	.-4      	; 0x1cdc <LCD_putValue+0x40>
    1ce0:	00 00       	nop
  _delay_us(1);       //wait to make enable wide
  LCD_CPRT &= ~ (1<<LCD_EN);  //EN = 0 for H-to-L pulse
    1ce2:	29 98       	cbi	0x05, 1	; 5
    1ce4:	8f e8       	ldi	r24, 0x8F	; 143
    1ce6:	91 e0       	ldi	r25, 0x01	; 1
    1ce8:	01 97       	sbiw	r24, 0x01	; 1
    1cea:	f1 f7       	brne	.-4      	; 0x1ce8 <LCD_putValue+0x4c>
    1cec:	00 c0       	rjmp	.+0      	; 0x1cee <LCD_putValue+0x52>
    1cee:	00 00       	nop
    1cf0:	08 95       	ret

00001cf2 <LCD_sendCommand>:
  _delay_us(100);     //wait to make enable wide    
}

static void LCD_sendCommand( unsigned char cmnd )
{ 
  LCD_CPRT &= ~ (1<<LCD_RS);    //RS = 0 for command  
    1cf2:	28 98       	cbi	0x05, 0	; 5
  LCD_putValue(cmnd);
    1cf4:	0e 94 4e 0e 	call	0x1c9c	; 0x1c9c <LCD_putValue>
    1cf8:	08 95       	ret

00001cfa <LCD_sendData>:
}

static void LCD_sendData( unsigned char data )
{
  LCD_CPRT |= (1<<LCD_RS);    //RS = 1 for data   
    1cfa:	28 9a       	sbi	0x05, 0	; 5
  LCD_putValue(data);  
    1cfc:	0e 94 4e 0e 	call	0x1c9c	; 0x1c9c <LCD_putValue>
    1d00:	08 95       	ret

00001d02 <LCD_goToXY>:

  LCD_clear();    
}

static void LCD_goToXY(unsigned char x, unsigned char y)
{  
    1d02:	cf 93       	push	r28
    1d04:	df 93       	push	r29
    1d06:	00 d0       	rcall	.+0      	; 0x1d08 <LCD_goToXY+0x6>
    1d08:	00 d0       	rcall	.+0      	; 0x1d0a <LCD_goToXY+0x8>
    1d0a:	cd b7       	in	r28, 0x3d	; 61
    1d0c:	de b7       	in	r29, 0x3e	; 62
  unsigned char firstCharAdr[]={0x80,0xC0,0x94,0xD4};//Table 12-4  
    1d0e:	90 e8       	ldi	r25, 0x80	; 128
    1d10:	99 83       	std	Y+1, r25	; 0x01
    1d12:	90 ec       	ldi	r25, 0xC0	; 192
    1d14:	9a 83       	std	Y+2, r25	; 0x02
    1d16:	94 e9       	ldi	r25, 0x94	; 148
    1d18:	9b 83       	std	Y+3, r25	; 0x03
    1d1a:	94 ed       	ldi	r25, 0xD4	; 212
    1d1c:	9c 83       	std	Y+4, r25	; 0x04
  LCD_sendCommand(firstCharAdr[y-1] + x - 1);
    1d1e:	fe 01       	movw	r30, r28
    1d20:	e6 0f       	add	r30, r22
    1d22:	f1 1d       	adc	r31, r1
    1d24:	81 50       	subi	r24, 0x01	; 1
    1d26:	90 81       	ld	r25, Z
    1d28:	89 0f       	add	r24, r25
    1d2a:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <LCD_sendCommand>
    1d2e:	8f e8       	ldi	r24, 0x8F	; 143
    1d30:	91 e0       	ldi	r25, 0x01	; 1
    1d32:	01 97       	sbiw	r24, 0x01	; 1
    1d34:	f1 f7       	brne	.-4      	; 0x1d32 <LCD_goToXY+0x30>
    1d36:	00 c0       	rjmp	.+0      	; 0x1d38 <LCD_goToXY+0x36>
    1d38:	00 00       	nop
  _delay_us(100); 
}
    1d3a:	0f 90       	pop	r0
    1d3c:	0f 90       	pop	r0
    1d3e:	0f 90       	pop	r0
    1d40:	0f 90       	pop	r0
    1d42:	df 91       	pop	r29
    1d44:	cf 91       	pop	r28
    1d46:	08 95       	ret

00001d48 <temperatureSendTask>:
		
		}//FOR
		
	}//TEMPERATURE SESNING TASK
	
void temperatureSendTask (void* parameter){
    1d48:	cf 93       	push	r28
    1d4a:	df 93       	push	r29
    1d4c:	cd b7       	in	r28, 0x3d	; 61
    1d4e:	de b7       	in	r29, 0x3e	; 62
    1d50:	a4 97       	sbiw	r28, 0x24	; 36
    1d52:	0f b6       	in	r0, 0x3f	; 63
    1d54:	f8 94       	cli
    1d56:	de bf       	out	0x3e, r29	; 62
    1d58:	0f be       	out	0x3f, r0	; 63
    1d5a:	cd bf       	out	0x3d, r28	; 61
    1d5c:	8e 01       	movw	r16, r28
    1d5e:	0b 5d       	subi	r16, 0xDB	; 219
    1d60:	1f 4f       	sbci	r17, 0xFF	; 255
	char *jsonDataTemperatureTempT2 = malloc(len1+7);
	
	for (int i = 0; i<len1; i++){
		jsonDataTemperatureTempT2[i] = jsonDataTemperatureTemp[i];
	}
	jsonDataTemperatureTempT2 [len1-1] = ':';
    1d62:	0f 2e       	mov	r0, r31
    1d64:	fa e3       	ldi	r31, 0x3A	; 58
    1d66:	af 2e       	mov	r10, r31
    1d68:	f0 2d       	mov	r31, r0
	jsonDataTemperatureTempT2 [len1] = ASCII_CONVERT(d1);
	jsonDataTemperatureTempT2 [len1+1] = ASCII_CONVERT(d2);
	jsonDataTemperatureTempT2 [len1+2] = '.';
	jsonDataTemperatureTempT2 [len1+3] = ASCII_CONVERT(d3);
	jsonDataTemperatureTempT2 [len1+4] = ASCII_CONVERT(d4);
	jsonDataTemperatureTempT2 [len1+5] = '}';
    1d6a:	0f 2e       	mov	r0, r31
    1d6c:	fd e7       	ldi	r31, 0x7D	; 125
    1d6e:	bf 2e       	mov	r11, r31
    1d70:	f0 2d       	mov	r31, r0
	jsonDataTemperatureTempT2 [len1+6] = '\n';
    1d72:	0f 2e       	mov	r0, r31
    1d74:	fa e0       	ldi	r31, 0x0A	; 10
    1d76:	cf 2e       	mov	r12, r31
    1d78:	f0 2d       	mov	r31, r0
void temperatureSendTask (void* parameter){
	
	float temperature;
	for (;;)
	{
		if( xQueueTemperatureSendings != NULL )
    1d7a:	80 91 8f 08 	lds	r24, 0x088F	; 0x80088f <xQueueTemperatureSendings>
    1d7e:	90 91 90 08 	lds	r25, 0x0890	; 0x800890 <xQueueTemperatureSendings+0x1>
    1d82:	00 97       	sbiw	r24, 0x00	; 0
    1d84:	f1 f3       	breq	.-4      	; 0x1d82 <temperatureSendTask+0x3a>
		{
		 /* Receive a message from the created queue to hold pointers.  Block for 10
		ticks if a message is not immediately available.  The value is read into a
		 pointer variable, and as the value received is the address of the xMessage
		variable, after this call pxRxedPointer will point to xMessage. */
			if( xQueueReceive( xQueueTemperatureSendings,
    1d86:	20 e0       	ldi	r18, 0x00	; 0
    1d88:	4a e0       	ldi	r20, 0x0A	; 10
    1d8a:	50 e0       	ldi	r21, 0x00	; 0
    1d8c:	be 01       	movw	r22, r28
    1d8e:	6f 5f       	subi	r22, 0xFF	; 255
    1d90:	7f 4f       	sbci	r23, 0xFF	; 255
    1d92:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    1d96:	81 30       	cpi	r24, 0x01	; 1
    1d98:	81 f7       	brne	.-32     	; 0x1d7a <temperatureSendTask+0x32>
                         &( temperature ),
                         ( TickType_t ) 10 ) == pdPASS )
						 
			{
				LCD_goToXY(6,1);
    1d9a:	61 e0       	ldi	r22, 0x01	; 1
    1d9c:	86 e0       	ldi	r24, 0x06	; 6
    1d9e:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <LCD_goToXY>
	unsigned char d1,d2,d3,d4;
	//sono 3 cifre

	//float convert = value *10/93-50;

	z = value*100;
    1da2:	20 e0       	ldi	r18, 0x00	; 0
    1da4:	30 e0       	ldi	r19, 0x00	; 0
    1da6:	48 ec       	ldi	r20, 0xC8	; 200
    1da8:	52 e4       	ldi	r21, 0x42	; 66
    1daa:	69 81       	ldd	r22, Y+1	; 0x01
    1dac:	7a 81       	ldd	r23, Y+2	; 0x02
    1dae:	8b 81       	ldd	r24, Y+3	; 0x03
    1db0:	9c 81       	ldd	r25, Y+4	; 0x04
    1db2:	0e 94 8e 13 	call	0x271c	; 0x271c <__mulsf3>
    1db6:	0e 94 cc 12 	call	0x2598	; 0x2598 <__fixunssfsi>
    1dba:	2b 01       	movw	r4, r22
    1dbc:	3c 01       	movw	r6, r24
	d1=y%10;
	d2=x%10;
	d3=w%10;
	d4=z%10;

	LCD_sendData(ASCII_CONVERT(d1));
    1dbe:	9b 01       	movw	r18, r22
    1dc0:	36 95       	lsr	r19
    1dc2:	27 95       	ror	r18
    1dc4:	36 95       	lsr	r19
    1dc6:	27 95       	ror	r18
    1dc8:	36 95       	lsr	r19
    1dca:	27 95       	ror	r18
    1dcc:	a5 ec       	ldi	r26, 0xC5	; 197
    1dce:	b0 e2       	ldi	r27, 0x20	; 32
    1dd0:	0e 94 25 14 	call	0x284a	; 0x284a <__umulhisi3>
    1dd4:	ac 01       	movw	r20, r24
    1dd6:	52 95       	swap	r21
    1dd8:	42 95       	swap	r20
    1dda:	4f 70       	andi	r20, 0x0F	; 15
    1ddc:	45 27       	eor	r20, r21
    1dde:	5f 70       	andi	r21, 0x0F	; 15
    1de0:	45 27       	eor	r20, r21
    1de2:	9a 01       	movw	r18, r20
    1de4:	ad ec       	ldi	r26, 0xCD	; 205
    1de6:	bc ec       	ldi	r27, 0xCC	; 204
    1de8:	0e 94 25 14 	call	0x284a	; 0x284a <__umulhisi3>
    1dec:	96 95       	lsr	r25
    1dee:	87 95       	ror	r24
    1df0:	96 95       	lsr	r25
    1df2:	87 95       	ror	r24
    1df4:	96 95       	lsr	r25
    1df6:	87 95       	ror	r24
    1df8:	9c 01       	movw	r18, r24
    1dfa:	22 0f       	add	r18, r18
    1dfc:	33 1f       	adc	r19, r19
    1dfe:	88 0f       	add	r24, r24
    1e00:	99 1f       	adc	r25, r25
    1e02:	88 0f       	add	r24, r24
    1e04:	99 1f       	adc	r25, r25
    1e06:	88 0f       	add	r24, r24
    1e08:	99 1f       	adc	r25, r25
    1e0a:	82 0f       	add	r24, r18
    1e0c:	93 1f       	adc	r25, r19
    1e0e:	48 1b       	sub	r20, r24
    1e10:	59 0b       	sbc	r21, r25
    1e12:	0f 2e       	mov	r0, r31
    1e14:	f0 e3       	ldi	r31, 0x30	; 48
    1e16:	9f 2e       	mov	r9, r31
    1e18:	f0 2d       	mov	r31, r0
    1e1a:	94 0e       	add	r9, r20
    1e1c:	89 2d       	mov	r24, r9
    1e1e:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <LCD_sendData>
	LCD_sendData(ASCII_CONVERT(d2));
    1e22:	92 01       	movw	r18, r4
    1e24:	36 95       	lsr	r19
    1e26:	27 95       	ror	r18
    1e28:	36 95       	lsr	r19
    1e2a:	27 95       	ror	r18
    1e2c:	ab e7       	ldi	r26, 0x7B	; 123
    1e2e:	b4 e1       	ldi	r27, 0x14	; 20
    1e30:	0e 94 25 14 	call	0x284a	; 0x284a <__umulhisi3>
    1e34:	ac 01       	movw	r20, r24
    1e36:	56 95       	lsr	r21
    1e38:	47 95       	ror	r20
    1e3a:	9a 01       	movw	r18, r20
    1e3c:	ad ec       	ldi	r26, 0xCD	; 205
    1e3e:	bc ec       	ldi	r27, 0xCC	; 204
    1e40:	0e 94 25 14 	call	0x284a	; 0x284a <__umulhisi3>
    1e44:	96 95       	lsr	r25
    1e46:	87 95       	ror	r24
    1e48:	96 95       	lsr	r25
    1e4a:	87 95       	ror	r24
    1e4c:	96 95       	lsr	r25
    1e4e:	87 95       	ror	r24
    1e50:	9c 01       	movw	r18, r24
    1e52:	22 0f       	add	r18, r18
    1e54:	33 1f       	adc	r19, r19
    1e56:	88 0f       	add	r24, r24
    1e58:	99 1f       	adc	r25, r25
    1e5a:	88 0f       	add	r24, r24
    1e5c:	99 1f       	adc	r25, r25
    1e5e:	88 0f       	add	r24, r24
    1e60:	99 1f       	adc	r25, r25
    1e62:	82 0f       	add	r24, r18
    1e64:	93 1f       	adc	r25, r19
    1e66:	48 1b       	sub	r20, r24
    1e68:	59 0b       	sbc	r21, r25
    1e6a:	0f 2e       	mov	r0, r31
    1e6c:	f0 e3       	ldi	r31, 0x30	; 48
    1e6e:	df 2e       	mov	r13, r31
    1e70:	f0 2d       	mov	r31, r0
    1e72:	d4 0e       	add	r13, r20
    1e74:	8d 2d       	mov	r24, r13
    1e76:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <LCD_sendData>
	LCD_sendData('.');
    1e7a:	8e e2       	ldi	r24, 0x2E	; 46
    1e7c:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <LCD_sendData>
	LCD_sendData(ASCII_CONVERT(d3));
    1e80:	92 01       	movw	r18, r4
    1e82:	ad ec       	ldi	r26, 0xCD	; 205
    1e84:	bc ec       	ldi	r27, 0xCC	; 204
    1e86:	0e 94 25 14 	call	0x284a	; 0x284a <__umulhisi3>
    1e8a:	7c 01       	movw	r14, r24
    1e8c:	f6 94       	lsr	r15
    1e8e:	e7 94       	ror	r14
    1e90:	f6 94       	lsr	r15
    1e92:	e7 94       	ror	r14
    1e94:	f6 94       	lsr	r15
    1e96:	e7 94       	ror	r14
    1e98:	97 01       	movw	r18, r14
    1e9a:	0e 94 25 14 	call	0x284a	; 0x284a <__umulhisi3>
    1e9e:	96 95       	lsr	r25
    1ea0:	87 95       	ror	r24
    1ea2:	96 95       	lsr	r25
    1ea4:	87 95       	ror	r24
    1ea6:	96 95       	lsr	r25
    1ea8:	87 95       	ror	r24
    1eaa:	9c 01       	movw	r18, r24
    1eac:	22 0f       	add	r18, r18
    1eae:	33 1f       	adc	r19, r19
    1eb0:	88 0f       	add	r24, r24
    1eb2:	99 1f       	adc	r25, r25
    1eb4:	88 0f       	add	r24, r24
    1eb6:	99 1f       	adc	r25, r25
    1eb8:	88 0f       	add	r24, r24
    1eba:	99 1f       	adc	r25, r25
    1ebc:	82 0f       	add	r24, r18
    1ebe:	93 1f       	adc	r25, r19
    1ec0:	97 01       	movw	r18, r14
    1ec2:	28 1b       	sub	r18, r24
    1ec4:	39 0b       	sbc	r19, r25
    1ec6:	0f 2e       	mov	r0, r31
    1ec8:	f0 e3       	ldi	r31, 0x30	; 48
    1eca:	8f 2e       	mov	r8, r31
    1ecc:	f0 2d       	mov	r31, r0
    1ece:	82 0e       	add	r8, r18
    1ed0:	88 2d       	mov	r24, r8
    1ed2:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <LCD_sendData>
	LCD_sendData(ASCII_CONVERT(d4));
    1ed6:	c7 01       	movw	r24, r14
    1ed8:	88 0f       	add	r24, r24
    1eda:	99 1f       	adc	r25, r25
    1edc:	ee 0c       	add	r14, r14
    1ede:	ff 1c       	adc	r15, r15
    1ee0:	ee 0c       	add	r14, r14
    1ee2:	ff 1c       	adc	r15, r15
    1ee4:	ee 0c       	add	r14, r14
    1ee6:	ff 1c       	adc	r15, r15
    1ee8:	e8 0e       	add	r14, r24
    1eea:	f9 1e       	adc	r15, r25
    1eec:	c2 01       	movw	r24, r4
    1eee:	8e 19       	sub	r24, r14
    1ef0:	9f 09       	sbc	r25, r15
    1ef2:	0f 2e       	mov	r0, r31
    1ef4:	f0 e3       	ldi	r31, 0x30	; 48
    1ef6:	4f 2e       	mov	r4, r31
    1ef8:	f0 2d       	mov	r31, r0
    1efa:	48 0e       	add	r4, r24
    1efc:	84 2d       	mov	r24, r4
    1efe:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <LCD_sendData>
	LCD_sendData(223);
    1f02:	8f ed       	ldi	r24, 0xDF	; 223
    1f04:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <LCD_sendData>

	return (ADCL+(ADCH<<8));
}

static char* generateArrayTemperature(unsigned char d1, unsigned char d2, unsigned char d3, unsigned char d4){
	char jsonDataTemperatureTemp [] = "{\"sensor\":\"temperature\",\"value\"";
    1f08:	80 e2       	ldi	r24, 0x20	; 32
    1f0a:	eb ee       	ldi	r30, 0xEB	; 235
    1f0c:	f1 e0       	ldi	r31, 0x01	; 1
    1f0e:	de 01       	movw	r26, r28
    1f10:	15 96       	adiw	r26, 0x05	; 5
    1f12:	01 90       	ld	r0, Z+
    1f14:	0d 92       	st	X+, r0
    1f16:	8a 95       	dec	r24
    1f18:	e1 f7       	brne	.-8      	; 0x1f12 <temperatureSendTask+0x1ca>
	int len1 = sizeof(jsonDataTemperatureTemp);
	char *jsonDataTemperatureTempT2 = malloc(len1+7);
    1f1a:	87 e2       	ldi	r24, 0x27	; 39
    1f1c:	90 e0       	ldi	r25, 0x00	; 0
    1f1e:	0e 94 34 14 	call	0x2868	; 0x2868 <malloc>
    1f22:	7c 01       	movw	r14, r24
    1f24:	fe 01       	movw	r30, r28
    1f26:	35 96       	adiw	r30, 0x05	; 5
    1f28:	dc 01       	movw	r26, r24
	
	for (int i = 0; i<len1; i++){
		jsonDataTemperatureTempT2[i] = jsonDataTemperatureTemp[i];
    1f2a:	81 91       	ld	r24, Z+
    1f2c:	8d 93       	st	X+, r24
static char* generateArrayTemperature(unsigned char d1, unsigned char d2, unsigned char d3, unsigned char d4){
	char jsonDataTemperatureTemp [] = "{\"sensor\":\"temperature\",\"value\"";
	int len1 = sizeof(jsonDataTemperatureTemp);
	char *jsonDataTemperatureTempT2 = malloc(len1+7);
	
	for (int i = 0; i<len1; i++){
    1f2e:	e0 17       	cp	r30, r16
    1f30:	f1 07       	cpc	r31, r17
    1f32:	d9 f7       	brne	.-10     	; 0x1f2a <temperatureSendTask+0x1e2>
		jsonDataTemperatureTempT2[i] = jsonDataTemperatureTemp[i];
	}
	jsonDataTemperatureTempT2 [len1-1] = ':';
    1f34:	f7 01       	movw	r30, r14
    1f36:	a7 8e       	std	Z+31, r10	; 0x1f
	jsonDataTemperatureTempT2 [len1] = ASCII_CONVERT(d1);
    1f38:	90 a2       	std	Z+32, r9	; 0x20
	jsonDataTemperatureTempT2 [len1+1] = ASCII_CONVERT(d2);
    1f3a:	d1 a2       	std	Z+33, r13	; 0x21
	jsonDataTemperatureTempT2 [len1+2] = '.';
    1f3c:	8e e2       	ldi	r24, 0x2E	; 46
    1f3e:	82 a3       	std	Z+34, r24	; 0x22
	jsonDataTemperatureTempT2 [len1+3] = ASCII_CONVERT(d3);
    1f40:	83 a2       	std	Z+35, r8	; 0x23
	jsonDataTemperatureTempT2 [len1+4] = ASCII_CONVERT(d4);
    1f42:	44 a2       	std	Z+36, r4	; 0x24
	jsonDataTemperatureTempT2 [len1+5] = '}';
    1f44:	b5 a2       	std	Z+37, r11	; 0x25
	jsonDataTemperatureTempT2 [len1+6] = '\n';
    1f46:	c6 a2       	std	Z+38, r12	; 0x26
	jsonDataTemperatureTempT2 [len1+7] = '\0';
    1f48:	17 a2       	std	Z+39, r1	; 0x27
                         ( TickType_t ) 10 ) == pdPASS )
						 
			{
				LCD_goToXY(6,1);
				char *jsonDataTemperature = convertAndWriteTemp(temperature);
				vTaskDelay(pdMS_TO_TICKS(10));
    1f4a:	8a e0       	ldi	r24, 0x0A	; 10
    1f4c:	90 e0       	ldi	r25, 0x00	; 0
    1f4e:	0e 94 9f 08 	call	0x113e	; 0x113e <vTaskDelay>
				UART_sendString(jsonDataTemperature);
    1f52:	c7 01       	movw	r24, r14
    1f54:	0e 94 e5 0c 	call	0x19ca	; 0x19ca <UART_sendString>
				vTaskDelay(pdMS_TO_TICKS(10));
    1f58:	8a e0       	ldi	r24, 0x0A	; 10
    1f5a:	90 e0       	ldi	r25, 0x00	; 0
    1f5c:	0e 94 9f 08 	call	0x113e	; 0x113e <vTaskDelay>
				free(jsonDataTemperature);
    1f60:	c7 01       	movw	r24, r14
    1f62:	0e 94 cc 14 	call	0x2998	; 0x2998 <free>
				vTaskDelay(pdMS_TO_TICKS(10));
    1f66:	8a e0       	ldi	r24, 0x0A	; 10
    1f68:	90 e0       	ldi	r25, 0x00	; 0
    1f6a:	0e 94 9f 08 	call	0x113e	; 0x113e <vTaskDelay>
    1f6e:	05 cf       	rjmp	.-502    	; 0x1d7a <temperatureSendTask+0x32>

00001f70 <airSendTask>:
		
	}//FOR
		
}//READING AIR

void airSendTask (void* parameter){
    1f70:	cf 93       	push	r28
    1f72:	df 93       	push	r29
    1f74:	cd b7       	in	r28, 0x3d	; 61
    1f76:	de b7       	in	r29, 0x3e	; 62
    1f78:	6c 97       	sbiw	r28, 0x1c	; 28
    1f7a:	0f b6       	in	r0, 0x3f	; 63
    1f7c:	f8 94       	cli
    1f7e:	de bf       	out	0x3e, r29	; 62
    1f80:	0f be       	out	0x3f, r0	; 63
    1f82:	cd bf       	out	0x3d, r28	; 61
    1f84:	8e 01       	movw	r16, r28
    1f86:	03 5e       	subi	r16, 0xE3	; 227
    1f88:	1f 4f       	sbci	r17, 0xFF	; 255
		for (int i = 0; i<len; i++){
			jsonDataAirT2[i] = jsonDataAir[i];
		}

		
		jsonDataAirT2 [len-1] = ':';
    1f8a:	0f 2e       	mov	r0, r31
    1f8c:	fa e3       	ldi	r31, 0x3A	; 58
    1f8e:	7f 2e       	mov	r7, r31
    1f90:	f0 2d       	mov	r31, r0
		}
		
		
		jsonDataAirT2 [len+2] = d3+ASCII_OFFSET;
		
		jsonDataAirT2 [len+3] = '.';
    1f92:	0f 2e       	mov	r0, r31
    1f94:	fe e2       	ldi	r31, 0x2E	; 46
    1f96:	8f 2e       	mov	r8, r31
    1f98:	f0 2d       	mov	r31, r0
		jsonDataAirT2 [len+4] = '0';
    1f9a:	0f 2e       	mov	r0, r31
    1f9c:	f0 e3       	ldi	r31, 0x30	; 48
    1f9e:	bf 2e       	mov	r11, r31
    1fa0:	f0 2d       	mov	r31, r0
		jsonDataAirT2 [len+5] = '0';
		
	jsonDataAirT2 [len+6] = '}';
    1fa2:	0f 2e       	mov	r0, r31
    1fa4:	fd e7       	ldi	r31, 0x7D	; 125
    1fa6:	9f 2e       	mov	r9, r31
    1fa8:	f0 2d       	mov	r31, r0
	
	jsonDataAirT2 [len+7] = '\n';
    1faa:	0f 2e       	mov	r0, r31
    1fac:	fa e0       	ldi	r31, 0x0A	; 10
    1fae:	6f 2e       	mov	r6, r31
    1fb0:	f0 2d       	mov	r31, r0
void airSendTask (void* parameter){
	
	float temperature;
	for (;;)
	{	
		if( xQueueTemperatureSendings != NULL )
    1fb2:	80 91 8f 08 	lds	r24, 0x088F	; 0x80088f <xQueueTemperatureSendings>
    1fb6:	90 91 90 08 	lds	r25, 0x0890	; 0x800890 <xQueueTemperatureSendings+0x1>
    1fba:	00 97       	sbiw	r24, 0x00	; 0
    1fbc:	f1 f3       	breq	.-4      	; 0x1fba <airSendTask+0x4a>
		{
		 /* Receive a message from the created queue to hold pointers.  Block for 10
		ticks if a message is not immediately available.  The value is read into a
		 pointer variable, and as the value received is the address of the xMessage
		variable, after this call pxRxedPointer will point to xMessage. */
			if( xQueueReceive( xQueueTemperatureSendings,
    1fbe:	20 e0       	ldi	r18, 0x00	; 0
    1fc0:	4a e0       	ldi	r20, 0x0A	; 10
    1fc2:	50 e0       	ldi	r21, 0x00	; 0
    1fc4:	be 01       	movw	r22, r28
    1fc6:	6f 5f       	subi	r22, 0xFF	; 255
    1fc8:	7f 4f       	sbci	r23, 0xFF	; 255
    1fca:	0e 94 75 04 	call	0x8ea	; 0x8ea <xQueueGenericReceive>
    1fce:	81 30       	cpi	r24, 0x01	; 1
    1fd0:	81 f7       	brne	.-32     	; 0x1fb2 <airSendTask+0x42>
                         &( temperature ),
                         ( TickType_t ) 10 ) == pdPASS )
						 
			{
				LCD_goToXY(6,2);
    1fd2:	62 e0       	ldi	r22, 0x02	; 2
    1fd4:	86 e0       	ldi	r24, 0x06	; 6
    1fd6:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <LCD_goToXY>
static char* convertAndWriteAir(float value){
	unsigned char d1,d2,d3;
	//sono 3 cifre
	unsigned int x,y,w;
	
	w = value;
    1fda:	60 91 95 08 	lds	r22, 0x0895	; 0x800895 <air>
    1fde:	70 91 96 08 	lds	r23, 0x0896	; 0x800896 <air+0x1>
    1fe2:	80 91 97 08 	lds	r24, 0x0897	; 0x800897 <air+0x2>
    1fe6:	90 91 98 08 	lds	r25, 0x0898	; 0x800898 <air+0x3>
    1fea:	0e 94 cc 12 	call	0x2598	; 0x2598 <__fixunssfsi>
    1fee:	1b 01       	movw	r2, r22
    1ff0:	2c 01       	movw	r4, r24
	x=w/10;
	y=x/10;
	
	
	d1=y%10;
    1ff2:	9b 01       	movw	r18, r22
    1ff4:	36 95       	lsr	r19
    1ff6:	27 95       	ror	r18
    1ff8:	36 95       	lsr	r19
    1ffa:	27 95       	ror	r18
    1ffc:	ab e7       	ldi	r26, 0x7B	; 123
    1ffe:	b4 e1       	ldi	r27, 0x14	; 20
    2000:	0e 94 25 14 	call	0x284a	; 0x284a <__umulhisi3>
    2004:	ac 01       	movw	r20, r24
    2006:	56 95       	lsr	r21
    2008:	47 95       	ror	r20
    200a:	9a 01       	movw	r18, r20
    200c:	ad ec       	ldi	r26, 0xCD	; 205
    200e:	bc ec       	ldi	r27, 0xCC	; 204
    2010:	0e 94 25 14 	call	0x284a	; 0x284a <__umulhisi3>
    2014:	96 95       	lsr	r25
    2016:	87 95       	ror	r24
    2018:	96 95       	lsr	r25
    201a:	87 95       	ror	r24
    201c:	96 95       	lsr	r25
    201e:	87 95       	ror	r24
    2020:	9c 01       	movw	r18, r24
    2022:	22 0f       	add	r18, r18
    2024:	33 1f       	adc	r19, r19
    2026:	88 0f       	add	r24, r24
    2028:	99 1f       	adc	r25, r25
    202a:	88 0f       	add	r24, r24
    202c:	99 1f       	adc	r25, r25
    202e:	88 0f       	add	r24, r24
    2030:	99 1f       	adc	r25, r25
    2032:	82 0f       	add	r24, r18
    2034:	93 1f       	adc	r25, r19
    2036:	48 1b       	sub	r20, r24
    2038:	59 0b       	sbc	r21, r25
    203a:	a4 2e       	mov	r10, r20
	d2=x%10;
	d3=w%10;
	

	
	LCD_sendData(d1+ASCII_OFFSET);
    203c:	0f 2e       	mov	r0, r31
    203e:	f0 e3       	ldi	r31, 0x30	; 48
    2040:	df 2e       	mov	r13, r31
    2042:	f0 2d       	mov	r31, r0
    2044:	d4 0e       	add	r13, r20
    2046:	8d 2d       	mov	r24, r13
    2048:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <LCD_sendData>
	LCD_sendData(d2+ASCII_OFFSET);
    204c:	91 01       	movw	r18, r2
    204e:	ad ec       	ldi	r26, 0xCD	; 205
    2050:	bc ec       	ldi	r27, 0xCC	; 204
    2052:	0e 94 25 14 	call	0x284a	; 0x284a <__umulhisi3>
    2056:	7c 01       	movw	r14, r24
    2058:	f6 94       	lsr	r15
    205a:	e7 94       	ror	r14
    205c:	f6 94       	lsr	r15
    205e:	e7 94       	ror	r14
    2060:	f6 94       	lsr	r15
    2062:	e7 94       	ror	r14
    2064:	97 01       	movw	r18, r14
    2066:	0e 94 25 14 	call	0x284a	; 0x284a <__umulhisi3>
    206a:	96 95       	lsr	r25
    206c:	87 95       	ror	r24
    206e:	96 95       	lsr	r25
    2070:	87 95       	ror	r24
    2072:	96 95       	lsr	r25
    2074:	87 95       	ror	r24
    2076:	9c 01       	movw	r18, r24
    2078:	22 0f       	add	r18, r18
    207a:	33 1f       	adc	r19, r19
    207c:	88 0f       	add	r24, r24
    207e:	99 1f       	adc	r25, r25
    2080:	88 0f       	add	r24, r24
    2082:	99 1f       	adc	r25, r25
    2084:	88 0f       	add	r24, r24
    2086:	99 1f       	adc	r25, r25
    2088:	82 0f       	add	r24, r18
    208a:	93 1f       	adc	r25, r19
    208c:	97 01       	movw	r18, r14
    208e:	28 1b       	sub	r18, r24
    2090:	39 0b       	sbc	r19, r25
    2092:	0f 2e       	mov	r0, r31
    2094:	f0 e3       	ldi	r31, 0x30	; 48
    2096:	cf 2e       	mov	r12, r31
    2098:	f0 2d       	mov	r31, r0
    209a:	c2 0e       	add	r12, r18
    209c:	8c 2d       	mov	r24, r12
    209e:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <LCD_sendData>
	LCD_sendData(d3+ASCII_OFFSET);
    20a2:	c7 01       	movw	r24, r14
    20a4:	88 0f       	add	r24, r24
    20a6:	99 1f       	adc	r25, r25
    20a8:	ee 0c       	add	r14, r14
    20aa:	ff 1c       	adc	r15, r15
    20ac:	ee 0c       	add	r14, r14
    20ae:	ff 1c       	adc	r15, r15
    20b0:	ee 0c       	add	r14, r14
    20b2:	ff 1c       	adc	r15, r15
    20b4:	e8 0e       	add	r14, r24
    20b6:	f9 1e       	adc	r15, r25
    20b8:	c1 01       	movw	r24, r2
    20ba:	8e 19       	sub	r24, r14
    20bc:	9f 09       	sbc	r25, r15
    20be:	0f 2e       	mov	r0, r31
    20c0:	f0 e3       	ldi	r31, 0x30	; 48
    20c2:	2f 2e       	mov	r2, r31
    20c4:	f0 2d       	mov	r31, r0
    20c6:	28 0e       	add	r2, r24
    20c8:	82 2d       	mov	r24, r2
    20ca:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <LCD_sendData>

	return generateArrayTemperature(d1, d2, d3, d4);
}

static char* generateArrayAir(unsigned char d1, unsigned char d2, unsigned char d3){
	char jsonDataAir [] = "{\"sensor\":\"air\",\"value\"";
    20ce:	88 e1       	ldi	r24, 0x18	; 24
    20d0:	eb e0       	ldi	r30, 0x0B	; 11
    20d2:	f2 e0       	ldi	r31, 0x02	; 2
    20d4:	de 01       	movw	r26, r28
    20d6:	15 96       	adiw	r26, 0x05	; 5
    20d8:	01 90       	ld	r0, Z+
    20da:	0d 92       	st	X+, r0
    20dc:	8a 95       	dec	r24
    20de:	e1 f7       	brne	.-8      	; 0x20d8 <airSendTask+0x168>
		int len = sizeof(jsonDataAir);
		char *jsonDataAirT2 = malloc(len+8);
    20e0:	80 e2       	ldi	r24, 0x20	; 32
    20e2:	90 e0       	ldi	r25, 0x00	; 0
    20e4:	0e 94 34 14 	call	0x2868	; 0x2868 <malloc>
    20e8:	7c 01       	movw	r14, r24
    20ea:	fe 01       	movw	r30, r28
    20ec:	35 96       	adiw	r30, 0x05	; 5
    20ee:	dc 01       	movw	r26, r24
		
		for (int i = 0; i<len; i++){
			jsonDataAirT2[i] = jsonDataAir[i];
    20f0:	81 91       	ld	r24, Z+
    20f2:	8d 93       	st	X+, r24
static char* generateArrayAir(unsigned char d1, unsigned char d2, unsigned char d3){
	char jsonDataAir [] = "{\"sensor\":\"air\",\"value\"";
		int len = sizeof(jsonDataAir);
		char *jsonDataAirT2 = malloc(len+8);
		
		for (int i = 0; i<len; i++){
    20f4:	e0 17       	cp	r30, r16
    20f6:	f1 07       	cpc	r31, r17
    20f8:	d9 f7       	brne	.-10     	; 0x20f0 <airSendTask+0x180>
			jsonDataAirT2[i] = jsonDataAir[i];
		}

		
		jsonDataAirT2 [len-1] = ':';
    20fa:	f7 01       	movw	r30, r14
    20fc:	77 8a       	std	Z+23, r7	; 0x17

		if ((d1+ASCII_OFFSET) == '0'){ //Non digerisco gli interi che iniziano per 0.
    20fe:	a1 10       	cpse	r10, r1
    2100:	04 c0       	rjmp	.+8      	; 0x210a <airSendTask+0x19a>
			jsonDataAirT2 [len] = d2+ASCII_OFFSET;
    2102:	c0 8e       	std	Z+24, r12	; 0x18
			len = len -1;
    2104:	e7 e1       	ldi	r30, 0x17	; 23
    2106:	f0 e0       	ldi	r31, 0x00	; 0
    2108:	05 c0       	rjmp	.+10     	; 0x2114 <airSendTask+0x1a4>
			} else {
			jsonDataAirT2 [len] = d1+ASCII_OFFSET;
    210a:	f7 01       	movw	r30, r14
    210c:	d0 8e       	std	Z+24, r13	; 0x18
			jsonDataAirT2 [len+1] = d2+ASCII_OFFSET;
    210e:	c1 8e       	std	Z+25, r12	; 0x19
	return generateArrayTemperature(d1, d2, d3, d4);
}

static char* generateArrayAir(unsigned char d1, unsigned char d2, unsigned char d3){
	char jsonDataAir [] = "{\"sensor\":\"air\",\"value\"";
		int len = sizeof(jsonDataAir);
    2110:	e8 e1       	ldi	r30, 0x18	; 24
    2112:	f0 e0       	ldi	r31, 0x00	; 0
			jsonDataAirT2 [len] = d1+ASCII_OFFSET;
			jsonDataAirT2 [len+1] = d2+ASCII_OFFSET;
		}
		
		
		jsonDataAirT2 [len+2] = d3+ASCII_OFFSET;
    2114:	ee 0d       	add	r30, r14
    2116:	ff 1d       	adc	r31, r15
    2118:	22 82       	std	Z+2, r2	; 0x02
		
		jsonDataAirT2 [len+3] = '.';
    211a:	83 82       	std	Z+3, r8	; 0x03
		jsonDataAirT2 [len+4] = '0';
    211c:	b4 82       	std	Z+4, r11	; 0x04
		jsonDataAirT2 [len+5] = '0';
    211e:	b5 82       	std	Z+5, r11	; 0x05
		
	jsonDataAirT2 [len+6] = '}';
    2120:	96 82       	std	Z+6, r9	; 0x06
	
	jsonDataAirT2 [len+7] = '\n';
    2122:	67 82       	std	Z+7, r6	; 0x07
	jsonDataAirT2 [len+8] = '\0';
    2124:	10 86       	std	Z+8, r1	; 0x08
                         ( TickType_t ) 10 ) == pdPASS )
						 
			{
				LCD_goToXY(6,2);
				char *jsonDataAir = convertAndWriteAir(air);
				vTaskDelay(pdMS_TO_TICKS(10));
    2126:	8a e0       	ldi	r24, 0x0A	; 10
    2128:	90 e0       	ldi	r25, 0x00	; 0
    212a:	0e 94 9f 08 	call	0x113e	; 0x113e <vTaskDelay>
				UART_sendString(jsonDataAir);
    212e:	c7 01       	movw	r24, r14
    2130:	0e 94 e5 0c 	call	0x19ca	; 0x19ca <UART_sendString>
				vTaskDelay(pdMS_TO_TICKS(10));
    2134:	8a e0       	ldi	r24, 0x0A	; 10
    2136:	90 e0       	ldi	r25, 0x00	; 0
    2138:	0e 94 9f 08 	call	0x113e	; 0x113e <vTaskDelay>
				free(jsonDataAir);
    213c:	c7 01       	movw	r24, r14
    213e:	0e 94 cc 14 	call	0x2998	; 0x2998 <free>
				vTaskDelay(pdMS_TO_TICKS(10));
    2142:	8a e0       	ldi	r24, 0x0A	; 10
    2144:	90 e0       	ldi	r25, 0x00	; 0
    2146:	0e 94 9f 08 	call	0x113e	; 0x113e <vTaskDelay>
    214a:	33 cf       	rjmp	.-410    	; 0x1fb2 <airSendTask+0x42>

0000214c <vTimerCallback>:
	}//for
}//airSendTask

void vTimerCallback(TimerHandle_t xTimerReadings)
 {
	vTaskResume (temperatureReadTaskHandle);
    214c:	80 91 a1 08 	lds	r24, 0x08A1	; 0x8008a1 <temperatureReadTaskHandle>
    2150:	90 91 a2 08 	lds	r25, 0x08A2	; 0x8008a2 <temperatureReadTaskHandle+0x1>
    2154:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <vTaskResume>
	vTaskResume (AirReadTaskHandle);  
    2158:	80 91 9d 08 	lds	r24, 0x089D	; 0x80089d <AirReadTaskHandle>
    215c:	90 91 9e 08 	lds	r25, 0x089E	; 0x80089e <AirReadTaskHandle+0x1>
    2160:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <vTaskResume>
    2164:	08 95       	ret

00002166 <main>:
 }
 
// MAIN PROGRAM
int main(void)
{
	alarmState = OFF;
    2166:	81 e0       	ldi	r24, 0x01	; 1
    2168:	80 93 a5 08 	sts	0x08A5, r24	; 0x8008a5 <alarmState>
	stateBuzzer = OFF;
    216c:	80 93 88 08 	sts	0x0888, r24	; 0x800888 <stateBuzzer>
	stateFan = OFF;
    2170:	80 93 a6 08 	sts	0x08A6, r24	; 0x8008a6 <stateFan>
}
*/

static void LCD_init()
{
  LCD_DDDR |= 0xF0;
    2174:	8a b1       	in	r24, 0x0a	; 10
    2176:	80 6f       	ori	r24, 0xF0	; 240
    2178:	8a b9       	out	0x0a, r24	; 10
  LCD_CDDR |= (1<<LCD_RS)|(1<<LCD_EN);
    217a:	84 b1       	in	r24, 0x04	; 4
    217c:	83 60       	ori	r24, 0x03	; 3
    217e:	84 b9       	out	0x04, r24	; 4
 
  LCD_CPRT &=~(1<<LCD_EN);  //LCD_EN = 0
    2180:	29 98       	cbi	0x05, 1	; 5
    2182:	8f e3       	ldi	r24, 0x3F	; 63
    2184:	9f e1       	ldi	r25, 0x1F	; 31
    2186:	01 97       	sbiw	r24, 0x01	; 1
    2188:	f1 f7       	brne	.-4      	; 0x2186 <main+0x20>
    218a:	00 c0       	rjmp	.+0      	; 0x218c <main+0x26>
    218c:	00 00       	nop
  _delay_us(2000);      //wait for init.

  LCD_sendCommand(0x33); //send $33 for init.
    218e:	83 e3       	ldi	r24, 0x33	; 51
    2190:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <LCD_sendCommand>
  LCD_sendCommand(0x32); //send $32 for init
    2194:	82 e3       	ldi	r24, 0x32	; 50
    2196:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <LCD_sendCommand>
  LCD_sendCommand(0x28); //init. LCD 2 line,5*7 matrix
    219a:	88 e2       	ldi	r24, 0x28	; 40
    219c:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <LCD_sendCommand>
  LCD_sendCommand(0x0C); //display on, cursor on
    21a0:	8c e0       	ldi	r24, 0x0C	; 12
    21a2:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <LCD_sendCommand>
  LCD_sendCommand(0x06); //shift cursor right
    21a6:	86 e0       	ldi	r24, 0x06	; 6
    21a8:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <LCD_sendCommand>
  LCD_putValue(data);  
}

static void LCD_clear()
{
  LCD_sendCommand(0x01);
    21ac:	81 e0       	ldi	r24, 0x01	; 1
    21ae:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <LCD_sendCommand>
    21b2:	8f e8       	ldi	r24, 0x8F	; 143
    21b4:	9a e1       	ldi	r25, 0x1A	; 26
    21b6:	01 97       	sbiw	r24, 0x01	; 1
    21b8:	f1 f7       	brne	.-4      	; 0x21b6 <main+0x50>
    21ba:	00 c0       	rjmp	.+0      	; 0x21bc <main+0x56>
    21bc:	00 00       	nop
    21be:	c0 e0       	ldi	r28, 0x00	; 0
    21c0:	84 e5       	ldi	r24, 0x54	; 84
{
  unsigned char i = 0;

  while(str[i] != 0) //while it is not end of string
  {
    LCD_sendData(str[i]);
    21c2:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <LCD_sendData>
    i++ ;
    21c6:	cf 5f       	subi	r28, 0xFF	; 255

static void LCD_print( char * str )
{
  unsigned char i = 0;

  while(str[i] != 0) //while it is not end of string
    21c8:	ec 2f       	mov	r30, r28
    21ca:	f0 e0       	ldi	r31, 0x00	; 0
    21cc:	ed 5d       	subi	r30, 0xDD	; 221
    21ce:	fd 4f       	sbci	r31, 0xFD	; 253
    21d0:	80 81       	ld	r24, Z
    21d2:	81 11       	cpse	r24, r1
    21d4:	f6 cf       	rjmp	.-20     	; 0x21c2 <main+0x5c>
	stateFan = OFF;
	
	LCD_init();
	
	LCD_print("Temp:");
	LCD_goToXY(1,2);
    21d6:	62 e0       	ldi	r22, 0x02	; 2
    21d8:	81 e0       	ldi	r24, 0x01	; 1
    21da:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <LCD_goToXY>
    21de:	c0 e0       	ldi	r28, 0x00	; 0
    21e0:	81 e4       	ldi	r24, 0x41	; 65
{
  unsigned char i = 0;

  while(str[i] != 0) //while it is not end of string
  {
    LCD_sendData(str[i]);
    21e2:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <LCD_sendData>
    i++ ;
    21e6:	cf 5f       	subi	r28, 0xFF	; 255

static void LCD_print( char * str )
{
  unsigned char i = 0;

  while(str[i] != 0) //while it is not end of string
    21e8:	ec 2f       	mov	r30, r28
    21ea:	f0 e0       	ldi	r31, 0x00	; 0
    21ec:	e7 5d       	subi	r30, 0xD7	; 215
    21ee:	fd 4f       	sbci	r31, 0xFD	; 253
    21f0:	80 81       	ld	r24, Z
    21f2:	81 11       	cpse	r24, r1
    21f4:	f6 cf       	rjmp	.-20     	; 0x21e2 <main+0x7c>
		}

static void UART_init()
{
	// Imposta la velocit di trasmissione
	UBRR0H = (BAUD_PRESCALER >> 8);
    21f6:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
	UBRR0L = BAUD_PRESCALER;
    21fa:	87 e6       	ldi	r24, 0x67	; 103
    21fc:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
	
	// Abilita la trasmissione e la ricezione
	UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
    2200:	88 e9       	ldi	r24, 0x98	; 152
    2202:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
	
	// Imposta il formato dei dati: 8 bit di dati, 1 bit di stop
	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);
    2206:	86 e0       	ldi	r24, 0x06	; 6
    2208:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__DATA_REGION_ORIGIN__+0x62>
  }
}

static void portInit (void){
	
	DDRC = 0; //make Porct C an input for ADC input
    220c:	17 b8       	out	0x07, r1	; 7
	DDRD = 0xFF;
    220e:	8f ef       	ldi	r24, 0xFF	; 255
    2210:	8a b9       	out	0x0a, r24	; 10
	DDRD |= (1<<PD3);
    2212:	53 9a       	sbi	0x0a, 3	; 10
	DDRB |= (1 << 3) | (1 << 2) | (1 << 4);
    2214:	84 b1       	in	r24, 0x04	; 4
    2216:	8c 61       	ori	r24, 0x1C	; 28
    2218:	84 b9       	out	0x04, r24	; 4

	UART_init();
	
	portInit();
	
	xTimerReadings = xTimerCreate ("Timer", pdMS_TO_TICKS( 1000 ), pdTRUE, ( void * ) 0, vTimerCallback);
    221a:	06 ea       	ldi	r16, 0xA6	; 166
    221c:	10 e1       	ldi	r17, 0x10	; 16
    221e:	20 e0       	ldi	r18, 0x00	; 0
    2220:	30 e0       	ldi	r19, 0x00	; 0
    2222:	41 e0       	ldi	r20, 0x01	; 1
    2224:	60 e1       	ldi	r22, 0x10	; 16
    2226:	70 e0       	ldi	r23, 0x00	; 0
    2228:	8e e2       	ldi	r24, 0x2E	; 46
    222a:	92 e0       	ldi	r25, 0x02	; 2
    222c:	0e 94 ef 0a 	call	0x15de	; 0x15de <xTimerCreate>
    2230:	90 93 8a 08 	sts	0x088A, r25	; 0x80088a <xTimerReadings+0x1>
    2234:	80 93 89 08 	sts	0x0889, r24	; 0x800889 <xTimerReadings>

         if( xTimerReadings == NULL )
    2238:	89 2b       	or	r24, r25
    223a:	71 f0       	breq	.+28     	; 0x2258 <main+0xf2>
         else
         {
             /* Start the timer.  No block time is specified, and
             even if one was it would be ignored because the RTOS
             scheduler has not yet been started. */
             if( xTimerStart( xTimerReadings, 0) != pdPASS )
    223c:	0e 94 5b 07 	call	0xeb6	; 0xeb6 <xTaskGetTickCount>
    2240:	00 e0       	ldi	r16, 0x00	; 0
    2242:	10 e0       	ldi	r17, 0x00	; 0
    2244:	20 e0       	ldi	r18, 0x00	; 0
    2246:	30 e0       	ldi	r19, 0x00	; 0
    2248:	ac 01       	movw	r20, r24
    224a:	61 e0       	ldi	r22, 0x01	; 1
    224c:	80 91 89 08 	lds	r24, 0x0889	; 0x800889 <xTimerReadings>
    2250:	90 91 8a 08 	lds	r25, 0x088A	; 0x80088a <xTimerReadings+0x1>
    2254:	0e 94 21 0b 	call	0x1642	; 0x1642 <xTimerGenericCommand>
                 state. */
             }
         }
	
    // Attempt to create a semaphore.
    xSemaphoreADC = xSemaphoreCreateBinary();
    2258:	43 e0       	ldi	r20, 0x03	; 3
    225a:	60 e0       	ldi	r22, 0x00	; 0
    225c:	81 e0       	ldi	r24, 0x01	; 1
    225e:	0e 94 6d 03 	call	0x6da	; 0x6da <xQueueGenericCreate>
    2262:	90 93 9a 08 	sts	0x089A, r25	; 0x80089a <xSemaphoreADC+0x1>
    2266:	80 93 99 08 	sts	0x0899, r24	; 0x800899 <xSemaphoreADC>

	xSemaphoreGive(xSemaphoreADC);
    226a:	20 e0       	ldi	r18, 0x00	; 0
    226c:	40 e0       	ldi	r20, 0x00	; 0
    226e:	50 e0       	ldi	r21, 0x00	; 0
    2270:	60 e0       	ldi	r22, 0x00	; 0
    2272:	70 e0       	ldi	r23, 0x00	; 0
    2274:	0e 94 9a 03 	call	0x734	; 0x734 <xQueueGenericSend>

	
	xCharQueue = xQueueCreate( 2, sizeof( char * ) );
    2278:	40 e0       	ldi	r20, 0x00	; 0
    227a:	62 e0       	ldi	r22, 0x02	; 2
    227c:	82 e0       	ldi	r24, 0x02	; 2
    227e:	0e 94 6d 03 	call	0x6da	; 0x6da <xQueueGenericCreate>
    2282:	90 93 a0 08 	sts	0x08A0, r25	; 0x8008a0 <xCharQueue+0x1>
    2286:	80 93 9f 08 	sts	0x089F, r24	; 0x80089f <xCharQueue>
	
	xQueueAirSendings = xQueueCreate( 2, sizeof (float) );
    228a:	40 e0       	ldi	r20, 0x00	; 0
    228c:	64 e0       	ldi	r22, 0x04	; 4
    228e:	82 e0       	ldi	r24, 0x02	; 2
    2290:	0e 94 6d 03 	call	0x6da	; 0x6da <xQueueGenericCreate>
    2294:	90 93 a4 08 	sts	0x08A4, r25	; 0x8008a4 <xQueueAirSendings+0x1>
    2298:	80 93 a3 08 	sts	0x08A3, r24	; 0x8008a3 <xQueueAirSendings>
	xQueueTemperatureSendings = xQueueCreate( 2, sizeof (float) );
    229c:	40 e0       	ldi	r20, 0x00	; 0
    229e:	64 e0       	ldi	r22, 0x04	; 4
    22a0:	82 e0       	ldi	r24, 0x02	; 2
    22a2:	0e 94 6d 03 	call	0x6da	; 0x6da <xQueueGenericCreate>
    22a6:	90 93 90 08 	sts	0x0890, r25	; 0x800890 <xQueueTemperatureSendings+0x1>
    22aa:	80 93 8f 08 	sts	0x088F, r24	; 0x80088f <xQueueTemperatureSendings>
			
	xTaskCreate(serialFromISRTask, "serialFromISRTask", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, &serialFromISRTaskHandle);
    22ae:	0f 2e       	mov	r0, r31
    22b0:	fb e9       	ldi	r31, 0x9B	; 155
    22b2:	ef 2e       	mov	r14, r31
    22b4:	f8 e0       	ldi	r31, 0x08	; 8
    22b6:	ff 2e       	mov	r15, r31
    22b8:	f0 2d       	mov	r31, r0
    22ba:	00 e0       	ldi	r16, 0x00	; 0
    22bc:	20 e0       	ldi	r18, 0x00	; 0
    22be:	30 e0       	ldi	r19, 0x00	; 0
    22c0:	45 e5       	ldi	r20, 0x55	; 85
    22c2:	50 e0       	ldi	r21, 0x00	; 0
    22c4:	64 e3       	ldi	r22, 0x34	; 52
    22c6:	72 e0       	ldi	r23, 0x02	; 2
    22c8:	85 e2       	ldi	r24, 0x25	; 37
    22ca:	9d e0       	ldi	r25, 0x0D	; 13
    22cc:	0e 94 cb 05 	call	0xb96	; 0xb96 <xTaskCreate>
	
	xTaskCreate(temperatureReadTask, "temperatureReadTask", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, &temperatureReadTaskHandle);
    22d0:	0f 2e       	mov	r0, r31
    22d2:	f1 ea       	ldi	r31, 0xA1	; 161
    22d4:	ef 2e       	mov	r14, r31
    22d6:	f8 e0       	ldi	r31, 0x08	; 8
    22d8:	ff 2e       	mov	r15, r31
    22da:	f0 2d       	mov	r31, r0
    22dc:	20 e0       	ldi	r18, 0x00	; 0
    22de:	30 e0       	ldi	r19, 0x00	; 0
    22e0:	45 e5       	ldi	r20, 0x55	; 85
    22e2:	50 e0       	ldi	r21, 0x00	; 0
    22e4:	66 e4       	ldi	r22, 0x46	; 70
    22e6:	72 e0       	ldi	r23, 0x02	; 2
    22e8:	80 e8       	ldi	r24, 0x80	; 128
    22ea:	9d e0       	ldi	r25, 0x0D	; 13
    22ec:	0e 94 cb 05 	call	0xb96	; 0xb96 <xTaskCreate>
	
	xTaskCreate(temperatureSendTask, "temperatureSendTask", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, &temperatureSendTaskHandle);
    22f0:	0f 2e       	mov	r0, r31
    22f2:	f1 e9       	ldi	r31, 0x91	; 145
    22f4:	ef 2e       	mov	r14, r31
    22f6:	f8 e0       	ldi	r31, 0x08	; 8
    22f8:	ff 2e       	mov	r15, r31
    22fa:	f0 2d       	mov	r31, r0
    22fc:	20 e0       	ldi	r18, 0x00	; 0
    22fe:	30 e0       	ldi	r19, 0x00	; 0
    2300:	45 e5       	ldi	r20, 0x55	; 85
    2302:	50 e0       	ldi	r21, 0x00	; 0
    2304:	6a e5       	ldi	r22, 0x5A	; 90
    2306:	72 e0       	ldi	r23, 0x02	; 2
    2308:	84 ea       	ldi	r24, 0xA4	; 164
    230a:	9e e0       	ldi	r25, 0x0E	; 14
    230c:	0e 94 cb 05 	call	0xb96	; 0xb96 <xTaskCreate>
	
	xTaskCreate(airReadTask, "airReadTask", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, &temperatureReadTaskHandle);
    2310:	0f 2e       	mov	r0, r31
    2312:	f1 ea       	ldi	r31, 0xA1	; 161
    2314:	ef 2e       	mov	r14, r31
    2316:	f8 e0       	ldi	r31, 0x08	; 8
    2318:	ff 2e       	mov	r15, r31
    231a:	f0 2d       	mov	r31, r0
    231c:	20 e0       	ldi	r18, 0x00	; 0
    231e:	30 e0       	ldi	r19, 0x00	; 0
    2320:	45 e5       	ldi	r20, 0x55	; 85
    2322:	50 e0       	ldi	r21, 0x00	; 0
    2324:	6e e6       	ldi	r22, 0x6E	; 110
    2326:	72 e0       	ldi	r23, 0x02	; 2
    2328:	81 ef       	ldi	r24, 0xF1	; 241
    232a:	9d e0       	ldi	r25, 0x0D	; 13
    232c:	0e 94 cb 05 	call	0xb96	; 0xb96 <xTaskCreate>
	
	xTaskCreate(airSendTask, "airSendTask", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, &AirSendTaskHandle);
    2330:	0f 2e       	mov	r0, r31
    2332:	f3 e9       	ldi	r31, 0x93	; 147
    2334:	ef 2e       	mov	r14, r31
    2336:	f8 e0       	ldi	r31, 0x08	; 8
    2338:	ff 2e       	mov	r15, r31
    233a:	f0 2d       	mov	r31, r0
    233c:	20 e0       	ldi	r18, 0x00	; 0
    233e:	30 e0       	ldi	r19, 0x00	; 0
    2340:	45 e5       	ldi	r20, 0x55	; 85
    2342:	50 e0       	ldi	r21, 0x00	; 0
    2344:	6a e7       	ldi	r22, 0x7A	; 122
    2346:	72 e0       	ldi	r23, 0x02	; 2
    2348:	88 eb       	ldi	r24, 0xB8	; 184
    234a:	9f e0       	ldi	r25, 0x0F	; 15
    234c:	0e 94 cb 05 	call	0xb96	; 0xb96 <xTaskCreate>
	
	sei();
    2350:	78 94       	sei
	
	// START SCHELUDER
	vTaskStartScheduler();
    2352:	0e 94 27 07 	call	0xe4e	; 0xe4e <vTaskStartScheduler>
    2356:	ff cf       	rjmp	.-2      	; 0x2356 <main+0x1f0>

00002358 <vApplicationIdleHook>:

}

// IDLE TASK
void vApplicationIdleHook(void)
{
    2358:	08 95       	ret

0000235a <__vector_18>:


/* ----------------------------------- ISR -------------------------------------*/

//INTERRUPT SERVICE ROUTINE
ISR (USART_RX_vect) {
    235a:	1f 92       	push	r1
    235c:	0f 92       	push	r0
    235e:	0f b6       	in	r0, 0x3f	; 63
    2360:	0f 92       	push	r0
    2362:	11 24       	eor	r1, r1
    2364:	2f 93       	push	r18
    2366:	3f 93       	push	r19
    2368:	4f 93       	push	r20
    236a:	5f 93       	push	r21
    236c:	6f 93       	push	r22
    236e:	7f 93       	push	r23
    2370:	8f 93       	push	r24
    2372:	9f 93       	push	r25
    2374:	af 93       	push	r26
    2376:	bf 93       	push	r27
    2378:	ef 93       	push	r30
    237a:	ff 93       	push	r31
    237c:	cf 93       	push	r28
    237e:	df 93       	push	r29
    2380:	00 d0       	rcall	.+0      	; 0x2382 <__vector_18+0x28>
    2382:	cd b7       	in	r28, 0x3d	; 61
    2384:	de b7       	in	r29, 0x3e	; 62
	
	signed char cChar;
	
	cChar = UDR0;
    2386:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
    238a:	89 83       	std	Y+1, r24	; 0x01
	
	
	//Due righe che servono sempre per lo YIELD delle task di FREERTOS
	BaseType_t xHigherPriorityTaskWoken;
	xHigherPriorityTaskWoken = pdFALSE;
    238c:	1a 82       	std	Y+2, r1	; 0x02
	
	//La coda serve per scambiare messaggi tra le task.
	//Penso che per altre task si possa utilizzare anche il suspend ed il resume.
	xQueueSendFromISR( xCharQueue, &cChar, &xHigherPriorityTaskWoken );
    238e:	20 e0       	ldi	r18, 0x00	; 0
    2390:	ae 01       	movw	r20, r28
    2392:	4e 5f       	subi	r20, 0xFE	; 254
    2394:	5f 4f       	sbci	r21, 0xFF	; 255
    2396:	be 01       	movw	r22, r28
    2398:	6f 5f       	subi	r22, 0xFF	; 255
    239a:	7f 4f       	sbci	r23, 0xFF	; 255
    239c:	80 91 9f 08 	lds	r24, 0x089F	; 0x80089f <xCharQueue>
    23a0:	90 91 a0 08 	lds	r25, 0x08A0	; 0x8008a0 <xCharQueue+0x1>
    23a4:	0e 94 3b 04 	call	0x876	; 0x876 <xQueueGenericSendFromISR>
	
	//Serve sempre per lo yield. Sulla documentazione  scritto come un'altra funzione, ma per atmega328p  questa.
	if( xHigherPriorityTaskWoken != pdFALSE ) {
    23a8:	8a 81       	ldd	r24, Y+2	; 0x02
    23aa:	81 11       	cpse	r24, r1
		taskYIELD();
    23ac:	0e 94 c9 01 	call	0x392	; 0x392 <vPortYield>
	}
		
    23b0:	0f 90       	pop	r0
    23b2:	0f 90       	pop	r0
    23b4:	df 91       	pop	r29
    23b6:	cf 91       	pop	r28
    23b8:	ff 91       	pop	r31
    23ba:	ef 91       	pop	r30
    23bc:	bf 91       	pop	r27
    23be:	af 91       	pop	r26
    23c0:	9f 91       	pop	r25
    23c2:	8f 91       	pop	r24
    23c4:	7f 91       	pop	r23
    23c6:	6f 91       	pop	r22
    23c8:	5f 91       	pop	r21
    23ca:	4f 91       	pop	r20
    23cc:	3f 91       	pop	r19
    23ce:	2f 91       	pop	r18
    23d0:	0f 90       	pop	r0
    23d2:	0f be       	out	0x3f, r0	; 63
    23d4:	0f 90       	pop	r0
    23d6:	1f 90       	pop	r1
    23d8:	18 95       	reti

000023da <__subsf3>:
    23da:	50 58       	subi	r21, 0x80	; 128

000023dc <__addsf3>:
    23dc:	bb 27       	eor	r27, r27
    23de:	aa 27       	eor	r26, r26
    23e0:	0e 94 05 12 	call	0x240a	; 0x240a <__addsf3x>
    23e4:	0c 94 4f 13 	jmp	0x269e	; 0x269e <__fp_round>
    23e8:	0e 94 41 13 	call	0x2682	; 0x2682 <__fp_pscA>
    23ec:	38 f0       	brcs	.+14     	; 0x23fc <__addsf3+0x20>
    23ee:	0e 94 48 13 	call	0x2690	; 0x2690 <__fp_pscB>
    23f2:	20 f0       	brcs	.+8      	; 0x23fc <__addsf3+0x20>
    23f4:	39 f4       	brne	.+14     	; 0x2404 <__addsf3+0x28>
    23f6:	9f 3f       	cpi	r25, 0xFF	; 255
    23f8:	19 f4       	brne	.+6      	; 0x2400 <__addsf3+0x24>
    23fa:	26 f4       	brtc	.+8      	; 0x2404 <__addsf3+0x28>
    23fc:	0c 94 3e 13 	jmp	0x267c	; 0x267c <__fp_nan>
    2400:	0e f4       	brtc	.+2      	; 0x2404 <__addsf3+0x28>
    2402:	e0 95       	com	r30
    2404:	e7 fb       	bst	r30, 7
    2406:	0c 94 38 13 	jmp	0x2670	; 0x2670 <__fp_inf>

0000240a <__addsf3x>:
    240a:	e9 2f       	mov	r30, r25
    240c:	0e 94 60 13 	call	0x26c0	; 0x26c0 <__fp_split3>
    2410:	58 f3       	brcs	.-42     	; 0x23e8 <__addsf3+0xc>
    2412:	ba 17       	cp	r27, r26
    2414:	62 07       	cpc	r22, r18
    2416:	73 07       	cpc	r23, r19
    2418:	84 07       	cpc	r24, r20
    241a:	95 07       	cpc	r25, r21
    241c:	20 f0       	brcs	.+8      	; 0x2426 <__addsf3x+0x1c>
    241e:	79 f4       	brne	.+30     	; 0x243e <__addsf3x+0x34>
    2420:	a6 f5       	brtc	.+104    	; 0x248a <__addsf3x+0x80>
    2422:	0c 94 82 13 	jmp	0x2704	; 0x2704 <__fp_zero>
    2426:	0e f4       	brtc	.+2      	; 0x242a <__addsf3x+0x20>
    2428:	e0 95       	com	r30
    242a:	0b 2e       	mov	r0, r27
    242c:	ba 2f       	mov	r27, r26
    242e:	a0 2d       	mov	r26, r0
    2430:	0b 01       	movw	r0, r22
    2432:	b9 01       	movw	r22, r18
    2434:	90 01       	movw	r18, r0
    2436:	0c 01       	movw	r0, r24
    2438:	ca 01       	movw	r24, r20
    243a:	a0 01       	movw	r20, r0
    243c:	11 24       	eor	r1, r1
    243e:	ff 27       	eor	r31, r31
    2440:	59 1b       	sub	r21, r25
    2442:	99 f0       	breq	.+38     	; 0x246a <__addsf3x+0x60>
    2444:	59 3f       	cpi	r21, 0xF9	; 249
    2446:	50 f4       	brcc	.+20     	; 0x245c <__addsf3x+0x52>
    2448:	50 3e       	cpi	r21, 0xE0	; 224
    244a:	68 f1       	brcs	.+90     	; 0x24a6 <__addsf3x+0x9c>
    244c:	1a 16       	cp	r1, r26
    244e:	f0 40       	sbci	r31, 0x00	; 0
    2450:	a2 2f       	mov	r26, r18
    2452:	23 2f       	mov	r18, r19
    2454:	34 2f       	mov	r19, r20
    2456:	44 27       	eor	r20, r20
    2458:	58 5f       	subi	r21, 0xF8	; 248
    245a:	f3 cf       	rjmp	.-26     	; 0x2442 <__addsf3x+0x38>
    245c:	46 95       	lsr	r20
    245e:	37 95       	ror	r19
    2460:	27 95       	ror	r18
    2462:	a7 95       	ror	r26
    2464:	f0 40       	sbci	r31, 0x00	; 0
    2466:	53 95       	inc	r21
    2468:	c9 f7       	brne	.-14     	; 0x245c <__addsf3x+0x52>
    246a:	7e f4       	brtc	.+30     	; 0x248a <__addsf3x+0x80>
    246c:	1f 16       	cp	r1, r31
    246e:	ba 0b       	sbc	r27, r26
    2470:	62 0b       	sbc	r22, r18
    2472:	73 0b       	sbc	r23, r19
    2474:	84 0b       	sbc	r24, r20
    2476:	ba f0       	brmi	.+46     	; 0x24a6 <__addsf3x+0x9c>
    2478:	91 50       	subi	r25, 0x01	; 1
    247a:	a1 f0       	breq	.+40     	; 0x24a4 <__addsf3x+0x9a>
    247c:	ff 0f       	add	r31, r31
    247e:	bb 1f       	adc	r27, r27
    2480:	66 1f       	adc	r22, r22
    2482:	77 1f       	adc	r23, r23
    2484:	88 1f       	adc	r24, r24
    2486:	c2 f7       	brpl	.-16     	; 0x2478 <__addsf3x+0x6e>
    2488:	0e c0       	rjmp	.+28     	; 0x24a6 <__addsf3x+0x9c>
    248a:	ba 0f       	add	r27, r26
    248c:	62 1f       	adc	r22, r18
    248e:	73 1f       	adc	r23, r19
    2490:	84 1f       	adc	r24, r20
    2492:	48 f4       	brcc	.+18     	; 0x24a6 <__addsf3x+0x9c>
    2494:	87 95       	ror	r24
    2496:	77 95       	ror	r23
    2498:	67 95       	ror	r22
    249a:	b7 95       	ror	r27
    249c:	f7 95       	ror	r31
    249e:	9e 3f       	cpi	r25, 0xFE	; 254
    24a0:	08 f0       	brcs	.+2      	; 0x24a4 <__addsf3x+0x9a>
    24a2:	b0 cf       	rjmp	.-160    	; 0x2404 <__addsf3+0x28>
    24a4:	93 95       	inc	r25
    24a6:	88 0f       	add	r24, r24
    24a8:	08 f0       	brcs	.+2      	; 0x24ac <__addsf3x+0xa2>
    24aa:	99 27       	eor	r25, r25
    24ac:	ee 0f       	add	r30, r30
    24ae:	97 95       	ror	r25
    24b0:	87 95       	ror	r24
    24b2:	08 95       	ret

000024b4 <__divsf3>:
    24b4:	0e 94 6e 12 	call	0x24dc	; 0x24dc <__divsf3x>
    24b8:	0c 94 4f 13 	jmp	0x269e	; 0x269e <__fp_round>
    24bc:	0e 94 48 13 	call	0x2690	; 0x2690 <__fp_pscB>
    24c0:	58 f0       	brcs	.+22     	; 0x24d8 <__divsf3+0x24>
    24c2:	0e 94 41 13 	call	0x2682	; 0x2682 <__fp_pscA>
    24c6:	40 f0       	brcs	.+16     	; 0x24d8 <__divsf3+0x24>
    24c8:	29 f4       	brne	.+10     	; 0x24d4 <__divsf3+0x20>
    24ca:	5f 3f       	cpi	r21, 0xFF	; 255
    24cc:	29 f0       	breq	.+10     	; 0x24d8 <__divsf3+0x24>
    24ce:	0c 94 38 13 	jmp	0x2670	; 0x2670 <__fp_inf>
    24d2:	51 11       	cpse	r21, r1
    24d4:	0c 94 83 13 	jmp	0x2706	; 0x2706 <__fp_szero>
    24d8:	0c 94 3e 13 	jmp	0x267c	; 0x267c <__fp_nan>

000024dc <__divsf3x>:
    24dc:	0e 94 60 13 	call	0x26c0	; 0x26c0 <__fp_split3>
    24e0:	68 f3       	brcs	.-38     	; 0x24bc <__divsf3+0x8>

000024e2 <__divsf3_pse>:
    24e2:	99 23       	and	r25, r25
    24e4:	b1 f3       	breq	.-20     	; 0x24d2 <__divsf3+0x1e>
    24e6:	55 23       	and	r21, r21
    24e8:	91 f3       	breq	.-28     	; 0x24ce <__divsf3+0x1a>
    24ea:	95 1b       	sub	r25, r21
    24ec:	55 0b       	sbc	r21, r21
    24ee:	bb 27       	eor	r27, r27
    24f0:	aa 27       	eor	r26, r26
    24f2:	62 17       	cp	r22, r18
    24f4:	73 07       	cpc	r23, r19
    24f6:	84 07       	cpc	r24, r20
    24f8:	38 f0       	brcs	.+14     	; 0x2508 <__divsf3_pse+0x26>
    24fa:	9f 5f       	subi	r25, 0xFF	; 255
    24fc:	5f 4f       	sbci	r21, 0xFF	; 255
    24fe:	22 0f       	add	r18, r18
    2500:	33 1f       	adc	r19, r19
    2502:	44 1f       	adc	r20, r20
    2504:	aa 1f       	adc	r26, r26
    2506:	a9 f3       	breq	.-22     	; 0x24f2 <__divsf3_pse+0x10>
    2508:	35 d0       	rcall	.+106    	; 0x2574 <__divsf3_pse+0x92>
    250a:	0e 2e       	mov	r0, r30
    250c:	3a f0       	brmi	.+14     	; 0x251c <__divsf3_pse+0x3a>
    250e:	e0 e8       	ldi	r30, 0x80	; 128
    2510:	32 d0       	rcall	.+100    	; 0x2576 <__divsf3_pse+0x94>
    2512:	91 50       	subi	r25, 0x01	; 1
    2514:	50 40       	sbci	r21, 0x00	; 0
    2516:	e6 95       	lsr	r30
    2518:	00 1c       	adc	r0, r0
    251a:	ca f7       	brpl	.-14     	; 0x250e <__divsf3_pse+0x2c>
    251c:	2b d0       	rcall	.+86     	; 0x2574 <__divsf3_pse+0x92>
    251e:	fe 2f       	mov	r31, r30
    2520:	29 d0       	rcall	.+82     	; 0x2574 <__divsf3_pse+0x92>
    2522:	66 0f       	add	r22, r22
    2524:	77 1f       	adc	r23, r23
    2526:	88 1f       	adc	r24, r24
    2528:	bb 1f       	adc	r27, r27
    252a:	26 17       	cp	r18, r22
    252c:	37 07       	cpc	r19, r23
    252e:	48 07       	cpc	r20, r24
    2530:	ab 07       	cpc	r26, r27
    2532:	b0 e8       	ldi	r27, 0x80	; 128
    2534:	09 f0       	breq	.+2      	; 0x2538 <__divsf3_pse+0x56>
    2536:	bb 0b       	sbc	r27, r27
    2538:	80 2d       	mov	r24, r0
    253a:	bf 01       	movw	r22, r30
    253c:	ff 27       	eor	r31, r31
    253e:	93 58       	subi	r25, 0x83	; 131
    2540:	5f 4f       	sbci	r21, 0xFF	; 255
    2542:	3a f0       	brmi	.+14     	; 0x2552 <__divsf3_pse+0x70>
    2544:	9e 3f       	cpi	r25, 0xFE	; 254
    2546:	51 05       	cpc	r21, r1
    2548:	78 f0       	brcs	.+30     	; 0x2568 <__divsf3_pse+0x86>
    254a:	0c 94 38 13 	jmp	0x2670	; 0x2670 <__fp_inf>
    254e:	0c 94 83 13 	jmp	0x2706	; 0x2706 <__fp_szero>
    2552:	5f 3f       	cpi	r21, 0xFF	; 255
    2554:	e4 f3       	brlt	.-8      	; 0x254e <__divsf3_pse+0x6c>
    2556:	98 3e       	cpi	r25, 0xE8	; 232
    2558:	d4 f3       	brlt	.-12     	; 0x254e <__divsf3_pse+0x6c>
    255a:	86 95       	lsr	r24
    255c:	77 95       	ror	r23
    255e:	67 95       	ror	r22
    2560:	b7 95       	ror	r27
    2562:	f7 95       	ror	r31
    2564:	9f 5f       	subi	r25, 0xFF	; 255
    2566:	c9 f7       	brne	.-14     	; 0x255a <__divsf3_pse+0x78>
    2568:	88 0f       	add	r24, r24
    256a:	91 1d       	adc	r25, r1
    256c:	96 95       	lsr	r25
    256e:	87 95       	ror	r24
    2570:	97 f9       	bld	r25, 7
    2572:	08 95       	ret
    2574:	e1 e0       	ldi	r30, 0x01	; 1
    2576:	66 0f       	add	r22, r22
    2578:	77 1f       	adc	r23, r23
    257a:	88 1f       	adc	r24, r24
    257c:	bb 1f       	adc	r27, r27
    257e:	62 17       	cp	r22, r18
    2580:	73 07       	cpc	r23, r19
    2582:	84 07       	cpc	r24, r20
    2584:	ba 07       	cpc	r27, r26
    2586:	20 f0       	brcs	.+8      	; 0x2590 <__divsf3_pse+0xae>
    2588:	62 1b       	sub	r22, r18
    258a:	73 0b       	sbc	r23, r19
    258c:	84 0b       	sbc	r24, r20
    258e:	ba 0b       	sbc	r27, r26
    2590:	ee 1f       	adc	r30, r30
    2592:	88 f7       	brcc	.-30     	; 0x2576 <__divsf3_pse+0x94>
    2594:	e0 95       	com	r30
    2596:	08 95       	ret

00002598 <__fixunssfsi>:
    2598:	0e 94 68 13 	call	0x26d0	; 0x26d0 <__fp_splitA>
    259c:	88 f0       	brcs	.+34     	; 0x25c0 <__fixunssfsi+0x28>
    259e:	9f 57       	subi	r25, 0x7F	; 127
    25a0:	98 f0       	brcs	.+38     	; 0x25c8 <__fixunssfsi+0x30>
    25a2:	b9 2f       	mov	r27, r25
    25a4:	99 27       	eor	r25, r25
    25a6:	b7 51       	subi	r27, 0x17	; 23
    25a8:	b0 f0       	brcs	.+44     	; 0x25d6 <__fixunssfsi+0x3e>
    25aa:	e1 f0       	breq	.+56     	; 0x25e4 <__fixunssfsi+0x4c>
    25ac:	66 0f       	add	r22, r22
    25ae:	77 1f       	adc	r23, r23
    25b0:	88 1f       	adc	r24, r24
    25b2:	99 1f       	adc	r25, r25
    25b4:	1a f0       	brmi	.+6      	; 0x25bc <__fixunssfsi+0x24>
    25b6:	ba 95       	dec	r27
    25b8:	c9 f7       	brne	.-14     	; 0x25ac <__fixunssfsi+0x14>
    25ba:	14 c0       	rjmp	.+40     	; 0x25e4 <__fixunssfsi+0x4c>
    25bc:	b1 30       	cpi	r27, 0x01	; 1
    25be:	91 f0       	breq	.+36     	; 0x25e4 <__fixunssfsi+0x4c>
    25c0:	0e 94 82 13 	call	0x2704	; 0x2704 <__fp_zero>
    25c4:	b1 e0       	ldi	r27, 0x01	; 1
    25c6:	08 95       	ret
    25c8:	0c 94 82 13 	jmp	0x2704	; 0x2704 <__fp_zero>
    25cc:	67 2f       	mov	r22, r23
    25ce:	78 2f       	mov	r23, r24
    25d0:	88 27       	eor	r24, r24
    25d2:	b8 5f       	subi	r27, 0xF8	; 248
    25d4:	39 f0       	breq	.+14     	; 0x25e4 <__fixunssfsi+0x4c>
    25d6:	b9 3f       	cpi	r27, 0xF9	; 249
    25d8:	cc f3       	brlt	.-14     	; 0x25cc <__fixunssfsi+0x34>
    25da:	86 95       	lsr	r24
    25dc:	77 95       	ror	r23
    25de:	67 95       	ror	r22
    25e0:	b3 95       	inc	r27
    25e2:	d9 f7       	brne	.-10     	; 0x25da <__fixunssfsi+0x42>
    25e4:	3e f4       	brtc	.+14     	; 0x25f4 <__fixunssfsi+0x5c>
    25e6:	90 95       	com	r25
    25e8:	80 95       	com	r24
    25ea:	70 95       	com	r23
    25ec:	61 95       	neg	r22
    25ee:	7f 4f       	sbci	r23, 0xFF	; 255
    25f0:	8f 4f       	sbci	r24, 0xFF	; 255
    25f2:	9f 4f       	sbci	r25, 0xFF	; 255
    25f4:	08 95       	ret

000025f6 <__floatunsisf>:
    25f6:	e8 94       	clt
    25f8:	09 c0       	rjmp	.+18     	; 0x260c <__floatsisf+0x12>

000025fa <__floatsisf>:
    25fa:	97 fb       	bst	r25, 7
    25fc:	3e f4       	brtc	.+14     	; 0x260c <__floatsisf+0x12>
    25fe:	90 95       	com	r25
    2600:	80 95       	com	r24
    2602:	70 95       	com	r23
    2604:	61 95       	neg	r22
    2606:	7f 4f       	sbci	r23, 0xFF	; 255
    2608:	8f 4f       	sbci	r24, 0xFF	; 255
    260a:	9f 4f       	sbci	r25, 0xFF	; 255
    260c:	99 23       	and	r25, r25
    260e:	a9 f0       	breq	.+42     	; 0x263a <__floatsisf+0x40>
    2610:	f9 2f       	mov	r31, r25
    2612:	96 e9       	ldi	r25, 0x96	; 150
    2614:	bb 27       	eor	r27, r27
    2616:	93 95       	inc	r25
    2618:	f6 95       	lsr	r31
    261a:	87 95       	ror	r24
    261c:	77 95       	ror	r23
    261e:	67 95       	ror	r22
    2620:	b7 95       	ror	r27
    2622:	f1 11       	cpse	r31, r1
    2624:	f8 cf       	rjmp	.-16     	; 0x2616 <__floatsisf+0x1c>
    2626:	fa f4       	brpl	.+62     	; 0x2666 <__floatsisf+0x6c>
    2628:	bb 0f       	add	r27, r27
    262a:	11 f4       	brne	.+4      	; 0x2630 <__floatsisf+0x36>
    262c:	60 ff       	sbrs	r22, 0
    262e:	1b c0       	rjmp	.+54     	; 0x2666 <__floatsisf+0x6c>
    2630:	6f 5f       	subi	r22, 0xFF	; 255
    2632:	7f 4f       	sbci	r23, 0xFF	; 255
    2634:	8f 4f       	sbci	r24, 0xFF	; 255
    2636:	9f 4f       	sbci	r25, 0xFF	; 255
    2638:	16 c0       	rjmp	.+44     	; 0x2666 <__floatsisf+0x6c>
    263a:	88 23       	and	r24, r24
    263c:	11 f0       	breq	.+4      	; 0x2642 <__floatsisf+0x48>
    263e:	96 e9       	ldi	r25, 0x96	; 150
    2640:	11 c0       	rjmp	.+34     	; 0x2664 <__floatsisf+0x6a>
    2642:	77 23       	and	r23, r23
    2644:	21 f0       	breq	.+8      	; 0x264e <__floatsisf+0x54>
    2646:	9e e8       	ldi	r25, 0x8E	; 142
    2648:	87 2f       	mov	r24, r23
    264a:	76 2f       	mov	r23, r22
    264c:	05 c0       	rjmp	.+10     	; 0x2658 <__floatsisf+0x5e>
    264e:	66 23       	and	r22, r22
    2650:	71 f0       	breq	.+28     	; 0x266e <__floatsisf+0x74>
    2652:	96 e8       	ldi	r25, 0x86	; 134
    2654:	86 2f       	mov	r24, r22
    2656:	70 e0       	ldi	r23, 0x00	; 0
    2658:	60 e0       	ldi	r22, 0x00	; 0
    265a:	2a f0       	brmi	.+10     	; 0x2666 <__floatsisf+0x6c>
    265c:	9a 95       	dec	r25
    265e:	66 0f       	add	r22, r22
    2660:	77 1f       	adc	r23, r23
    2662:	88 1f       	adc	r24, r24
    2664:	da f7       	brpl	.-10     	; 0x265c <__floatsisf+0x62>
    2666:	88 0f       	add	r24, r24
    2668:	96 95       	lsr	r25
    266a:	87 95       	ror	r24
    266c:	97 f9       	bld	r25, 7
    266e:	08 95       	ret

00002670 <__fp_inf>:
    2670:	97 f9       	bld	r25, 7
    2672:	9f 67       	ori	r25, 0x7F	; 127
    2674:	80 e8       	ldi	r24, 0x80	; 128
    2676:	70 e0       	ldi	r23, 0x00	; 0
    2678:	60 e0       	ldi	r22, 0x00	; 0
    267a:	08 95       	ret

0000267c <__fp_nan>:
    267c:	9f ef       	ldi	r25, 0xFF	; 255
    267e:	80 ec       	ldi	r24, 0xC0	; 192
    2680:	08 95       	ret

00002682 <__fp_pscA>:
    2682:	00 24       	eor	r0, r0
    2684:	0a 94       	dec	r0
    2686:	16 16       	cp	r1, r22
    2688:	17 06       	cpc	r1, r23
    268a:	18 06       	cpc	r1, r24
    268c:	09 06       	cpc	r0, r25
    268e:	08 95       	ret

00002690 <__fp_pscB>:
    2690:	00 24       	eor	r0, r0
    2692:	0a 94       	dec	r0
    2694:	12 16       	cp	r1, r18
    2696:	13 06       	cpc	r1, r19
    2698:	14 06       	cpc	r1, r20
    269a:	05 06       	cpc	r0, r21
    269c:	08 95       	ret

0000269e <__fp_round>:
    269e:	09 2e       	mov	r0, r25
    26a0:	03 94       	inc	r0
    26a2:	00 0c       	add	r0, r0
    26a4:	11 f4       	brne	.+4      	; 0x26aa <__fp_round+0xc>
    26a6:	88 23       	and	r24, r24
    26a8:	52 f0       	brmi	.+20     	; 0x26be <__fp_round+0x20>
    26aa:	bb 0f       	add	r27, r27
    26ac:	40 f4       	brcc	.+16     	; 0x26be <__fp_round+0x20>
    26ae:	bf 2b       	or	r27, r31
    26b0:	11 f4       	brne	.+4      	; 0x26b6 <__fp_round+0x18>
    26b2:	60 ff       	sbrs	r22, 0
    26b4:	04 c0       	rjmp	.+8      	; 0x26be <__fp_round+0x20>
    26b6:	6f 5f       	subi	r22, 0xFF	; 255
    26b8:	7f 4f       	sbci	r23, 0xFF	; 255
    26ba:	8f 4f       	sbci	r24, 0xFF	; 255
    26bc:	9f 4f       	sbci	r25, 0xFF	; 255
    26be:	08 95       	ret

000026c0 <__fp_split3>:
    26c0:	57 fd       	sbrc	r21, 7
    26c2:	90 58       	subi	r25, 0x80	; 128
    26c4:	44 0f       	add	r20, r20
    26c6:	55 1f       	adc	r21, r21
    26c8:	59 f0       	breq	.+22     	; 0x26e0 <__fp_splitA+0x10>
    26ca:	5f 3f       	cpi	r21, 0xFF	; 255
    26cc:	71 f0       	breq	.+28     	; 0x26ea <__fp_splitA+0x1a>
    26ce:	47 95       	ror	r20

000026d0 <__fp_splitA>:
    26d0:	88 0f       	add	r24, r24
    26d2:	97 fb       	bst	r25, 7
    26d4:	99 1f       	adc	r25, r25
    26d6:	61 f0       	breq	.+24     	; 0x26f0 <__fp_splitA+0x20>
    26d8:	9f 3f       	cpi	r25, 0xFF	; 255
    26da:	79 f0       	breq	.+30     	; 0x26fa <__fp_splitA+0x2a>
    26dc:	87 95       	ror	r24
    26de:	08 95       	ret
    26e0:	12 16       	cp	r1, r18
    26e2:	13 06       	cpc	r1, r19
    26e4:	14 06       	cpc	r1, r20
    26e6:	55 1f       	adc	r21, r21
    26e8:	f2 cf       	rjmp	.-28     	; 0x26ce <__fp_split3+0xe>
    26ea:	46 95       	lsr	r20
    26ec:	f1 df       	rcall	.-30     	; 0x26d0 <__fp_splitA>
    26ee:	08 c0       	rjmp	.+16     	; 0x2700 <__fp_splitA+0x30>
    26f0:	16 16       	cp	r1, r22
    26f2:	17 06       	cpc	r1, r23
    26f4:	18 06       	cpc	r1, r24
    26f6:	99 1f       	adc	r25, r25
    26f8:	f1 cf       	rjmp	.-30     	; 0x26dc <__fp_splitA+0xc>
    26fa:	86 95       	lsr	r24
    26fc:	71 05       	cpc	r23, r1
    26fe:	61 05       	cpc	r22, r1
    2700:	08 94       	sec
    2702:	08 95       	ret

00002704 <__fp_zero>:
    2704:	e8 94       	clt

00002706 <__fp_szero>:
    2706:	bb 27       	eor	r27, r27
    2708:	66 27       	eor	r22, r22
    270a:	77 27       	eor	r23, r23
    270c:	cb 01       	movw	r24, r22
    270e:	97 f9       	bld	r25, 7
    2710:	08 95       	ret

00002712 <__gesf2>:
    2712:	0e 94 fb 13 	call	0x27f6	; 0x27f6 <__fp_cmp>
    2716:	08 f4       	brcc	.+2      	; 0x271a <__gesf2+0x8>
    2718:	8f ef       	ldi	r24, 0xFF	; 255
    271a:	08 95       	ret

0000271c <__mulsf3>:
    271c:	0e 94 a1 13 	call	0x2742	; 0x2742 <__mulsf3x>
    2720:	0c 94 4f 13 	jmp	0x269e	; 0x269e <__fp_round>
    2724:	0e 94 41 13 	call	0x2682	; 0x2682 <__fp_pscA>
    2728:	38 f0       	brcs	.+14     	; 0x2738 <__mulsf3+0x1c>
    272a:	0e 94 48 13 	call	0x2690	; 0x2690 <__fp_pscB>
    272e:	20 f0       	brcs	.+8      	; 0x2738 <__mulsf3+0x1c>
    2730:	95 23       	and	r25, r21
    2732:	11 f0       	breq	.+4      	; 0x2738 <__mulsf3+0x1c>
    2734:	0c 94 38 13 	jmp	0x2670	; 0x2670 <__fp_inf>
    2738:	0c 94 3e 13 	jmp	0x267c	; 0x267c <__fp_nan>
    273c:	11 24       	eor	r1, r1
    273e:	0c 94 83 13 	jmp	0x2706	; 0x2706 <__fp_szero>

00002742 <__mulsf3x>:
    2742:	0e 94 60 13 	call	0x26c0	; 0x26c0 <__fp_split3>
    2746:	70 f3       	brcs	.-36     	; 0x2724 <__mulsf3+0x8>

00002748 <__mulsf3_pse>:
    2748:	95 9f       	mul	r25, r21
    274a:	c1 f3       	breq	.-16     	; 0x273c <__mulsf3+0x20>
    274c:	95 0f       	add	r25, r21
    274e:	50 e0       	ldi	r21, 0x00	; 0
    2750:	55 1f       	adc	r21, r21
    2752:	62 9f       	mul	r22, r18
    2754:	f0 01       	movw	r30, r0
    2756:	72 9f       	mul	r23, r18
    2758:	bb 27       	eor	r27, r27
    275a:	f0 0d       	add	r31, r0
    275c:	b1 1d       	adc	r27, r1
    275e:	63 9f       	mul	r22, r19
    2760:	aa 27       	eor	r26, r26
    2762:	f0 0d       	add	r31, r0
    2764:	b1 1d       	adc	r27, r1
    2766:	aa 1f       	adc	r26, r26
    2768:	64 9f       	mul	r22, r20
    276a:	66 27       	eor	r22, r22
    276c:	b0 0d       	add	r27, r0
    276e:	a1 1d       	adc	r26, r1
    2770:	66 1f       	adc	r22, r22
    2772:	82 9f       	mul	r24, r18
    2774:	22 27       	eor	r18, r18
    2776:	b0 0d       	add	r27, r0
    2778:	a1 1d       	adc	r26, r1
    277a:	62 1f       	adc	r22, r18
    277c:	73 9f       	mul	r23, r19
    277e:	b0 0d       	add	r27, r0
    2780:	a1 1d       	adc	r26, r1
    2782:	62 1f       	adc	r22, r18
    2784:	83 9f       	mul	r24, r19
    2786:	a0 0d       	add	r26, r0
    2788:	61 1d       	adc	r22, r1
    278a:	22 1f       	adc	r18, r18
    278c:	74 9f       	mul	r23, r20
    278e:	33 27       	eor	r19, r19
    2790:	a0 0d       	add	r26, r0
    2792:	61 1d       	adc	r22, r1
    2794:	23 1f       	adc	r18, r19
    2796:	84 9f       	mul	r24, r20
    2798:	60 0d       	add	r22, r0
    279a:	21 1d       	adc	r18, r1
    279c:	82 2f       	mov	r24, r18
    279e:	76 2f       	mov	r23, r22
    27a0:	6a 2f       	mov	r22, r26
    27a2:	11 24       	eor	r1, r1
    27a4:	9f 57       	subi	r25, 0x7F	; 127
    27a6:	50 40       	sbci	r21, 0x00	; 0
    27a8:	9a f0       	brmi	.+38     	; 0x27d0 <__mulsf3_pse+0x88>
    27aa:	f1 f0       	breq	.+60     	; 0x27e8 <__mulsf3_pse+0xa0>
    27ac:	88 23       	and	r24, r24
    27ae:	4a f0       	brmi	.+18     	; 0x27c2 <__mulsf3_pse+0x7a>
    27b0:	ee 0f       	add	r30, r30
    27b2:	ff 1f       	adc	r31, r31
    27b4:	bb 1f       	adc	r27, r27
    27b6:	66 1f       	adc	r22, r22
    27b8:	77 1f       	adc	r23, r23
    27ba:	88 1f       	adc	r24, r24
    27bc:	91 50       	subi	r25, 0x01	; 1
    27be:	50 40       	sbci	r21, 0x00	; 0
    27c0:	a9 f7       	brne	.-22     	; 0x27ac <__mulsf3_pse+0x64>
    27c2:	9e 3f       	cpi	r25, 0xFE	; 254
    27c4:	51 05       	cpc	r21, r1
    27c6:	80 f0       	brcs	.+32     	; 0x27e8 <__mulsf3_pse+0xa0>
    27c8:	0c 94 38 13 	jmp	0x2670	; 0x2670 <__fp_inf>
    27cc:	0c 94 83 13 	jmp	0x2706	; 0x2706 <__fp_szero>
    27d0:	5f 3f       	cpi	r21, 0xFF	; 255
    27d2:	e4 f3       	brlt	.-8      	; 0x27cc <__mulsf3_pse+0x84>
    27d4:	98 3e       	cpi	r25, 0xE8	; 232
    27d6:	d4 f3       	brlt	.-12     	; 0x27cc <__mulsf3_pse+0x84>
    27d8:	86 95       	lsr	r24
    27da:	77 95       	ror	r23
    27dc:	67 95       	ror	r22
    27de:	b7 95       	ror	r27
    27e0:	f7 95       	ror	r31
    27e2:	e7 95       	ror	r30
    27e4:	9f 5f       	subi	r25, 0xFF	; 255
    27e6:	c1 f7       	brne	.-16     	; 0x27d8 <__mulsf3_pse+0x90>
    27e8:	fe 2b       	or	r31, r30
    27ea:	88 0f       	add	r24, r24
    27ec:	91 1d       	adc	r25, r1
    27ee:	96 95       	lsr	r25
    27f0:	87 95       	ror	r24
    27f2:	97 f9       	bld	r25, 7
    27f4:	08 95       	ret

000027f6 <__fp_cmp>:
    27f6:	99 0f       	add	r25, r25
    27f8:	00 08       	sbc	r0, r0
    27fa:	55 0f       	add	r21, r21
    27fc:	aa 0b       	sbc	r26, r26
    27fe:	e0 e8       	ldi	r30, 0x80	; 128
    2800:	fe ef       	ldi	r31, 0xFE	; 254
    2802:	16 16       	cp	r1, r22
    2804:	17 06       	cpc	r1, r23
    2806:	e8 07       	cpc	r30, r24
    2808:	f9 07       	cpc	r31, r25
    280a:	c0 f0       	brcs	.+48     	; 0x283c <__fp_cmp+0x46>
    280c:	12 16       	cp	r1, r18
    280e:	13 06       	cpc	r1, r19
    2810:	e4 07       	cpc	r30, r20
    2812:	f5 07       	cpc	r31, r21
    2814:	98 f0       	brcs	.+38     	; 0x283c <__fp_cmp+0x46>
    2816:	62 1b       	sub	r22, r18
    2818:	73 0b       	sbc	r23, r19
    281a:	84 0b       	sbc	r24, r20
    281c:	95 0b       	sbc	r25, r21
    281e:	39 f4       	brne	.+14     	; 0x282e <__fp_cmp+0x38>
    2820:	0a 26       	eor	r0, r26
    2822:	61 f0       	breq	.+24     	; 0x283c <__fp_cmp+0x46>
    2824:	23 2b       	or	r18, r19
    2826:	24 2b       	or	r18, r20
    2828:	25 2b       	or	r18, r21
    282a:	21 f4       	brne	.+8      	; 0x2834 <__fp_cmp+0x3e>
    282c:	08 95       	ret
    282e:	0a 26       	eor	r0, r26
    2830:	09 f4       	brne	.+2      	; 0x2834 <__fp_cmp+0x3e>
    2832:	a1 40       	sbci	r26, 0x01	; 1
    2834:	a6 95       	lsr	r26
    2836:	8f ef       	ldi	r24, 0xFF	; 255
    2838:	81 1d       	adc	r24, r1
    283a:	81 1d       	adc	r24, r1
    283c:	08 95       	ret

0000283e <__tablejump2__>:
    283e:	ee 0f       	add	r30, r30
    2840:	ff 1f       	adc	r31, r31
    2842:	05 90       	lpm	r0, Z+
    2844:	f4 91       	lpm	r31, Z
    2846:	e0 2d       	mov	r30, r0
    2848:	09 94       	ijmp

0000284a <__umulhisi3>:
    284a:	a2 9f       	mul	r26, r18
    284c:	b0 01       	movw	r22, r0
    284e:	b3 9f       	mul	r27, r19
    2850:	c0 01       	movw	r24, r0
    2852:	a3 9f       	mul	r26, r19
    2854:	70 0d       	add	r23, r0
    2856:	81 1d       	adc	r24, r1
    2858:	11 24       	eor	r1, r1
    285a:	91 1d       	adc	r25, r1
    285c:	b2 9f       	mul	r27, r18
    285e:	70 0d       	add	r23, r0
    2860:	81 1d       	adc	r24, r1
    2862:	11 24       	eor	r1, r1
    2864:	91 1d       	adc	r25, r1
    2866:	08 95       	ret

00002868 <malloc>:
    2868:	0f 93       	push	r16
    286a:	1f 93       	push	r17
    286c:	cf 93       	push	r28
    286e:	df 93       	push	r29
    2870:	82 30       	cpi	r24, 0x02	; 2
    2872:	91 05       	cpc	r25, r1
    2874:	10 f4       	brcc	.+4      	; 0x287a <malloc+0x12>
    2876:	82 e0       	ldi	r24, 0x02	; 2
    2878:	90 e0       	ldi	r25, 0x00	; 0
    287a:	e0 91 a9 08 	lds	r30, 0x08A9	; 0x8008a9 <__flp>
    287e:	f0 91 aa 08 	lds	r31, 0x08AA	; 0x8008aa <__flp+0x1>
    2882:	20 e0       	ldi	r18, 0x00	; 0
    2884:	30 e0       	ldi	r19, 0x00	; 0
    2886:	a0 e0       	ldi	r26, 0x00	; 0
    2888:	b0 e0       	ldi	r27, 0x00	; 0
    288a:	30 97       	sbiw	r30, 0x00	; 0
    288c:	19 f1       	breq	.+70     	; 0x28d4 <malloc+0x6c>
    288e:	40 81       	ld	r20, Z
    2890:	51 81       	ldd	r21, Z+1	; 0x01
    2892:	02 81       	ldd	r16, Z+2	; 0x02
    2894:	13 81       	ldd	r17, Z+3	; 0x03
    2896:	48 17       	cp	r20, r24
    2898:	59 07       	cpc	r21, r25
    289a:	c8 f0       	brcs	.+50     	; 0x28ce <malloc+0x66>
    289c:	84 17       	cp	r24, r20
    289e:	95 07       	cpc	r25, r21
    28a0:	69 f4       	brne	.+26     	; 0x28bc <malloc+0x54>
    28a2:	10 97       	sbiw	r26, 0x00	; 0
    28a4:	31 f0       	breq	.+12     	; 0x28b2 <malloc+0x4a>
    28a6:	12 96       	adiw	r26, 0x02	; 2
    28a8:	0c 93       	st	X, r16
    28aa:	12 97       	sbiw	r26, 0x02	; 2
    28ac:	13 96       	adiw	r26, 0x03	; 3
    28ae:	1c 93       	st	X, r17
    28b0:	27 c0       	rjmp	.+78     	; 0x2900 <malloc+0x98>
    28b2:	00 93 a9 08 	sts	0x08A9, r16	; 0x8008a9 <__flp>
    28b6:	10 93 aa 08 	sts	0x08AA, r17	; 0x8008aa <__flp+0x1>
    28ba:	22 c0       	rjmp	.+68     	; 0x2900 <malloc+0x98>
    28bc:	21 15       	cp	r18, r1
    28be:	31 05       	cpc	r19, r1
    28c0:	19 f0       	breq	.+6      	; 0x28c8 <malloc+0x60>
    28c2:	42 17       	cp	r20, r18
    28c4:	53 07       	cpc	r21, r19
    28c6:	18 f4       	brcc	.+6      	; 0x28ce <malloc+0x66>
    28c8:	9a 01       	movw	r18, r20
    28ca:	bd 01       	movw	r22, r26
    28cc:	ef 01       	movw	r28, r30
    28ce:	df 01       	movw	r26, r30
    28d0:	f8 01       	movw	r30, r16
    28d2:	db cf       	rjmp	.-74     	; 0x288a <malloc+0x22>
    28d4:	21 15       	cp	r18, r1
    28d6:	31 05       	cpc	r19, r1
    28d8:	f9 f0       	breq	.+62     	; 0x2918 <malloc+0xb0>
    28da:	28 1b       	sub	r18, r24
    28dc:	39 0b       	sbc	r19, r25
    28de:	24 30       	cpi	r18, 0x04	; 4
    28e0:	31 05       	cpc	r19, r1
    28e2:	80 f4       	brcc	.+32     	; 0x2904 <malloc+0x9c>
    28e4:	8a 81       	ldd	r24, Y+2	; 0x02
    28e6:	9b 81       	ldd	r25, Y+3	; 0x03
    28e8:	61 15       	cp	r22, r1
    28ea:	71 05       	cpc	r23, r1
    28ec:	21 f0       	breq	.+8      	; 0x28f6 <malloc+0x8e>
    28ee:	fb 01       	movw	r30, r22
    28f0:	93 83       	std	Z+3, r25	; 0x03
    28f2:	82 83       	std	Z+2, r24	; 0x02
    28f4:	04 c0       	rjmp	.+8      	; 0x28fe <malloc+0x96>
    28f6:	90 93 aa 08 	sts	0x08AA, r25	; 0x8008aa <__flp+0x1>
    28fa:	80 93 a9 08 	sts	0x08A9, r24	; 0x8008a9 <__flp>
    28fe:	fe 01       	movw	r30, r28
    2900:	32 96       	adiw	r30, 0x02	; 2
    2902:	44 c0       	rjmp	.+136    	; 0x298c <malloc+0x124>
    2904:	fe 01       	movw	r30, r28
    2906:	e2 0f       	add	r30, r18
    2908:	f3 1f       	adc	r31, r19
    290a:	81 93       	st	Z+, r24
    290c:	91 93       	st	Z+, r25
    290e:	22 50       	subi	r18, 0x02	; 2
    2910:	31 09       	sbc	r19, r1
    2912:	39 83       	std	Y+1, r19	; 0x01
    2914:	28 83       	st	Y, r18
    2916:	3a c0       	rjmp	.+116    	; 0x298c <malloc+0x124>
    2918:	20 91 a7 08 	lds	r18, 0x08A7	; 0x8008a7 <__brkval>
    291c:	30 91 a8 08 	lds	r19, 0x08A8	; 0x8008a8 <__brkval+0x1>
    2920:	23 2b       	or	r18, r19
    2922:	41 f4       	brne	.+16     	; 0x2934 <malloc+0xcc>
    2924:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    2928:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    292c:	30 93 a8 08 	sts	0x08A8, r19	; 0x8008a8 <__brkval+0x1>
    2930:	20 93 a7 08 	sts	0x08A7, r18	; 0x8008a7 <__brkval>
    2934:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    2938:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    293c:	21 15       	cp	r18, r1
    293e:	31 05       	cpc	r19, r1
    2940:	41 f4       	brne	.+16     	; 0x2952 <malloc+0xea>
    2942:	2d b7       	in	r18, 0x3d	; 61
    2944:	3e b7       	in	r19, 0x3e	; 62
    2946:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    294a:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    294e:	24 1b       	sub	r18, r20
    2950:	35 0b       	sbc	r19, r21
    2952:	e0 91 a7 08 	lds	r30, 0x08A7	; 0x8008a7 <__brkval>
    2956:	f0 91 a8 08 	lds	r31, 0x08A8	; 0x8008a8 <__brkval+0x1>
    295a:	e2 17       	cp	r30, r18
    295c:	f3 07       	cpc	r31, r19
    295e:	a0 f4       	brcc	.+40     	; 0x2988 <malloc+0x120>
    2960:	2e 1b       	sub	r18, r30
    2962:	3f 0b       	sbc	r19, r31
    2964:	28 17       	cp	r18, r24
    2966:	39 07       	cpc	r19, r25
    2968:	78 f0       	brcs	.+30     	; 0x2988 <malloc+0x120>
    296a:	ac 01       	movw	r20, r24
    296c:	4e 5f       	subi	r20, 0xFE	; 254
    296e:	5f 4f       	sbci	r21, 0xFF	; 255
    2970:	24 17       	cp	r18, r20
    2972:	35 07       	cpc	r19, r21
    2974:	48 f0       	brcs	.+18     	; 0x2988 <malloc+0x120>
    2976:	4e 0f       	add	r20, r30
    2978:	5f 1f       	adc	r21, r31
    297a:	50 93 a8 08 	sts	0x08A8, r21	; 0x8008a8 <__brkval+0x1>
    297e:	40 93 a7 08 	sts	0x08A7, r20	; 0x8008a7 <__brkval>
    2982:	81 93       	st	Z+, r24
    2984:	91 93       	st	Z+, r25
    2986:	02 c0       	rjmp	.+4      	; 0x298c <malloc+0x124>
    2988:	e0 e0       	ldi	r30, 0x00	; 0
    298a:	f0 e0       	ldi	r31, 0x00	; 0
    298c:	cf 01       	movw	r24, r30
    298e:	df 91       	pop	r29
    2990:	cf 91       	pop	r28
    2992:	1f 91       	pop	r17
    2994:	0f 91       	pop	r16
    2996:	08 95       	ret

00002998 <free>:
    2998:	cf 93       	push	r28
    299a:	df 93       	push	r29
    299c:	00 97       	sbiw	r24, 0x00	; 0
    299e:	09 f4       	brne	.+2      	; 0x29a2 <free+0xa>
    29a0:	81 c0       	rjmp	.+258    	; 0x2aa4 <free+0x10c>
    29a2:	fc 01       	movw	r30, r24
    29a4:	32 97       	sbiw	r30, 0x02	; 2
    29a6:	13 82       	std	Z+3, r1	; 0x03
    29a8:	12 82       	std	Z+2, r1	; 0x02
    29aa:	a0 91 a9 08 	lds	r26, 0x08A9	; 0x8008a9 <__flp>
    29ae:	b0 91 aa 08 	lds	r27, 0x08AA	; 0x8008aa <__flp+0x1>
    29b2:	10 97       	sbiw	r26, 0x00	; 0
    29b4:	81 f4       	brne	.+32     	; 0x29d6 <free+0x3e>
    29b6:	20 81       	ld	r18, Z
    29b8:	31 81       	ldd	r19, Z+1	; 0x01
    29ba:	82 0f       	add	r24, r18
    29bc:	93 1f       	adc	r25, r19
    29be:	20 91 a7 08 	lds	r18, 0x08A7	; 0x8008a7 <__brkval>
    29c2:	30 91 a8 08 	lds	r19, 0x08A8	; 0x8008a8 <__brkval+0x1>
    29c6:	28 17       	cp	r18, r24
    29c8:	39 07       	cpc	r19, r25
    29ca:	51 f5       	brne	.+84     	; 0x2a20 <free+0x88>
    29cc:	f0 93 a8 08 	sts	0x08A8, r31	; 0x8008a8 <__brkval+0x1>
    29d0:	e0 93 a7 08 	sts	0x08A7, r30	; 0x8008a7 <__brkval>
    29d4:	67 c0       	rjmp	.+206    	; 0x2aa4 <free+0x10c>
    29d6:	ed 01       	movw	r28, r26
    29d8:	20 e0       	ldi	r18, 0x00	; 0
    29da:	30 e0       	ldi	r19, 0x00	; 0
    29dc:	ce 17       	cp	r28, r30
    29de:	df 07       	cpc	r29, r31
    29e0:	40 f4       	brcc	.+16     	; 0x29f2 <free+0x5a>
    29e2:	4a 81       	ldd	r20, Y+2	; 0x02
    29e4:	5b 81       	ldd	r21, Y+3	; 0x03
    29e6:	9e 01       	movw	r18, r28
    29e8:	41 15       	cp	r20, r1
    29ea:	51 05       	cpc	r21, r1
    29ec:	f1 f0       	breq	.+60     	; 0x2a2a <free+0x92>
    29ee:	ea 01       	movw	r28, r20
    29f0:	f5 cf       	rjmp	.-22     	; 0x29dc <free+0x44>
    29f2:	d3 83       	std	Z+3, r29	; 0x03
    29f4:	c2 83       	std	Z+2, r28	; 0x02
    29f6:	40 81       	ld	r20, Z
    29f8:	51 81       	ldd	r21, Z+1	; 0x01
    29fa:	84 0f       	add	r24, r20
    29fc:	95 1f       	adc	r25, r21
    29fe:	c8 17       	cp	r28, r24
    2a00:	d9 07       	cpc	r29, r25
    2a02:	59 f4       	brne	.+22     	; 0x2a1a <free+0x82>
    2a04:	88 81       	ld	r24, Y
    2a06:	99 81       	ldd	r25, Y+1	; 0x01
    2a08:	84 0f       	add	r24, r20
    2a0a:	95 1f       	adc	r25, r21
    2a0c:	02 96       	adiw	r24, 0x02	; 2
    2a0e:	91 83       	std	Z+1, r25	; 0x01
    2a10:	80 83       	st	Z, r24
    2a12:	8a 81       	ldd	r24, Y+2	; 0x02
    2a14:	9b 81       	ldd	r25, Y+3	; 0x03
    2a16:	93 83       	std	Z+3, r25	; 0x03
    2a18:	82 83       	std	Z+2, r24	; 0x02
    2a1a:	21 15       	cp	r18, r1
    2a1c:	31 05       	cpc	r19, r1
    2a1e:	29 f4       	brne	.+10     	; 0x2a2a <free+0x92>
    2a20:	f0 93 aa 08 	sts	0x08AA, r31	; 0x8008aa <__flp+0x1>
    2a24:	e0 93 a9 08 	sts	0x08A9, r30	; 0x8008a9 <__flp>
    2a28:	3d c0       	rjmp	.+122    	; 0x2aa4 <free+0x10c>
    2a2a:	e9 01       	movw	r28, r18
    2a2c:	fb 83       	std	Y+3, r31	; 0x03
    2a2e:	ea 83       	std	Y+2, r30	; 0x02
    2a30:	49 91       	ld	r20, Y+
    2a32:	59 91       	ld	r21, Y+
    2a34:	c4 0f       	add	r28, r20
    2a36:	d5 1f       	adc	r29, r21
    2a38:	ec 17       	cp	r30, r28
    2a3a:	fd 07       	cpc	r31, r29
    2a3c:	61 f4       	brne	.+24     	; 0x2a56 <free+0xbe>
    2a3e:	80 81       	ld	r24, Z
    2a40:	91 81       	ldd	r25, Z+1	; 0x01
    2a42:	84 0f       	add	r24, r20
    2a44:	95 1f       	adc	r25, r21
    2a46:	02 96       	adiw	r24, 0x02	; 2
    2a48:	e9 01       	movw	r28, r18
    2a4a:	99 83       	std	Y+1, r25	; 0x01
    2a4c:	88 83       	st	Y, r24
    2a4e:	82 81       	ldd	r24, Z+2	; 0x02
    2a50:	93 81       	ldd	r25, Z+3	; 0x03
    2a52:	9b 83       	std	Y+3, r25	; 0x03
    2a54:	8a 83       	std	Y+2, r24	; 0x02
    2a56:	e0 e0       	ldi	r30, 0x00	; 0
    2a58:	f0 e0       	ldi	r31, 0x00	; 0
    2a5a:	12 96       	adiw	r26, 0x02	; 2
    2a5c:	8d 91       	ld	r24, X+
    2a5e:	9c 91       	ld	r25, X
    2a60:	13 97       	sbiw	r26, 0x03	; 3
    2a62:	00 97       	sbiw	r24, 0x00	; 0
    2a64:	19 f0       	breq	.+6      	; 0x2a6c <free+0xd4>
    2a66:	fd 01       	movw	r30, r26
    2a68:	dc 01       	movw	r26, r24
    2a6a:	f7 cf       	rjmp	.-18     	; 0x2a5a <free+0xc2>
    2a6c:	8d 91       	ld	r24, X+
    2a6e:	9c 91       	ld	r25, X
    2a70:	11 97       	sbiw	r26, 0x01	; 1
    2a72:	9d 01       	movw	r18, r26
    2a74:	2e 5f       	subi	r18, 0xFE	; 254
    2a76:	3f 4f       	sbci	r19, 0xFF	; 255
    2a78:	82 0f       	add	r24, r18
    2a7a:	93 1f       	adc	r25, r19
    2a7c:	20 91 a7 08 	lds	r18, 0x08A7	; 0x8008a7 <__brkval>
    2a80:	30 91 a8 08 	lds	r19, 0x08A8	; 0x8008a8 <__brkval+0x1>
    2a84:	28 17       	cp	r18, r24
    2a86:	39 07       	cpc	r19, r25
    2a88:	69 f4       	brne	.+26     	; 0x2aa4 <free+0x10c>
    2a8a:	30 97       	sbiw	r30, 0x00	; 0
    2a8c:	29 f4       	brne	.+10     	; 0x2a98 <free+0x100>
    2a8e:	10 92 aa 08 	sts	0x08AA, r1	; 0x8008aa <__flp+0x1>
    2a92:	10 92 a9 08 	sts	0x08A9, r1	; 0x8008a9 <__flp>
    2a96:	02 c0       	rjmp	.+4      	; 0x2a9c <free+0x104>
    2a98:	13 82       	std	Z+3, r1	; 0x03
    2a9a:	12 82       	std	Z+2, r1	; 0x02
    2a9c:	b0 93 a8 08 	sts	0x08A8, r27	; 0x8008a8 <__brkval+0x1>
    2aa0:	a0 93 a7 08 	sts	0x08A7, r26	; 0x8008a7 <__brkval>
    2aa4:	df 91       	pop	r29
    2aa6:	cf 91       	pop	r28
    2aa8:	08 95       	ret

00002aaa <memcpy>:
    2aaa:	fb 01       	movw	r30, r22
    2aac:	dc 01       	movw	r26, r24
    2aae:	02 c0       	rjmp	.+4      	; 0x2ab4 <memcpy+0xa>
    2ab0:	01 90       	ld	r0, Z+
    2ab2:	0d 92       	st	X+, r0
    2ab4:	41 50       	subi	r20, 0x01	; 1
    2ab6:	50 40       	sbci	r21, 0x00	; 0
    2ab8:	d8 f7       	brcc	.-10     	; 0x2ab0 <memcpy+0x6>
    2aba:	08 95       	ret

00002abc <_exit>:
    2abc:	f8 94       	cli

00002abe <__stop_program>:
    2abe:	ff cf       	rjmp	.-2      	; 0x2abe <__stop_program>
