
ArduinoFreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000e2  00800100  00001702  00001796  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001702  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000065c  008001e2  008001e2  00001878  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001878  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000018a8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000358  00000000  00000000  000018e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000434c  00000000  00000000  00001c40  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c00  00000000  00000000  00005f8c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000258b  00000000  00000000  00006b8c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000a60  00000000  00000000  00009118  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001417  00000000  00000000  00009b78  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000430b  00000000  00000000  0000af8f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000003e8  00000000  00000000  0000f29a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 73 02 	jmp	0x4e6	; 0x4e6 <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 e3 09 	jmp	0x13c6	; 0x13c6 <__vector_18>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e2 e0       	ldi	r30, 0x02	; 2
      7c:	f7 e1       	ldi	r31, 0x17	; 23
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a2 3e       	cpi	r26, 0xE2	; 226
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	28 e0       	ldi	r18, 0x08	; 8
      8c:	a2 ee       	ldi	r26, 0xE2	; 226
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	ae 33       	cpi	r26, 0x3E	; 62
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <main>
      9e:	0c 94 7f 0b 	jmp	0x16fe	; 0x16fe <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
      a6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      a8:	03 96       	adiw	r24, 0x03	; 3
      aa:	92 83       	std	Z+2, r25	; 0x02
      ac:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
      ae:	2f ef       	ldi	r18, 0xFF	; 255
      b0:	3f ef       	ldi	r19, 0xFF	; 255
      b2:	34 83       	std	Z+4, r19	; 0x04
      b4:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      b6:	96 83       	std	Z+6, r25	; 0x06
      b8:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      ba:	90 87       	std	Z+8, r25	; 0x08
      bc:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
      be:	10 82       	st	Z, r1
      c0:	08 95       	ret

000000c2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
      c2:	fc 01       	movw	r30, r24
      c4:	11 86       	std	Z+9, r1	; 0x09
      c6:	10 86       	std	Z+8, r1	; 0x08
      c8:	08 95       	ret

000000ca <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
      ca:	cf 93       	push	r28
      cc:	df 93       	push	r29
      ce:	9c 01       	movw	r18, r24
      d0:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
      d2:	dc 01       	movw	r26, r24
      d4:	11 96       	adiw	r26, 0x01	; 1
      d6:	cd 91       	ld	r28, X+
      d8:	dc 91       	ld	r29, X
      da:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
      dc:	d3 83       	std	Z+3, r29	; 0x03
      de:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
      e0:	8c 81       	ldd	r24, Y+4	; 0x04
      e2:	9d 81       	ldd	r25, Y+5	; 0x05
      e4:	95 83       	std	Z+5, r25	; 0x05
      e6:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
      e8:	8c 81       	ldd	r24, Y+4	; 0x04
      ea:	9d 81       	ldd	r25, Y+5	; 0x05
      ec:	dc 01       	movw	r26, r24
      ee:	13 96       	adiw	r26, 0x03	; 3
      f0:	7c 93       	st	X, r23
      f2:	6e 93       	st	-X, r22
      f4:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
      f6:	7d 83       	std	Y+5, r23	; 0x05
      f8:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
      fa:	31 87       	std	Z+9, r19	; 0x09
      fc:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
      fe:	f9 01       	movw	r30, r18
     100:	80 81       	ld	r24, Z
     102:	8f 5f       	subi	r24, 0xFF	; 255
     104:	80 83       	st	Z, r24
}
     106:	df 91       	pop	r29
     108:	cf 91       	pop	r28
     10a:	08 95       	ret

0000010c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     10c:	cf 93       	push	r28
     10e:	df 93       	push	r29
     110:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     112:	48 81       	ld	r20, Y
     114:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     116:	4f 3f       	cpi	r20, 0xFF	; 255
     118:	2f ef       	ldi	r18, 0xFF	; 255
     11a:	52 07       	cpc	r21, r18
     11c:	21 f4       	brne	.+8      	; 0x126 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     11e:	fc 01       	movw	r30, r24
     120:	a7 81       	ldd	r26, Z+7	; 0x07
     122:	b0 85       	ldd	r27, Z+8	; 0x08
     124:	0d c0       	rjmp	.+26     	; 0x140 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     126:	dc 01       	movw	r26, r24
     128:	13 96       	adiw	r26, 0x03	; 3
     12a:	01 c0       	rjmp	.+2      	; 0x12e <vListInsert+0x22>
     12c:	df 01       	movw	r26, r30
     12e:	12 96       	adiw	r26, 0x02	; 2
     130:	ed 91       	ld	r30, X+
     132:	fc 91       	ld	r31, X
     134:	13 97       	sbiw	r26, 0x03	; 3
     136:	20 81       	ld	r18, Z
     138:	31 81       	ldd	r19, Z+1	; 0x01
     13a:	42 17       	cp	r20, r18
     13c:	53 07       	cpc	r21, r19
     13e:	b0 f7       	brcc	.-20     	; 0x12c <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     140:	12 96       	adiw	r26, 0x02	; 2
     142:	ed 91       	ld	r30, X+
     144:	fc 91       	ld	r31, X
     146:	13 97       	sbiw	r26, 0x03	; 3
     148:	fb 83       	std	Y+3, r31	; 0x03
     14a:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     14c:	d5 83       	std	Z+5, r29	; 0x05
     14e:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     150:	bd 83       	std	Y+5, r27	; 0x05
     152:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     154:	13 96       	adiw	r26, 0x03	; 3
     156:	dc 93       	st	X, r29
     158:	ce 93       	st	-X, r28
     15a:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     15c:	99 87       	std	Y+9, r25	; 0x09
     15e:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     160:	fc 01       	movw	r30, r24
     162:	20 81       	ld	r18, Z
     164:	2f 5f       	subi	r18, 0xFF	; 255
     166:	20 83       	st	Z, r18
}
     168:	df 91       	pop	r29
     16a:	cf 91       	pop	r28
     16c:	08 95       	ret

0000016e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     16e:	cf 93       	push	r28
     170:	df 93       	push	r29
     172:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     174:	a0 85       	ldd	r26, Z+8	; 0x08
     176:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     178:	c2 81       	ldd	r28, Z+2	; 0x02
     17a:	d3 81       	ldd	r29, Z+3	; 0x03
     17c:	84 81       	ldd	r24, Z+4	; 0x04
     17e:	95 81       	ldd	r25, Z+5	; 0x05
     180:	9d 83       	std	Y+5, r25	; 0x05
     182:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     184:	c4 81       	ldd	r28, Z+4	; 0x04
     186:	d5 81       	ldd	r29, Z+5	; 0x05
     188:	82 81       	ldd	r24, Z+2	; 0x02
     18a:	93 81       	ldd	r25, Z+3	; 0x03
     18c:	9b 83       	std	Y+3, r25	; 0x03
     18e:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     190:	11 96       	adiw	r26, 0x01	; 1
     192:	8d 91       	ld	r24, X+
     194:	9c 91       	ld	r25, X
     196:	12 97       	sbiw	r26, 0x02	; 2
     198:	e8 17       	cp	r30, r24
     19a:	f9 07       	cpc	r31, r25
     19c:	31 f4       	brne	.+12     	; 0x1aa <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     19e:	84 81       	ldd	r24, Z+4	; 0x04
     1a0:	95 81       	ldd	r25, Z+5	; 0x05
     1a2:	12 96       	adiw	r26, 0x02	; 2
     1a4:	9c 93       	st	X, r25
     1a6:	8e 93       	st	-X, r24
     1a8:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     1aa:	11 86       	std	Z+9, r1	; 0x09
     1ac:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     1ae:	8c 91       	ld	r24, X
     1b0:	81 50       	subi	r24, 0x01	; 1
     1b2:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     1b4:	df 91       	pop	r29
     1b6:	cf 91       	pop	r28
     1b8:	08 95       	ret

000001ba <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     1ba:	cf 93       	push	r28
     1bc:	df 93       	push	r29
     1be:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     1c0:	0e 94 7c 06 	call	0xcf8	; 0xcf8 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     1c4:	80 91 e2 01 	lds	r24, 0x01E2	; 0x8001e2 <__data_end>
     1c8:	90 91 e3 01 	lds	r25, 0x01E3	; 0x8001e3 <__data_end+0x1>
     1cc:	89 2b       	or	r24, r25
     1ce:	31 f4       	brne	.+12     	; 0x1dc <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     1d0:	87 ee       	ldi	r24, 0xE7	; 231
     1d2:	91 e0       	ldi	r25, 0x01	; 1
     1d4:	90 93 e3 01 	sts	0x01E3, r25	; 0x8001e3 <__data_end+0x1>
     1d8:	80 93 e2 01 	sts	0x01E2, r24	; 0x8001e2 <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     1dc:	20 91 e4 01 	lds	r18, 0x01E4	; 0x8001e4 <xNextFreeByte>
     1e0:	30 91 e5 01 	lds	r19, 0x01E5	; 0x8001e5 <xNextFreeByte+0x1>
     1e4:	c9 01       	movw	r24, r18
     1e6:	8c 0f       	add	r24, r28
     1e8:	9d 1f       	adc	r25, r29
     1ea:	8b 3d       	cpi	r24, 0xDB	; 219
     1ec:	45 e0       	ldi	r20, 0x05	; 5
     1ee:	94 07       	cpc	r25, r20
     1f0:	70 f4       	brcc	.+28     	; 0x20e <pvPortMalloc+0x54>
     1f2:	28 17       	cp	r18, r24
     1f4:	39 07       	cpc	r19, r25
     1f6:	70 f4       	brcc	.+28     	; 0x214 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     1f8:	c0 91 e2 01 	lds	r28, 0x01E2	; 0x8001e2 <__data_end>
     1fc:	d0 91 e3 01 	lds	r29, 0x01E3	; 0x8001e3 <__data_end+0x1>
     200:	c2 0f       	add	r28, r18
     202:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     204:	90 93 e5 01 	sts	0x01E5, r25	; 0x8001e5 <xNextFreeByte+0x1>
     208:	80 93 e4 01 	sts	0x01E4, r24	; 0x8001e4 <xNextFreeByte>
     20c:	05 c0       	rjmp	.+10     	; 0x218 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     20e:	c0 e0       	ldi	r28, 0x00	; 0
     210:	d0 e0       	ldi	r29, 0x00	; 0
     212:	02 c0       	rjmp	.+4      	; 0x218 <pvPortMalloc+0x5e>
     214:	c0 e0       	ldi	r28, 0x00	; 0
     216:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     218:	0e 94 3d 07 	call	0xe7a	; 0xe7a <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     21c:	ce 01       	movw	r24, r28
     21e:	df 91       	pop	r29
     220:	cf 91       	pop	r28
     222:	08 95       	ret

00000224 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     224:	08 95       	ret

00000226 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     226:	31 e1       	ldi	r19, 0x11	; 17
     228:	fc 01       	movw	r30, r24
     22a:	30 83       	st	Z, r19
     22c:	31 97       	sbiw	r30, 0x01	; 1
     22e:	22 e2       	ldi	r18, 0x22	; 34
     230:	20 83       	st	Z, r18
     232:	31 97       	sbiw	r30, 0x01	; 1
     234:	a3 e3       	ldi	r26, 0x33	; 51
     236:	a0 83       	st	Z, r26
     238:	31 97       	sbiw	r30, 0x01	; 1
     23a:	60 83       	st	Z, r22
     23c:	31 97       	sbiw	r30, 0x01	; 1
     23e:	70 83       	st	Z, r23
     240:	31 97       	sbiw	r30, 0x01	; 1
     242:	10 82       	st	Z, r1
     244:	31 97       	sbiw	r30, 0x01	; 1
     246:	60 e8       	ldi	r22, 0x80	; 128
     248:	60 83       	st	Z, r22
     24a:	31 97       	sbiw	r30, 0x01	; 1
     24c:	10 82       	st	Z, r1
     24e:	31 97       	sbiw	r30, 0x01	; 1
     250:	62 e0       	ldi	r22, 0x02	; 2
     252:	60 83       	st	Z, r22
     254:	31 97       	sbiw	r30, 0x01	; 1
     256:	63 e0       	ldi	r22, 0x03	; 3
     258:	60 83       	st	Z, r22
     25a:	31 97       	sbiw	r30, 0x01	; 1
     25c:	64 e0       	ldi	r22, 0x04	; 4
     25e:	60 83       	st	Z, r22
     260:	31 97       	sbiw	r30, 0x01	; 1
     262:	65 e0       	ldi	r22, 0x05	; 5
     264:	60 83       	st	Z, r22
     266:	31 97       	sbiw	r30, 0x01	; 1
     268:	66 e0       	ldi	r22, 0x06	; 6
     26a:	60 83       	st	Z, r22
     26c:	31 97       	sbiw	r30, 0x01	; 1
     26e:	67 e0       	ldi	r22, 0x07	; 7
     270:	60 83       	st	Z, r22
     272:	31 97       	sbiw	r30, 0x01	; 1
     274:	68 e0       	ldi	r22, 0x08	; 8
     276:	60 83       	st	Z, r22
     278:	31 97       	sbiw	r30, 0x01	; 1
     27a:	69 e0       	ldi	r22, 0x09	; 9
     27c:	60 83       	st	Z, r22
     27e:	31 97       	sbiw	r30, 0x01	; 1
     280:	60 e1       	ldi	r22, 0x10	; 16
     282:	60 83       	st	Z, r22
     284:	31 97       	sbiw	r30, 0x01	; 1
     286:	30 83       	st	Z, r19
     288:	31 97       	sbiw	r30, 0x01	; 1
     28a:	32 e1       	ldi	r19, 0x12	; 18
     28c:	30 83       	st	Z, r19
     28e:	31 97       	sbiw	r30, 0x01	; 1
     290:	33 e1       	ldi	r19, 0x13	; 19
     292:	30 83       	st	Z, r19
     294:	31 97       	sbiw	r30, 0x01	; 1
     296:	34 e1       	ldi	r19, 0x14	; 20
     298:	30 83       	st	Z, r19
     29a:	31 97       	sbiw	r30, 0x01	; 1
     29c:	35 e1       	ldi	r19, 0x15	; 21
     29e:	30 83       	st	Z, r19
     2a0:	31 97       	sbiw	r30, 0x01	; 1
     2a2:	36 e1       	ldi	r19, 0x16	; 22
     2a4:	30 83       	st	Z, r19
     2a6:	31 97       	sbiw	r30, 0x01	; 1
     2a8:	37 e1       	ldi	r19, 0x17	; 23
     2aa:	30 83       	st	Z, r19
     2ac:	31 97       	sbiw	r30, 0x01	; 1
     2ae:	38 e1       	ldi	r19, 0x18	; 24
     2b0:	30 83       	st	Z, r19
     2b2:	31 97       	sbiw	r30, 0x01	; 1
     2b4:	39 e1       	ldi	r19, 0x19	; 25
     2b6:	30 83       	st	Z, r19
     2b8:	31 97       	sbiw	r30, 0x01	; 1
     2ba:	30 e2       	ldi	r19, 0x20	; 32
     2bc:	30 83       	st	Z, r19
     2be:	31 97       	sbiw	r30, 0x01	; 1
     2c0:	31 e2       	ldi	r19, 0x21	; 33
     2c2:	30 83       	st	Z, r19
     2c4:	31 97       	sbiw	r30, 0x01	; 1
     2c6:	20 83       	st	Z, r18
     2c8:	31 97       	sbiw	r30, 0x01	; 1
     2ca:	23 e2       	ldi	r18, 0x23	; 35
     2cc:	20 83       	st	Z, r18
     2ce:	31 97       	sbiw	r30, 0x01	; 1
     2d0:	40 83       	st	Z, r20
     2d2:	31 97       	sbiw	r30, 0x01	; 1
     2d4:	50 83       	st	Z, r21
     2d6:	31 97       	sbiw	r30, 0x01	; 1
     2d8:	26 e2       	ldi	r18, 0x26	; 38
     2da:	20 83       	st	Z, r18
     2dc:	31 97       	sbiw	r30, 0x01	; 1
     2de:	27 e2       	ldi	r18, 0x27	; 39
     2e0:	20 83       	st	Z, r18
     2e2:	31 97       	sbiw	r30, 0x01	; 1
     2e4:	28 e2       	ldi	r18, 0x28	; 40
     2e6:	20 83       	st	Z, r18
     2e8:	31 97       	sbiw	r30, 0x01	; 1
     2ea:	29 e2       	ldi	r18, 0x29	; 41
     2ec:	20 83       	st	Z, r18
     2ee:	31 97       	sbiw	r30, 0x01	; 1
     2f0:	20 e3       	ldi	r18, 0x30	; 48
     2f2:	20 83       	st	Z, r18
     2f4:	31 97       	sbiw	r30, 0x01	; 1
     2f6:	21 e3       	ldi	r18, 0x31	; 49
     2f8:	20 83       	st	Z, r18
     2fa:	86 97       	sbiw	r24, 0x26	; 38
     2fc:	08 95       	ret

000002fe <xPortStartScheduler>:
     2fe:	89 ef       	ldi	r24, 0xF9	; 249
     300:	90 e0       	ldi	r25, 0x00	; 0
     302:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
     306:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
     30a:	e0 e8       	ldi	r30, 0x80	; 128
     30c:	f0 e0       	ldi	r31, 0x00	; 0
     30e:	80 81       	ld	r24, Z
     310:	8c 7f       	andi	r24, 0xFC	; 252
     312:	80 83       	st	Z, r24
     314:	8b e0       	ldi	r24, 0x0B	; 11
     316:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
     31a:	ef e6       	ldi	r30, 0x6F	; 111
     31c:	f0 e0       	ldi	r31, 0x00	; 0
     31e:	80 81       	ld	r24, Z
     320:	82 60       	ori	r24, 0x02	; 2
     322:	80 83       	st	Z, r24
     324:	a0 91 26 08 	lds	r26, 0x0826	; 0x800826 <pxCurrentTCB>
     328:	b0 91 27 08 	lds	r27, 0x0827	; 0x800827 <pxCurrentTCB+0x1>
     32c:	cd 91       	ld	r28, X+
     32e:	cd bf       	out	0x3d, r28	; 61
     330:	dd 91       	ld	r29, X+
     332:	de bf       	out	0x3e, r29	; 62
     334:	ff 91       	pop	r31
     336:	ef 91       	pop	r30
     338:	df 91       	pop	r29
     33a:	cf 91       	pop	r28
     33c:	bf 91       	pop	r27
     33e:	af 91       	pop	r26
     340:	9f 91       	pop	r25
     342:	8f 91       	pop	r24
     344:	7f 91       	pop	r23
     346:	6f 91       	pop	r22
     348:	5f 91       	pop	r21
     34a:	4f 91       	pop	r20
     34c:	3f 91       	pop	r19
     34e:	2f 91       	pop	r18
     350:	1f 91       	pop	r17
     352:	0f 91       	pop	r16
     354:	ff 90       	pop	r15
     356:	ef 90       	pop	r14
     358:	df 90       	pop	r13
     35a:	cf 90       	pop	r12
     35c:	bf 90       	pop	r11
     35e:	af 90       	pop	r10
     360:	9f 90       	pop	r9
     362:	8f 90       	pop	r8
     364:	7f 90       	pop	r7
     366:	6f 90       	pop	r6
     368:	5f 90       	pop	r5
     36a:	4f 90       	pop	r4
     36c:	3f 90       	pop	r3
     36e:	2f 90       	pop	r2
     370:	1f 90       	pop	r1
     372:	0f 90       	pop	r0
     374:	0f be       	out	0x3f, r0	; 63
     376:	0f 90       	pop	r0
     378:	08 95       	ret
     37a:	81 e0       	ldi	r24, 0x01	; 1
     37c:	08 95       	ret

0000037e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     37e:	0f 92       	push	r0
     380:	0f b6       	in	r0, 0x3f	; 63
     382:	f8 94       	cli
     384:	0f 92       	push	r0
     386:	1f 92       	push	r1
     388:	11 24       	eor	r1, r1
     38a:	2f 92       	push	r2
     38c:	3f 92       	push	r3
     38e:	4f 92       	push	r4
     390:	5f 92       	push	r5
     392:	6f 92       	push	r6
     394:	7f 92       	push	r7
     396:	8f 92       	push	r8
     398:	9f 92       	push	r9
     39a:	af 92       	push	r10
     39c:	bf 92       	push	r11
     39e:	cf 92       	push	r12
     3a0:	df 92       	push	r13
     3a2:	ef 92       	push	r14
     3a4:	ff 92       	push	r15
     3a6:	0f 93       	push	r16
     3a8:	1f 93       	push	r17
     3aa:	2f 93       	push	r18
     3ac:	3f 93       	push	r19
     3ae:	4f 93       	push	r20
     3b0:	5f 93       	push	r21
     3b2:	6f 93       	push	r22
     3b4:	7f 93       	push	r23
     3b6:	8f 93       	push	r24
     3b8:	9f 93       	push	r25
     3ba:	af 93       	push	r26
     3bc:	bf 93       	push	r27
     3be:	cf 93       	push	r28
     3c0:	df 93       	push	r29
     3c2:	ef 93       	push	r30
     3c4:	ff 93       	push	r31
     3c6:	a0 91 26 08 	lds	r26, 0x0826	; 0x800826 <pxCurrentTCB>
     3ca:	b0 91 27 08 	lds	r27, 0x0827	; 0x800827 <pxCurrentTCB+0x1>
     3ce:	0d b6       	in	r0, 0x3d	; 61
     3d0:	0d 92       	st	X+, r0
     3d2:	0e b6       	in	r0, 0x3e	; 62
     3d4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     3d6:	0e 94 0f 08 	call	0x101e	; 0x101e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     3da:	a0 91 26 08 	lds	r26, 0x0826	; 0x800826 <pxCurrentTCB>
     3de:	b0 91 27 08 	lds	r27, 0x0827	; 0x800827 <pxCurrentTCB+0x1>
     3e2:	cd 91       	ld	r28, X+
     3e4:	cd bf       	out	0x3d, r28	; 61
     3e6:	dd 91       	ld	r29, X+
     3e8:	de bf       	out	0x3e, r29	; 62
     3ea:	ff 91       	pop	r31
     3ec:	ef 91       	pop	r30
     3ee:	df 91       	pop	r29
     3f0:	cf 91       	pop	r28
     3f2:	bf 91       	pop	r27
     3f4:	af 91       	pop	r26
     3f6:	9f 91       	pop	r25
     3f8:	8f 91       	pop	r24
     3fa:	7f 91       	pop	r23
     3fc:	6f 91       	pop	r22
     3fe:	5f 91       	pop	r21
     400:	4f 91       	pop	r20
     402:	3f 91       	pop	r19
     404:	2f 91       	pop	r18
     406:	1f 91       	pop	r17
     408:	0f 91       	pop	r16
     40a:	ff 90       	pop	r15
     40c:	ef 90       	pop	r14
     40e:	df 90       	pop	r13
     410:	cf 90       	pop	r12
     412:	bf 90       	pop	r11
     414:	af 90       	pop	r10
     416:	9f 90       	pop	r9
     418:	8f 90       	pop	r8
     41a:	7f 90       	pop	r7
     41c:	6f 90       	pop	r6
     41e:	5f 90       	pop	r5
     420:	4f 90       	pop	r4
     422:	3f 90       	pop	r3
     424:	2f 90       	pop	r2
     426:	1f 90       	pop	r1
     428:	0f 90       	pop	r0
     42a:	0f be       	out	0x3f, r0	; 63
     42c:	0f 90       	pop	r0

	asm volatile ( "ret" );
     42e:	08 95       	ret

00000430 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     430:	0f 92       	push	r0
     432:	0f b6       	in	r0, 0x3f	; 63
     434:	f8 94       	cli
     436:	0f 92       	push	r0
     438:	1f 92       	push	r1
     43a:	11 24       	eor	r1, r1
     43c:	2f 92       	push	r2
     43e:	3f 92       	push	r3
     440:	4f 92       	push	r4
     442:	5f 92       	push	r5
     444:	6f 92       	push	r6
     446:	7f 92       	push	r7
     448:	8f 92       	push	r8
     44a:	9f 92       	push	r9
     44c:	af 92       	push	r10
     44e:	bf 92       	push	r11
     450:	cf 92       	push	r12
     452:	df 92       	push	r13
     454:	ef 92       	push	r14
     456:	ff 92       	push	r15
     458:	0f 93       	push	r16
     45a:	1f 93       	push	r17
     45c:	2f 93       	push	r18
     45e:	3f 93       	push	r19
     460:	4f 93       	push	r20
     462:	5f 93       	push	r21
     464:	6f 93       	push	r22
     466:	7f 93       	push	r23
     468:	8f 93       	push	r24
     46a:	9f 93       	push	r25
     46c:	af 93       	push	r26
     46e:	bf 93       	push	r27
     470:	cf 93       	push	r28
     472:	df 93       	push	r29
     474:	ef 93       	push	r30
     476:	ff 93       	push	r31
     478:	a0 91 26 08 	lds	r26, 0x0826	; 0x800826 <pxCurrentTCB>
     47c:	b0 91 27 08 	lds	r27, 0x0827	; 0x800827 <pxCurrentTCB+0x1>
     480:	0d b6       	in	r0, 0x3d	; 61
     482:	0d 92       	st	X+, r0
     484:	0e b6       	in	r0, 0x3e	; 62
     486:	0d 92       	st	X+, r0
	xTaskIncrementTick();
     488:	0e 94 82 06 	call	0xd04	; 0xd04 <xTaskIncrementTick>
	vTaskSwitchContext();
     48c:	0e 94 0f 08 	call	0x101e	; 0x101e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     490:	a0 91 26 08 	lds	r26, 0x0826	; 0x800826 <pxCurrentTCB>
     494:	b0 91 27 08 	lds	r27, 0x0827	; 0x800827 <pxCurrentTCB+0x1>
     498:	cd 91       	ld	r28, X+
     49a:	cd bf       	out	0x3d, r28	; 61
     49c:	dd 91       	ld	r29, X+
     49e:	de bf       	out	0x3e, r29	; 62
     4a0:	ff 91       	pop	r31
     4a2:	ef 91       	pop	r30
     4a4:	df 91       	pop	r29
     4a6:	cf 91       	pop	r28
     4a8:	bf 91       	pop	r27
     4aa:	af 91       	pop	r26
     4ac:	9f 91       	pop	r25
     4ae:	8f 91       	pop	r24
     4b0:	7f 91       	pop	r23
     4b2:	6f 91       	pop	r22
     4b4:	5f 91       	pop	r21
     4b6:	4f 91       	pop	r20
     4b8:	3f 91       	pop	r19
     4ba:	2f 91       	pop	r18
     4bc:	1f 91       	pop	r17
     4be:	0f 91       	pop	r16
     4c0:	ff 90       	pop	r15
     4c2:	ef 90       	pop	r14
     4c4:	df 90       	pop	r13
     4c6:	cf 90       	pop	r12
     4c8:	bf 90       	pop	r11
     4ca:	af 90       	pop	r10
     4cc:	9f 90       	pop	r9
     4ce:	8f 90       	pop	r8
     4d0:	7f 90       	pop	r7
     4d2:	6f 90       	pop	r6
     4d4:	5f 90       	pop	r5
     4d6:	4f 90       	pop	r4
     4d8:	3f 90       	pop	r3
     4da:	2f 90       	pop	r2
     4dc:	1f 90       	pop	r1
     4de:	0f 90       	pop	r0
     4e0:	0f be       	out	0x3f, r0	; 63
     4e2:	0f 90       	pop	r0

	asm volatile ( "ret" );
     4e4:	08 95       	ret

000004e6 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     4e6:	0e 94 18 02 	call	0x430	; 0x430 <vPortYieldFromTick>
		asm volatile ( "reti" );
     4ea:	18 95       	reti

000004ec <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     4ec:	0f 93       	push	r16
     4ee:	1f 93       	push	r17
     4f0:	cf 93       	push	r28
     4f2:	df 93       	push	r29
     4f4:	ec 01       	movw	r28, r24
     4f6:	04 2f       	mov	r16, r20
     4f8:	1a 8d       	ldd	r17, Y+26	; 0x1a
     4fa:	4c 8d       	ldd	r20, Y+28	; 0x1c
     4fc:	44 23       	and	r20, r20
     4fe:	b9 f1       	breq	.+110    	; 0x56e <prvCopyDataToQueue+0x82>
     500:	01 11       	cpse	r16, r1
     502:	16 c0       	rjmp	.+44     	; 0x530 <prvCopyDataToQueue+0x44>
     504:	50 e0       	ldi	r21, 0x00	; 0
     506:	8c 81       	ldd	r24, Y+4	; 0x04
     508:	9d 81       	ldd	r25, Y+5	; 0x05
     50a:	0e 94 76 0b 	call	0x16ec	; 0x16ec <memcpy>
     50e:	2c 8d       	ldd	r18, Y+28	; 0x1c
     510:	8c 81       	ldd	r24, Y+4	; 0x04
     512:	9d 81       	ldd	r25, Y+5	; 0x05
     514:	82 0f       	add	r24, r18
     516:	91 1d       	adc	r25, r1
     518:	9d 83       	std	Y+5, r25	; 0x05
     51a:	8c 83       	std	Y+4, r24	; 0x04
     51c:	2a 81       	ldd	r18, Y+2	; 0x02
     51e:	3b 81       	ldd	r19, Y+3	; 0x03
     520:	82 17       	cp	r24, r18
     522:	93 07       	cpc	r25, r19
     524:	20 f1       	brcs	.+72     	; 0x56e <prvCopyDataToQueue+0x82>
     526:	88 81       	ld	r24, Y
     528:	99 81       	ldd	r25, Y+1	; 0x01
     52a:	9d 83       	std	Y+5, r25	; 0x05
     52c:	8c 83       	std	Y+4, r24	; 0x04
     52e:	1f c0       	rjmp	.+62     	; 0x56e <prvCopyDataToQueue+0x82>
     530:	50 e0       	ldi	r21, 0x00	; 0
     532:	8e 81       	ldd	r24, Y+6	; 0x06
     534:	9f 81       	ldd	r25, Y+7	; 0x07
     536:	0e 94 76 0b 	call	0x16ec	; 0x16ec <memcpy>
     53a:	8c 8d       	ldd	r24, Y+28	; 0x1c
     53c:	90 e0       	ldi	r25, 0x00	; 0
     53e:	91 95       	neg	r25
     540:	81 95       	neg	r24
     542:	91 09       	sbc	r25, r1
     544:	2e 81       	ldd	r18, Y+6	; 0x06
     546:	3f 81       	ldd	r19, Y+7	; 0x07
     548:	28 0f       	add	r18, r24
     54a:	39 1f       	adc	r19, r25
     54c:	3f 83       	std	Y+7, r19	; 0x07
     54e:	2e 83       	std	Y+6, r18	; 0x06
     550:	48 81       	ld	r20, Y
     552:	59 81       	ldd	r21, Y+1	; 0x01
     554:	24 17       	cp	r18, r20
     556:	35 07       	cpc	r19, r21
     558:	30 f4       	brcc	.+12     	; 0x566 <prvCopyDataToQueue+0x7a>
     55a:	2a 81       	ldd	r18, Y+2	; 0x02
     55c:	3b 81       	ldd	r19, Y+3	; 0x03
     55e:	82 0f       	add	r24, r18
     560:	93 1f       	adc	r25, r19
     562:	9f 83       	std	Y+7, r25	; 0x07
     564:	8e 83       	std	Y+6, r24	; 0x06
     566:	02 30       	cpi	r16, 0x02	; 2
     568:	11 f4       	brne	.+4      	; 0x56e <prvCopyDataToQueue+0x82>
     56a:	11 11       	cpse	r17, r1
     56c:	11 50       	subi	r17, 0x01	; 1
     56e:	1f 5f       	subi	r17, 0xFF	; 255
     570:	1a 8f       	std	Y+26, r17	; 0x1a
     572:	80 e0       	ldi	r24, 0x00	; 0
     574:	df 91       	pop	r29
     576:	cf 91       	pop	r28
     578:	1f 91       	pop	r17
     57a:	0f 91       	pop	r16
     57c:	08 95       	ret

0000057e <prvCopyDataFromQueue>:
     57e:	fc 01       	movw	r30, r24
     580:	44 8d       	ldd	r20, Z+28	; 0x1c
     582:	44 23       	and	r20, r20
     584:	a9 f0       	breq	.+42     	; 0x5b0 <prvCopyDataFromQueue+0x32>
     586:	50 e0       	ldi	r21, 0x00	; 0
     588:	26 81       	ldd	r18, Z+6	; 0x06
     58a:	37 81       	ldd	r19, Z+7	; 0x07
     58c:	24 0f       	add	r18, r20
     58e:	35 1f       	adc	r19, r21
     590:	37 83       	std	Z+7, r19	; 0x07
     592:	26 83       	std	Z+6, r18	; 0x06
     594:	82 81       	ldd	r24, Z+2	; 0x02
     596:	93 81       	ldd	r25, Z+3	; 0x03
     598:	28 17       	cp	r18, r24
     59a:	39 07       	cpc	r19, r25
     59c:	20 f0       	brcs	.+8      	; 0x5a6 <prvCopyDataFromQueue+0x28>
     59e:	80 81       	ld	r24, Z
     5a0:	91 81       	ldd	r25, Z+1	; 0x01
     5a2:	97 83       	std	Z+7, r25	; 0x07
     5a4:	86 83       	std	Z+6, r24	; 0x06
     5a6:	cb 01       	movw	r24, r22
     5a8:	66 81       	ldd	r22, Z+6	; 0x06
     5aa:	77 81       	ldd	r23, Z+7	; 0x07
     5ac:	0e 94 76 0b 	call	0x16ec	; 0x16ec <memcpy>
     5b0:	08 95       	ret

000005b2 <prvUnlockQueue>:
     5b2:	ef 92       	push	r14
     5b4:	ff 92       	push	r15
     5b6:	0f 93       	push	r16
     5b8:	1f 93       	push	r17
     5ba:	cf 93       	push	r28
     5bc:	8c 01       	movw	r16, r24
     5be:	0f b6       	in	r0, 0x3f	; 63
     5c0:	f8 94       	cli
     5c2:	0f 92       	push	r0
     5c4:	fc 01       	movw	r30, r24
     5c6:	c6 8d       	ldd	r28, Z+30	; 0x1e
     5c8:	1c 16       	cp	r1, r28
     5ca:	ac f4       	brge	.+42     	; 0x5f6 <prvUnlockQueue+0x44>
     5cc:	81 89       	ldd	r24, Z+17	; 0x11
     5ce:	81 11       	cpse	r24, r1
     5d0:	06 c0       	rjmp	.+12     	; 0x5de <prvUnlockQueue+0x2c>
     5d2:	11 c0       	rjmp	.+34     	; 0x5f6 <prvUnlockQueue+0x44>
     5d4:	f8 01       	movw	r30, r16
     5d6:	81 89       	ldd	r24, Z+17	; 0x11
     5d8:	81 11       	cpse	r24, r1
     5da:	05 c0       	rjmp	.+10     	; 0x5e6 <prvUnlockQueue+0x34>
     5dc:	0c c0       	rjmp	.+24     	; 0x5f6 <prvUnlockQueue+0x44>
     5de:	78 01       	movw	r14, r16
     5e0:	f1 e1       	ldi	r31, 0x11	; 17
     5e2:	ef 0e       	add	r14, r31
     5e4:	f1 1c       	adc	r15, r1
     5e6:	c7 01       	movw	r24, r14
     5e8:	0e 94 d5 08 	call	0x11aa	; 0x11aa <xTaskRemoveFromEventList>
     5ec:	81 11       	cpse	r24, r1
     5ee:	0e 94 61 09 	call	0x12c2	; 0x12c2 <vTaskMissedYield>
     5f2:	c1 50       	subi	r28, 0x01	; 1
     5f4:	79 f7       	brne	.-34     	; 0x5d4 <prvUnlockQueue+0x22>
     5f6:	8f ef       	ldi	r24, 0xFF	; 255
     5f8:	f8 01       	movw	r30, r16
     5fa:	86 8f       	std	Z+30, r24	; 0x1e
     5fc:	0f 90       	pop	r0
     5fe:	0f be       	out	0x3f, r0	; 63
     600:	0f b6       	in	r0, 0x3f	; 63
     602:	f8 94       	cli
     604:	0f 92       	push	r0
     606:	c5 8d       	ldd	r28, Z+29	; 0x1d
     608:	1c 16       	cp	r1, r28
     60a:	ac f4       	brge	.+42     	; 0x636 <prvUnlockQueue+0x84>
     60c:	80 85       	ldd	r24, Z+8	; 0x08
     60e:	81 11       	cpse	r24, r1
     610:	06 c0       	rjmp	.+12     	; 0x61e <prvUnlockQueue+0x6c>
     612:	11 c0       	rjmp	.+34     	; 0x636 <prvUnlockQueue+0x84>
     614:	f8 01       	movw	r30, r16
     616:	80 85       	ldd	r24, Z+8	; 0x08
     618:	81 11       	cpse	r24, r1
     61a:	05 c0       	rjmp	.+10     	; 0x626 <prvUnlockQueue+0x74>
     61c:	0c c0       	rjmp	.+24     	; 0x636 <prvUnlockQueue+0x84>
     61e:	78 01       	movw	r14, r16
     620:	f8 e0       	ldi	r31, 0x08	; 8
     622:	ef 0e       	add	r14, r31
     624:	f1 1c       	adc	r15, r1
     626:	c7 01       	movw	r24, r14
     628:	0e 94 d5 08 	call	0x11aa	; 0x11aa <xTaskRemoveFromEventList>
     62c:	81 11       	cpse	r24, r1
     62e:	0e 94 61 09 	call	0x12c2	; 0x12c2 <vTaskMissedYield>
     632:	c1 50       	subi	r28, 0x01	; 1
     634:	79 f7       	brne	.-34     	; 0x614 <prvUnlockQueue+0x62>
     636:	8f ef       	ldi	r24, 0xFF	; 255
     638:	f8 01       	movw	r30, r16
     63a:	85 8f       	std	Z+29, r24	; 0x1d
     63c:	0f 90       	pop	r0
     63e:	0f be       	out	0x3f, r0	; 63
     640:	cf 91       	pop	r28
     642:	1f 91       	pop	r17
     644:	0f 91       	pop	r16
     646:	ff 90       	pop	r15
     648:	ef 90       	pop	r14
     64a:	08 95       	ret

0000064c <xQueueGenericReset>:
     64c:	cf 93       	push	r28
     64e:	df 93       	push	r29
     650:	ec 01       	movw	r28, r24
     652:	0f b6       	in	r0, 0x3f	; 63
     654:	f8 94       	cli
     656:	0f 92       	push	r0
     658:	48 81       	ld	r20, Y
     65a:	59 81       	ldd	r21, Y+1	; 0x01
     65c:	2c 8d       	ldd	r18, Y+28	; 0x1c
     65e:	30 e0       	ldi	r19, 0x00	; 0
     660:	7b 8d       	ldd	r23, Y+27	; 0x1b
     662:	72 9f       	mul	r23, r18
     664:	c0 01       	movw	r24, r0
     666:	73 9f       	mul	r23, r19
     668:	90 0d       	add	r25, r0
     66a:	11 24       	eor	r1, r1
     66c:	fa 01       	movw	r30, r20
     66e:	e8 0f       	add	r30, r24
     670:	f9 1f       	adc	r31, r25
     672:	fb 83       	std	Y+3, r31	; 0x03
     674:	ea 83       	std	Y+2, r30	; 0x02
     676:	1a 8e       	std	Y+26, r1	; 0x1a
     678:	5d 83       	std	Y+5, r21	; 0x05
     67a:	4c 83       	std	Y+4, r20	; 0x04
     67c:	82 1b       	sub	r24, r18
     67e:	93 0b       	sbc	r25, r19
     680:	84 0f       	add	r24, r20
     682:	95 1f       	adc	r25, r21
     684:	9f 83       	std	Y+7, r25	; 0x07
     686:	8e 83       	std	Y+6, r24	; 0x06
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	8d 8f       	std	Y+29, r24	; 0x1d
     68c:	8e 8f       	std	Y+30, r24	; 0x1e
     68e:	61 11       	cpse	r22, r1
     690:	0c c0       	rjmp	.+24     	; 0x6aa <xQueueGenericReset+0x5e>
     692:	88 85       	ldd	r24, Y+8	; 0x08
     694:	88 23       	and	r24, r24
     696:	89 f0       	breq	.+34     	; 0x6ba <xQueueGenericReset+0x6e>
     698:	ce 01       	movw	r24, r28
     69a:	08 96       	adiw	r24, 0x08	; 8
     69c:	0e 94 d5 08 	call	0x11aa	; 0x11aa <xTaskRemoveFromEventList>
     6a0:	88 23       	and	r24, r24
     6a2:	59 f0       	breq	.+22     	; 0x6ba <xQueueGenericReset+0x6e>
     6a4:	0e 94 bf 01 	call	0x37e	; 0x37e <vPortYield>
     6a8:	08 c0       	rjmp	.+16     	; 0x6ba <xQueueGenericReset+0x6e>
     6aa:	ce 01       	movw	r24, r28
     6ac:	08 96       	adiw	r24, 0x08	; 8
     6ae:	0e 94 53 00 	call	0xa6	; 0xa6 <vListInitialise>
     6b2:	ce 01       	movw	r24, r28
     6b4:	41 96       	adiw	r24, 0x11	; 17
     6b6:	0e 94 53 00 	call	0xa6	; 0xa6 <vListInitialise>
     6ba:	0f 90       	pop	r0
     6bc:	0f be       	out	0x3f, r0	; 63
     6be:	81 e0       	ldi	r24, 0x01	; 1
     6c0:	df 91       	pop	r29
     6c2:	cf 91       	pop	r28
     6c4:	08 95       	ret

000006c6 <xQueueGenericCreate>:
     6c6:	0f 93       	push	r16
     6c8:	1f 93       	push	r17
     6ca:	cf 93       	push	r28
     6cc:	df 93       	push	r29
     6ce:	08 2f       	mov	r16, r24
     6d0:	16 2f       	mov	r17, r22
     6d2:	66 23       	and	r22, r22
     6d4:	c1 f0       	breq	.+48     	; 0x706 <xQueueGenericCreate+0x40>
     6d6:	86 9f       	mul	r24, r22
     6d8:	c0 01       	movw	r24, r0
     6da:	11 24       	eor	r1, r1
     6dc:	4f 96       	adiw	r24, 0x1f	; 31
     6de:	0e 94 dd 00 	call	0x1ba	; 0x1ba <pvPortMalloc>
     6e2:	ec 01       	movw	r28, r24
     6e4:	00 97       	sbiw	r24, 0x00	; 0
     6e6:	41 f4       	brne	.+16     	; 0x6f8 <xQueueGenericCreate+0x32>
     6e8:	15 c0       	rjmp	.+42     	; 0x714 <xQueueGenericCreate+0x4e>
     6ea:	0b 8f       	std	Y+27, r16	; 0x1b
     6ec:	1c 8f       	std	Y+28, r17	; 0x1c
     6ee:	61 e0       	ldi	r22, 0x01	; 1
     6f0:	ce 01       	movw	r24, r28
     6f2:	0e 94 26 03 	call	0x64c	; 0x64c <xQueueGenericReset>
     6f6:	0e c0       	rjmp	.+28     	; 0x714 <xQueueGenericCreate+0x4e>
     6f8:	4f 96       	adiw	r24, 0x1f	; 31
     6fa:	99 83       	std	Y+1, r25	; 0x01
     6fc:	88 83       	st	Y, r24
     6fe:	f5 cf       	rjmp	.-22     	; 0x6ea <xQueueGenericCreate+0x24>
     700:	d9 83       	std	Y+1, r29	; 0x01
     702:	c8 83       	st	Y, r28
     704:	f2 cf       	rjmp	.-28     	; 0x6ea <xQueueGenericCreate+0x24>
     706:	8f e1       	ldi	r24, 0x1F	; 31
     708:	90 e0       	ldi	r25, 0x00	; 0
     70a:	0e 94 dd 00 	call	0x1ba	; 0x1ba <pvPortMalloc>
     70e:	ec 01       	movw	r28, r24
     710:	89 2b       	or	r24, r25
     712:	b1 f7       	brne	.-20     	; 0x700 <xQueueGenericCreate+0x3a>
     714:	ce 01       	movw	r24, r28
     716:	df 91       	pop	r29
     718:	cf 91       	pop	r28
     71a:	1f 91       	pop	r17
     71c:	0f 91       	pop	r16
     71e:	08 95       	ret

00000720 <xQueueGenericSendFromISR>:
     720:	ef 92       	push	r14
     722:	ff 92       	push	r15
     724:	0f 93       	push	r16
     726:	1f 93       	push	r17
     728:	cf 93       	push	r28
     72a:	df 93       	push	r29
     72c:	8a 01       	movw	r16, r20
     72e:	fc 01       	movw	r30, r24
     730:	52 8d       	ldd	r21, Z+26	; 0x1a
     732:	33 8d       	ldd	r19, Z+27	; 0x1b
     734:	53 17       	cp	r21, r19
     736:	10 f0       	brcs	.+4      	; 0x73c <xQueueGenericSendFromISR+0x1c>
     738:	22 30       	cpi	r18, 0x02	; 2
     73a:	f1 f4       	brne	.+60     	; 0x778 <xQueueGenericSendFromISR+0x58>
     73c:	42 2f       	mov	r20, r18
     73e:	78 01       	movw	r14, r16
     740:	ec 01       	movw	r28, r24
     742:	1e 8d       	ldd	r17, Y+30	; 0x1e
     744:	0e 94 76 02 	call	0x4ec	; 0x4ec <prvCopyDataToQueue>
     748:	1f 3f       	cpi	r17, 0xFF	; 255
     74a:	81 f4       	brne	.+32     	; 0x76c <xQueueGenericSendFromISR+0x4c>
     74c:	89 89       	ldd	r24, Y+17	; 0x11
     74e:	88 23       	and	r24, r24
     750:	a9 f0       	breq	.+42     	; 0x77c <xQueueGenericSendFromISR+0x5c>
     752:	ce 01       	movw	r24, r28
     754:	41 96       	adiw	r24, 0x11	; 17
     756:	0e 94 d5 08 	call	0x11aa	; 0x11aa <xTaskRemoveFromEventList>
     75a:	88 23       	and	r24, r24
     75c:	89 f0       	breq	.+34     	; 0x780 <xQueueGenericSendFromISR+0x60>
     75e:	e1 14       	cp	r14, r1
     760:	f1 04       	cpc	r15, r1
     762:	81 f0       	breq	.+32     	; 0x784 <xQueueGenericSendFromISR+0x64>
     764:	81 e0       	ldi	r24, 0x01	; 1
     766:	f7 01       	movw	r30, r14
     768:	80 83       	st	Z, r24
     76a:	0d c0       	rjmp	.+26     	; 0x786 <xQueueGenericSendFromISR+0x66>
     76c:	ff 24       	eor	r15, r15
     76e:	f3 94       	inc	r15
     770:	f1 0e       	add	r15, r17
     772:	fe 8e       	std	Y+30, r15	; 0x1e
     774:	81 e0       	ldi	r24, 0x01	; 1
     776:	07 c0       	rjmp	.+14     	; 0x786 <xQueueGenericSendFromISR+0x66>
     778:	80 e0       	ldi	r24, 0x00	; 0
     77a:	05 c0       	rjmp	.+10     	; 0x786 <xQueueGenericSendFromISR+0x66>
     77c:	81 e0       	ldi	r24, 0x01	; 1
     77e:	03 c0       	rjmp	.+6      	; 0x786 <xQueueGenericSendFromISR+0x66>
     780:	81 e0       	ldi	r24, 0x01	; 1
     782:	01 c0       	rjmp	.+2      	; 0x786 <xQueueGenericSendFromISR+0x66>
     784:	81 e0       	ldi	r24, 0x01	; 1
     786:	df 91       	pop	r29
     788:	cf 91       	pop	r28
     78a:	1f 91       	pop	r17
     78c:	0f 91       	pop	r16
     78e:	ff 90       	pop	r15
     790:	ef 90       	pop	r14
     792:	08 95       	ret

00000794 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     794:	8f 92       	push	r8
     796:	9f 92       	push	r9
     798:	af 92       	push	r10
     79a:	bf 92       	push	r11
     79c:	cf 92       	push	r12
     79e:	df 92       	push	r13
     7a0:	ef 92       	push	r14
     7a2:	ff 92       	push	r15
     7a4:	0f 93       	push	r16
     7a6:	1f 93       	push	r17
     7a8:	cf 93       	push	r28
     7aa:	df 93       	push	r29
     7ac:	00 d0       	rcall	.+0      	; 0x7ae <xQueueGenericReceive+0x1a>
     7ae:	00 d0       	rcall	.+0      	; 0x7b0 <xQueueGenericReceive+0x1c>
     7b0:	1f 92       	push	r1
     7b2:	cd b7       	in	r28, 0x3d	; 61
     7b4:	de b7       	in	r29, 0x3e	; 62
     7b6:	8c 01       	movw	r16, r24
     7b8:	5b 01       	movw	r10, r22
     7ba:	5d 83       	std	Y+5, r21	; 0x05
     7bc:	4c 83       	std	Y+4, r20	; 0x04
     7be:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
     7c0:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     7c2:	99 24       	eor	r9, r9
     7c4:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     7c6:	6c 01       	movw	r12, r24
     7c8:	81 e1       	ldi	r24, 0x11	; 17
     7ca:	c8 0e       	add	r12, r24
     7cc:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     7ce:	0f b6       	in	r0, 0x3f	; 63
     7d0:	f8 94       	cli
     7d2:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     7d4:	f8 01       	movw	r30, r16
     7d6:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     7d8:	ff 20       	and	r15, r15
     7da:	41 f1       	breq	.+80     	; 0x82c <xQueueGenericReceive+0x98>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     7dc:	c6 80       	ldd	r12, Z+6	; 0x06
     7de:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     7e0:	b5 01       	movw	r22, r10
     7e2:	c8 01       	movw	r24, r16
     7e4:	0e 94 bf 02 	call	0x57e	; 0x57e <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     7e8:	81 10       	cpse	r8, r1
     7ea:	0f c0       	rjmp	.+30     	; 0x80a <xQueueGenericReceive+0x76>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     7ec:	fa 94       	dec	r15
     7ee:	f8 01       	movw	r30, r16
     7f0:	f2 8e       	std	Z+26, r15	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     7f2:	80 85       	ldd	r24, Z+8	; 0x08
     7f4:	88 23       	and	r24, r24
     7f6:	b1 f0       	breq	.+44     	; 0x824 <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     7f8:	c8 01       	movw	r24, r16
     7fa:	08 96       	adiw	r24, 0x08	; 8
     7fc:	0e 94 d5 08 	call	0x11aa	; 0x11aa <xTaskRemoveFromEventList>
     800:	88 23       	and	r24, r24
     802:	81 f0       	breq	.+32     	; 0x824 <xQueueGenericReceive+0x90>
						{
							queueYIELD_IF_USING_PREEMPTION();
     804:	0e 94 bf 01 	call	0x37e	; 0x37e <vPortYield>
     808:	0d c0       	rjmp	.+26     	; 0x824 <xQueueGenericReceive+0x90>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     80a:	f8 01       	movw	r30, r16
     80c:	d7 82       	std	Z+7, r13	; 0x07
     80e:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     810:	81 89       	ldd	r24, Z+17	; 0x11
     812:	88 23       	and	r24, r24
     814:	39 f0       	breq	.+14     	; 0x824 <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     816:	c8 01       	movw	r24, r16
     818:	41 96       	adiw	r24, 0x11	; 17
     81a:	0e 94 d5 08 	call	0x11aa	; 0x11aa <xTaskRemoveFromEventList>
     81e:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     820:	0e 94 bf 01 	call	0x37e	; 0x37e <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     824:	0f 90       	pop	r0
     826:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     828:	81 e0       	ldi	r24, 0x01	; 1
     82a:	57 c0       	rjmp	.+174    	; 0x8da <xQueueGenericReceive+0x146>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     82c:	8c 81       	ldd	r24, Y+4	; 0x04
     82e:	9d 81       	ldd	r25, Y+5	; 0x05
     830:	89 2b       	or	r24, r25
     832:	21 f4       	brne	.+8      	; 0x83c <xQueueGenericReceive+0xa8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     834:	0f 90       	pop	r0
     836:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     838:	80 e0       	ldi	r24, 0x00	; 0
     83a:	4f c0       	rjmp	.+158    	; 0x8da <xQueueGenericReceive+0x146>
				}
				else if( xEntryTimeSet == pdFALSE )
     83c:	e1 10       	cpse	r14, r1
     83e:	05 c0       	rjmp	.+10     	; 0x84a <xQueueGenericReceive+0xb6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     840:	ce 01       	movw	r24, r28
     842:	01 96       	adiw	r24, 0x01	; 1
     844:	0e 94 1d 09 	call	0x123a	; 0x123a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     848:	e9 2c       	mov	r14, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     84a:	0f 90       	pop	r0
     84c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     84e:	0e 94 7c 06 	call	0xcf8	; 0xcf8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     852:	0f b6       	in	r0, 0x3f	; 63
     854:	f8 94       	cli
     856:	0f 92       	push	r0
     858:	f8 01       	movw	r30, r16
     85a:	85 8d       	ldd	r24, Z+29	; 0x1d
     85c:	8f 3f       	cpi	r24, 0xFF	; 255
     85e:	09 f4       	brne	.+2      	; 0x862 <xQueueGenericReceive+0xce>
     860:	15 8e       	std	Z+29, r1	; 0x1d
     862:	f8 01       	movw	r30, r16
     864:	86 8d       	ldd	r24, Z+30	; 0x1e
     866:	8f 3f       	cpi	r24, 0xFF	; 255
     868:	09 f4       	brne	.+2      	; 0x86c <xQueueGenericReceive+0xd8>
     86a:	16 8e       	std	Z+30, r1	; 0x1e
     86c:	0f 90       	pop	r0
     86e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     870:	be 01       	movw	r22, r28
     872:	6c 5f       	subi	r22, 0xFC	; 252
     874:	7f 4f       	sbci	r23, 0xFF	; 255
     876:	ce 01       	movw	r24, r28
     878:	01 96       	adiw	r24, 0x01	; 1
     87a:	0e 94 28 09 	call	0x1250	; 0x1250 <xTaskCheckForTimeOut>
     87e:	81 11       	cpse	r24, r1
     880:	1e c0       	rjmp	.+60     	; 0x8be <xQueueGenericReceive+0x12a>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     882:	0f b6       	in	r0, 0x3f	; 63
     884:	f8 94       	cli
     886:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     888:	f8 01       	movw	r30, r16
     88a:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     88c:	0f 90       	pop	r0
     88e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     890:	81 11       	cpse	r24, r1
     892:	0f c0       	rjmp	.+30     	; 0x8b2 <xQueueGenericReceive+0x11e>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     894:	6c 81       	ldd	r22, Y+4	; 0x04
     896:	7d 81       	ldd	r23, Y+5	; 0x05
     898:	c6 01       	movw	r24, r12
     89a:	0e 94 c3 08 	call	0x1186	; 0x1186 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     89e:	c8 01       	movw	r24, r16
     8a0:	0e 94 d9 02 	call	0x5b2	; 0x5b2 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     8a4:	0e 94 3d 07 	call	0xe7a	; 0xe7a <xTaskResumeAll>
     8a8:	81 11       	cpse	r24, r1
     8aa:	91 cf       	rjmp	.-222    	; 0x7ce <xQueueGenericReceive+0x3a>
				{
					portYIELD_WITHIN_API();
     8ac:	0e 94 bf 01 	call	0x37e	; 0x37e <vPortYield>
     8b0:	8e cf       	rjmp	.-228    	; 0x7ce <xQueueGenericReceive+0x3a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     8b2:	c8 01       	movw	r24, r16
     8b4:	0e 94 d9 02 	call	0x5b2	; 0x5b2 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     8b8:	0e 94 3d 07 	call	0xe7a	; 0xe7a <xTaskResumeAll>
     8bc:	88 cf       	rjmp	.-240    	; 0x7ce <xQueueGenericReceive+0x3a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     8be:	c8 01       	movw	r24, r16
     8c0:	0e 94 d9 02 	call	0x5b2	; 0x5b2 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     8c4:	0e 94 3d 07 	call	0xe7a	; 0xe7a <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     8c8:	0f b6       	in	r0, 0x3f	; 63
     8ca:	f8 94       	cli
     8cc:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     8ce:	f8 01       	movw	r30, r16
     8d0:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     8d2:	0f 90       	pop	r0
     8d4:	0f be       	out	0x3f, r0	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     8d6:	81 11       	cpse	r24, r1
     8d8:	7a cf       	rjmp	.-268    	; 0x7ce <xQueueGenericReceive+0x3a>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
     8da:	0f 90       	pop	r0
     8dc:	0f 90       	pop	r0
     8de:	0f 90       	pop	r0
     8e0:	0f 90       	pop	r0
     8e2:	0f 90       	pop	r0
     8e4:	df 91       	pop	r29
     8e6:	cf 91       	pop	r28
     8e8:	1f 91       	pop	r17
     8ea:	0f 91       	pop	r16
     8ec:	ff 90       	pop	r15
     8ee:	ef 90       	pop	r14
     8f0:	df 90       	pop	r13
     8f2:	cf 90       	pop	r12
     8f4:	bf 90       	pop	r11
     8f6:	af 90       	pop	r10
     8f8:	9f 90       	pop	r9
     8fa:	8f 90       	pop	r8
     8fc:	08 95       	ret

000008fe <prvResetNextTaskUnblockTime>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     8fe:	e0 91 ee 07 	lds	r30, 0x07EE	; 0x8007ee <pxDelayedTaskList>
     902:	f0 91 ef 07 	lds	r31, 0x07EF	; 0x8007ef <pxDelayedTaskList+0x1>
     906:	80 81       	ld	r24, Z
     908:	81 11       	cpse	r24, r1
     90a:	07 c0       	rjmp	.+14     	; 0x91a <__stack+0x1b>
     90c:	8f ef       	ldi	r24, 0xFF	; 255
     90e:	9f ef       	ldi	r25, 0xFF	; 255
     910:	90 93 c6 07 	sts	0x07C6, r25	; 0x8007c6 <xNextTaskUnblockTime+0x1>
     914:	80 93 c5 07 	sts	0x07C5, r24	; 0x8007c5 <xNextTaskUnblockTime>
     918:	08 95       	ret
     91a:	e0 91 ee 07 	lds	r30, 0x07EE	; 0x8007ee <pxDelayedTaskList>
     91e:	f0 91 ef 07 	lds	r31, 0x07EF	; 0x8007ef <pxDelayedTaskList+0x1>
     922:	05 80       	ldd	r0, Z+5	; 0x05
     924:	f6 81       	ldd	r31, Z+6	; 0x06
     926:	e0 2d       	mov	r30, r0
     928:	06 80       	ldd	r0, Z+6	; 0x06
     92a:	f7 81       	ldd	r31, Z+7	; 0x07
     92c:	e0 2d       	mov	r30, r0
     92e:	82 81       	ldd	r24, Z+2	; 0x02
     930:	93 81       	ldd	r25, Z+3	; 0x03
     932:	90 93 c6 07 	sts	0x07C6, r25	; 0x8007c6 <xNextTaskUnblockTime+0x1>
     936:	80 93 c5 07 	sts	0x07C5, r24	; 0x8007c5 <xNextTaskUnblockTime>
     93a:	08 95       	ret

0000093c <prvAddCurrentTaskToDelayedList>:
     93c:	ff 92       	push	r15
     93e:	0f 93       	push	r16
     940:	1f 93       	push	r17
     942:	cf 93       	push	r28
     944:	df 93       	push	r29
     946:	ec 01       	movw	r28, r24
     948:	f6 2e       	mov	r15, r22
     94a:	00 91 cd 07 	lds	r16, 0x07CD	; 0x8007cd <xTickCount>
     94e:	10 91 ce 07 	lds	r17, 0x07CE	; 0x8007ce <xTickCount+0x1>
     952:	80 91 26 08 	lds	r24, 0x0826	; 0x800826 <pxCurrentTCB>
     956:	90 91 27 08 	lds	r25, 0x0827	; 0x800827 <pxCurrentTCB+0x1>
     95a:	02 96       	adiw	r24, 0x02	; 2
     95c:	0e 94 b7 00 	call	0x16e	; 0x16e <uxListRemove>
     960:	cf 3f       	cpi	r28, 0xFF	; 255
     962:	8f ef       	ldi	r24, 0xFF	; 255
     964:	d8 07       	cpc	r29, r24
     966:	69 f4       	brne	.+26     	; 0x982 <prvAddCurrentTaskToDelayedList+0x46>
     968:	ff 20       	and	r15, r15
     96a:	59 f0       	breq	.+22     	; 0x982 <prvAddCurrentTaskToDelayedList+0x46>
     96c:	60 91 26 08 	lds	r22, 0x0826	; 0x800826 <pxCurrentTCB>
     970:	70 91 27 08 	lds	r23, 0x0827	; 0x800827 <pxCurrentTCB+0x1>
     974:	6e 5f       	subi	r22, 0xFE	; 254
     976:	7f 4f       	sbci	r23, 0xFF	; 255
     978:	80 ed       	ldi	r24, 0xD0	; 208
     97a:	97 e0       	ldi	r25, 0x07	; 7
     97c:	0e 94 65 00 	call	0xca	; 0xca <vListInsertEnd>
     980:	2f c0       	rjmp	.+94     	; 0x9e0 <prvAddCurrentTaskToDelayedList+0xa4>
     982:	c0 0f       	add	r28, r16
     984:	d1 1f       	adc	r29, r17
     986:	e0 91 26 08 	lds	r30, 0x0826	; 0x800826 <pxCurrentTCB>
     98a:	f0 91 27 08 	lds	r31, 0x0827	; 0x800827 <pxCurrentTCB+0x1>
     98e:	d3 83       	std	Z+3, r29	; 0x03
     990:	c2 83       	std	Z+2, r28	; 0x02
     992:	c0 17       	cp	r28, r16
     994:	d1 07       	cpc	r29, r17
     996:	68 f4       	brcc	.+26     	; 0x9b2 <prvAddCurrentTaskToDelayedList+0x76>
     998:	60 91 26 08 	lds	r22, 0x0826	; 0x800826 <pxCurrentTCB>
     99c:	70 91 27 08 	lds	r23, 0x0827	; 0x800827 <pxCurrentTCB+0x1>
     9a0:	80 91 ec 07 	lds	r24, 0x07EC	; 0x8007ec <pxOverflowDelayedTaskList>
     9a4:	90 91 ed 07 	lds	r25, 0x07ED	; 0x8007ed <pxOverflowDelayedTaskList+0x1>
     9a8:	6e 5f       	subi	r22, 0xFE	; 254
     9aa:	7f 4f       	sbci	r23, 0xFF	; 255
     9ac:	0e 94 86 00 	call	0x10c	; 0x10c <vListInsert>
     9b0:	17 c0       	rjmp	.+46     	; 0x9e0 <prvAddCurrentTaskToDelayedList+0xa4>
     9b2:	60 91 26 08 	lds	r22, 0x0826	; 0x800826 <pxCurrentTCB>
     9b6:	70 91 27 08 	lds	r23, 0x0827	; 0x800827 <pxCurrentTCB+0x1>
     9ba:	80 91 ee 07 	lds	r24, 0x07EE	; 0x8007ee <pxDelayedTaskList>
     9be:	90 91 ef 07 	lds	r25, 0x07EF	; 0x8007ef <pxDelayedTaskList+0x1>
     9c2:	6e 5f       	subi	r22, 0xFE	; 254
     9c4:	7f 4f       	sbci	r23, 0xFF	; 255
     9c6:	0e 94 86 00 	call	0x10c	; 0x10c <vListInsert>
     9ca:	80 91 c5 07 	lds	r24, 0x07C5	; 0x8007c5 <xNextTaskUnblockTime>
     9ce:	90 91 c6 07 	lds	r25, 0x07C6	; 0x8007c6 <xNextTaskUnblockTime+0x1>
     9d2:	c8 17       	cp	r28, r24
     9d4:	d9 07       	cpc	r29, r25
     9d6:	20 f4       	brcc	.+8      	; 0x9e0 <prvAddCurrentTaskToDelayedList+0xa4>
     9d8:	d0 93 c6 07 	sts	0x07C6, r29	; 0x8007c6 <xNextTaskUnblockTime+0x1>
     9dc:	c0 93 c5 07 	sts	0x07C5, r28	; 0x8007c5 <xNextTaskUnblockTime>
     9e0:	df 91       	pop	r29
     9e2:	cf 91       	pop	r28
     9e4:	1f 91       	pop	r17
     9e6:	0f 91       	pop	r16
     9e8:	ff 90       	pop	r15
     9ea:	08 95       	ret

000009ec <xTaskCreate>:
     9ec:	4f 92       	push	r4
     9ee:	5f 92       	push	r5
     9f0:	6f 92       	push	r6
     9f2:	7f 92       	push	r7
     9f4:	8f 92       	push	r8
     9f6:	9f 92       	push	r9
     9f8:	af 92       	push	r10
     9fa:	bf 92       	push	r11
     9fc:	cf 92       	push	r12
     9fe:	df 92       	push	r13
     a00:	ef 92       	push	r14
     a02:	ff 92       	push	r15
     a04:	0f 93       	push	r16
     a06:	cf 93       	push	r28
     a08:	df 93       	push	r29
     a0a:	4c 01       	movw	r8, r24
     a0c:	6b 01       	movw	r12, r22
     a0e:	5a 01       	movw	r10, r20
     a10:	29 01       	movw	r4, r18
     a12:	ca 01       	movw	r24, r20
     a14:	0e 94 dd 00 	call	0x1ba	; 0x1ba <pvPortMalloc>
     a18:	3c 01       	movw	r6, r24
     a1a:	89 2b       	or	r24, r25
     a1c:	09 f4       	brne	.+2      	; 0xa20 <xTaskCreate+0x34>
     a1e:	e2 c0       	rjmp	.+452    	; 0xbe4 <xTaskCreate+0x1f8>
     a20:	86 e2       	ldi	r24, 0x26	; 38
     a22:	90 e0       	ldi	r25, 0x00	; 0
     a24:	0e 94 dd 00 	call	0x1ba	; 0x1ba <pvPortMalloc>
     a28:	ec 01       	movw	r28, r24
     a2a:	89 2b       	or	r24, r25
     a2c:	71 f0       	breq	.+28     	; 0xa4a <xTaskCreate+0x5e>
     a2e:	78 8e       	std	Y+24, r7	; 0x18
     a30:	6f 8a       	std	Y+23, r6	; 0x17
     a32:	81 e0       	ldi	r24, 0x01	; 1
     a34:	a8 1a       	sub	r10, r24
     a36:	b1 08       	sbc	r11, r1
     a38:	a6 0c       	add	r10, r6
     a3a:	b7 1c       	adc	r11, r7
     a3c:	d6 01       	movw	r26, r12
     a3e:	8c 91       	ld	r24, X
     a40:	89 8f       	std	Y+25, r24	; 0x19
     a42:	8c 91       	ld	r24, X
     a44:	81 11       	cpse	r24, r1
     a46:	05 c0       	rjmp	.+10     	; 0xa52 <xTaskCreate+0x66>
     a48:	18 c0       	rjmp	.+48     	; 0xa7a <xTaskCreate+0x8e>
     a4a:	c3 01       	movw	r24, r6
     a4c:	0e 94 12 01 	call	0x224	; 0x224 <vPortFree>
     a50:	c9 c0       	rjmp	.+402    	; 0xbe4 <xTaskCreate+0x1f8>
     a52:	ae 01       	movw	r20, r28
     a54:	46 5e       	subi	r20, 0xE6	; 230
     a56:	5f 4f       	sbci	r21, 0xFF	; 255
     a58:	f6 01       	movw	r30, r12
     a5a:	31 96       	adiw	r30, 0x01	; 1
     a5c:	b8 e0       	ldi	r27, 0x08	; 8
     a5e:	cb 0e       	add	r12, r27
     a60:	d1 1c       	adc	r13, r1
     a62:	cf 01       	movw	r24, r30
     a64:	21 91       	ld	r18, Z+
     a66:	da 01       	movw	r26, r20
     a68:	2d 93       	st	X+, r18
     a6a:	ad 01       	movw	r20, r26
     a6c:	dc 01       	movw	r26, r24
     a6e:	8c 91       	ld	r24, X
     a70:	88 23       	and	r24, r24
     a72:	19 f0       	breq	.+6      	; 0xa7a <xTaskCreate+0x8e>
     a74:	ec 15       	cp	r30, r12
     a76:	fd 05       	cpc	r31, r13
     a78:	a1 f7       	brne	.-24     	; 0xa62 <xTaskCreate+0x76>
     a7a:	18 a2       	std	Y+32, r1	; 0x20
     a7c:	04 30       	cpi	r16, 0x04	; 4
     a7e:	08 f0       	brcs	.+2      	; 0xa82 <xTaskCreate+0x96>
     a80:	03 e0       	ldi	r16, 0x03	; 3
     a82:	0e 8b       	std	Y+22, r16	; 0x16
     a84:	6e 01       	movw	r12, r28
     a86:	b2 e0       	ldi	r27, 0x02	; 2
     a88:	cb 0e       	add	r12, r27
     a8a:	d1 1c       	adc	r13, r1
     a8c:	c6 01       	movw	r24, r12
     a8e:	0e 94 61 00 	call	0xc2	; 0xc2 <vListInitialiseItem>
     a92:	ce 01       	movw	r24, r28
     a94:	0c 96       	adiw	r24, 0x0c	; 12
     a96:	0e 94 61 00 	call	0xc2	; 0xc2 <vListInitialiseItem>
     a9a:	d9 87       	std	Y+9, r29	; 0x09
     a9c:	c8 87       	std	Y+8, r28	; 0x08
     a9e:	84 e0       	ldi	r24, 0x04	; 4
     aa0:	90 e0       	ldi	r25, 0x00	; 0
     aa2:	80 1b       	sub	r24, r16
     aa4:	91 09       	sbc	r25, r1
     aa6:	9d 87       	std	Y+13, r25	; 0x0d
     aa8:	8c 87       	std	Y+12, r24	; 0x0c
     aaa:	db 8b       	std	Y+19, r29	; 0x13
     aac:	ca 8b       	std	Y+18, r28	; 0x12
     aae:	19 a2       	std	Y+33, r1	; 0x21
     ab0:	1a a2       	std	Y+34, r1	; 0x22
     ab2:	1b a2       	std	Y+35, r1	; 0x23
     ab4:	1c a2       	std	Y+36, r1	; 0x24
     ab6:	1d a2       	std	Y+37, r1	; 0x25
     ab8:	a2 01       	movw	r20, r4
     aba:	b4 01       	movw	r22, r8
     abc:	c5 01       	movw	r24, r10
     abe:	0e 94 13 01 	call	0x226	; 0x226 <pxPortInitialiseStack>
     ac2:	99 83       	std	Y+1, r25	; 0x01
     ac4:	88 83       	st	Y, r24
     ac6:	e1 14       	cp	r14, r1
     ac8:	f1 04       	cpc	r15, r1
     aca:	19 f0       	breq	.+6      	; 0xad2 <xTaskCreate+0xe6>
     acc:	f7 01       	movw	r30, r14
     ace:	d1 83       	std	Z+1, r29	; 0x01
     ad0:	c0 83       	st	Z, r28
     ad2:	0f b6       	in	r0, 0x3f	; 63
     ad4:	f8 94       	cli
     ad6:	0f 92       	push	r0
     ad8:	80 91 cf 07 	lds	r24, 0x07CF	; 0x8007cf <uxCurrentNumberOfTasks>
     adc:	8f 5f       	subi	r24, 0xFF	; 255
     ade:	80 93 cf 07 	sts	0x07CF, r24	; 0x8007cf <uxCurrentNumberOfTasks>
     ae2:	80 91 26 08 	lds	r24, 0x0826	; 0x800826 <pxCurrentTCB>
     ae6:	90 91 27 08 	lds	r25, 0x0827	; 0x800827 <pxCurrentTCB+0x1>
     aea:	89 2b       	or	r24, r25
     aec:	d1 f5       	brne	.+116    	; 0xb62 <xTaskCreate+0x176>
     aee:	d0 93 27 08 	sts	0x0827, r29	; 0x800827 <pxCurrentTCB+0x1>
     af2:	c0 93 26 08 	sts	0x0826, r28	; 0x800826 <pxCurrentTCB>
     af6:	80 91 cf 07 	lds	r24, 0x07CF	; 0x8007cf <uxCurrentNumberOfTasks>
     afa:	81 30       	cpi	r24, 0x01	; 1
     afc:	09 f0       	breq	.+2      	; 0xb00 <xTaskCreate+0x114>
     afe:	41 c0       	rjmp	.+130    	; 0xb82 <xTaskCreate+0x196>
     b00:	82 e0       	ldi	r24, 0x02	; 2
     b02:	98 e0       	ldi	r25, 0x08	; 8
     b04:	0e 94 53 00 	call	0xa6	; 0xa6 <vListInitialise>
     b08:	8b e0       	ldi	r24, 0x0B	; 11
     b0a:	98 e0       	ldi	r25, 0x08	; 8
     b0c:	0e 94 53 00 	call	0xa6	; 0xa6 <vListInitialise>
     b10:	84 e1       	ldi	r24, 0x14	; 20
     b12:	98 e0       	ldi	r25, 0x08	; 8
     b14:	0e 94 53 00 	call	0xa6	; 0xa6 <vListInitialise>
     b18:	8d e1       	ldi	r24, 0x1D	; 29
     b1a:	98 e0       	ldi	r25, 0x08	; 8
     b1c:	0e 94 53 00 	call	0xa6	; 0xa6 <vListInitialise>
     b20:	89 ef       	ldi	r24, 0xF9	; 249
     b22:	97 e0       	ldi	r25, 0x07	; 7
     b24:	0e 94 53 00 	call	0xa6	; 0xa6 <vListInitialise>
     b28:	80 ef       	ldi	r24, 0xF0	; 240
     b2a:	97 e0       	ldi	r25, 0x07	; 7
     b2c:	0e 94 53 00 	call	0xa6	; 0xa6 <vListInitialise>
     b30:	83 ee       	ldi	r24, 0xE3	; 227
     b32:	97 e0       	ldi	r25, 0x07	; 7
     b34:	0e 94 53 00 	call	0xa6	; 0xa6 <vListInitialise>
     b38:	8a ed       	ldi	r24, 0xDA	; 218
     b3a:	97 e0       	ldi	r25, 0x07	; 7
     b3c:	0e 94 53 00 	call	0xa6	; 0xa6 <vListInitialise>
     b40:	80 ed       	ldi	r24, 0xD0	; 208
     b42:	97 e0       	ldi	r25, 0x07	; 7
     b44:	0e 94 53 00 	call	0xa6	; 0xa6 <vListInitialise>
     b48:	89 ef       	ldi	r24, 0xF9	; 249
     b4a:	97 e0       	ldi	r25, 0x07	; 7
     b4c:	90 93 ef 07 	sts	0x07EF, r25	; 0x8007ef <pxDelayedTaskList+0x1>
     b50:	80 93 ee 07 	sts	0x07EE, r24	; 0x8007ee <pxDelayedTaskList>
     b54:	80 ef       	ldi	r24, 0xF0	; 240
     b56:	97 e0       	ldi	r25, 0x07	; 7
     b58:	90 93 ed 07 	sts	0x07ED, r25	; 0x8007ed <pxOverflowDelayedTaskList+0x1>
     b5c:	80 93 ec 07 	sts	0x07EC, r24	; 0x8007ec <pxOverflowDelayedTaskList>
     b60:	10 c0       	rjmp	.+32     	; 0xb82 <xTaskCreate+0x196>
     b62:	80 91 cb 07 	lds	r24, 0x07CB	; 0x8007cb <xSchedulerRunning>
     b66:	81 11       	cpse	r24, r1
     b68:	0c c0       	rjmp	.+24     	; 0xb82 <xTaskCreate+0x196>
     b6a:	e0 91 26 08 	lds	r30, 0x0826	; 0x800826 <pxCurrentTCB>
     b6e:	f0 91 27 08 	lds	r31, 0x0827	; 0x800827 <pxCurrentTCB+0x1>
     b72:	96 89       	ldd	r25, Z+22	; 0x16
     b74:	8e 89       	ldd	r24, Y+22	; 0x16
     b76:	89 17       	cp	r24, r25
     b78:	20 f0       	brcs	.+8      	; 0xb82 <xTaskCreate+0x196>
     b7a:	d0 93 27 08 	sts	0x0827, r29	; 0x800827 <pxCurrentTCB+0x1>
     b7e:	c0 93 26 08 	sts	0x0826, r28	; 0x800826 <pxCurrentTCB>
     b82:	80 91 c7 07 	lds	r24, 0x07C7	; 0x8007c7 <uxTaskNumber>
     b86:	8f 5f       	subi	r24, 0xFF	; 255
     b88:	80 93 c7 07 	sts	0x07C7, r24	; 0x8007c7 <uxTaskNumber>
     b8c:	8e 89       	ldd	r24, Y+22	; 0x16
     b8e:	90 91 cc 07 	lds	r25, 0x07CC	; 0x8007cc <uxTopReadyPriority>
     b92:	98 17       	cp	r25, r24
     b94:	10 f4       	brcc	.+4      	; 0xb9a <xTaskCreate+0x1ae>
     b96:	80 93 cc 07 	sts	0x07CC, r24	; 0x8007cc <uxTopReadyPriority>
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	9c 01       	movw	r18, r24
     b9e:	22 0f       	add	r18, r18
     ba0:	33 1f       	adc	r19, r19
     ba2:	22 0f       	add	r18, r18
     ba4:	33 1f       	adc	r19, r19
     ba6:	22 0f       	add	r18, r18
     ba8:	33 1f       	adc	r19, r19
     baa:	82 0f       	add	r24, r18
     bac:	93 1f       	adc	r25, r19
     bae:	b6 01       	movw	r22, r12
     bb0:	8e 5f       	subi	r24, 0xFE	; 254
     bb2:	97 4f       	sbci	r25, 0xF7	; 247
     bb4:	0e 94 65 00 	call	0xca	; 0xca <vListInsertEnd>
     bb8:	0f 90       	pop	r0
     bba:	0f be       	out	0x3f, r0	; 63
     bbc:	80 91 cb 07 	lds	r24, 0x07CB	; 0x8007cb <xSchedulerRunning>
     bc0:	88 23       	and	r24, r24
     bc2:	61 f0       	breq	.+24     	; 0xbdc <xTaskCreate+0x1f0>
     bc4:	e0 91 26 08 	lds	r30, 0x0826	; 0x800826 <pxCurrentTCB>
     bc8:	f0 91 27 08 	lds	r31, 0x0827	; 0x800827 <pxCurrentTCB+0x1>
     bcc:	96 89       	ldd	r25, Z+22	; 0x16
     bce:	8e 89       	ldd	r24, Y+22	; 0x16
     bd0:	98 17       	cp	r25, r24
     bd2:	30 f4       	brcc	.+12     	; 0xbe0 <xTaskCreate+0x1f4>
     bd4:	0e 94 bf 01 	call	0x37e	; 0x37e <vPortYield>
     bd8:	81 e0       	ldi	r24, 0x01	; 1
     bda:	05 c0       	rjmp	.+10     	; 0xbe6 <xTaskCreate+0x1fa>
     bdc:	81 e0       	ldi	r24, 0x01	; 1
     bde:	03 c0       	rjmp	.+6      	; 0xbe6 <xTaskCreate+0x1fa>
     be0:	81 e0       	ldi	r24, 0x01	; 1
     be2:	01 c0       	rjmp	.+2      	; 0xbe6 <xTaskCreate+0x1fa>
     be4:	8f ef       	ldi	r24, 0xFF	; 255
     be6:	df 91       	pop	r29
     be8:	cf 91       	pop	r28
     bea:	0f 91       	pop	r16
     bec:	ff 90       	pop	r15
     bee:	ef 90       	pop	r14
     bf0:	df 90       	pop	r13
     bf2:	cf 90       	pop	r12
     bf4:	bf 90       	pop	r11
     bf6:	af 90       	pop	r10
     bf8:	9f 90       	pop	r9
     bfa:	8f 90       	pop	r8
     bfc:	7f 90       	pop	r7
     bfe:	6f 90       	pop	r6
     c00:	5f 90       	pop	r5
     c02:	4f 90       	pop	r4
     c04:	08 95       	ret

00000c06 <vTaskResume>:
     c06:	0f 93       	push	r16
     c08:	1f 93       	push	r17
     c0a:	cf 93       	push	r28
     c0c:	df 93       	push	r29
     c0e:	00 97       	sbiw	r24, 0x00	; 0
     c10:	09 f4       	brne	.+2      	; 0xc14 <vTaskResume+0xe>
     c12:	43 c0       	rjmp	.+134    	; 0xc9a <vTaskResume+0x94>
     c14:	20 91 26 08 	lds	r18, 0x0826	; 0x800826 <pxCurrentTCB>
     c18:	30 91 27 08 	lds	r19, 0x0827	; 0x800827 <pxCurrentTCB+0x1>
     c1c:	82 17       	cp	r24, r18
     c1e:	93 07       	cpc	r25, r19
     c20:	09 f4       	brne	.+2      	; 0xc24 <vTaskResume+0x1e>
     c22:	3b c0       	rjmp	.+118    	; 0xc9a <vTaskResume+0x94>
     c24:	0f b6       	in	r0, 0x3f	; 63
     c26:	f8 94       	cli
     c28:	0f 92       	push	r0
     c2a:	fc 01       	movw	r30, r24
     c2c:	22 85       	ldd	r18, Z+10	; 0x0a
     c2e:	33 85       	ldd	r19, Z+11	; 0x0b
     c30:	20 5d       	subi	r18, 0xD0	; 208
     c32:	37 40       	sbci	r19, 0x07	; 7
     c34:	81 f5       	brne	.+96     	; 0xc96 <vTaskResume+0x90>
     c36:	fc 01       	movw	r30, r24
     c38:	24 89       	ldd	r18, Z+20	; 0x14
     c3a:	35 89       	ldd	r19, Z+21	; 0x15
     c3c:	f7 e0       	ldi	r31, 0x07	; 7
     c3e:	23 3e       	cpi	r18, 0xE3	; 227
     c40:	3f 07       	cpc	r19, r31
     c42:	49 f1       	breq	.+82     	; 0xc96 <vTaskResume+0x90>
     c44:	23 2b       	or	r18, r19
     c46:	39 f5       	brne	.+78     	; 0xc96 <vTaskResume+0x90>
     c48:	ec 01       	movw	r28, r24
     c4a:	8c 01       	movw	r16, r24
     c4c:	0e 5f       	subi	r16, 0xFE	; 254
     c4e:	1f 4f       	sbci	r17, 0xFF	; 255
     c50:	c8 01       	movw	r24, r16
     c52:	0e 94 b7 00 	call	0x16e	; 0x16e <uxListRemove>
     c56:	8e 89       	ldd	r24, Y+22	; 0x16
     c58:	90 91 cc 07 	lds	r25, 0x07CC	; 0x8007cc <uxTopReadyPriority>
     c5c:	98 17       	cp	r25, r24
     c5e:	10 f4       	brcc	.+4      	; 0xc64 <vTaskResume+0x5e>
     c60:	80 93 cc 07 	sts	0x07CC, r24	; 0x8007cc <uxTopReadyPriority>
     c64:	90 e0       	ldi	r25, 0x00	; 0
     c66:	9c 01       	movw	r18, r24
     c68:	22 0f       	add	r18, r18
     c6a:	33 1f       	adc	r19, r19
     c6c:	22 0f       	add	r18, r18
     c6e:	33 1f       	adc	r19, r19
     c70:	22 0f       	add	r18, r18
     c72:	33 1f       	adc	r19, r19
     c74:	82 0f       	add	r24, r18
     c76:	93 1f       	adc	r25, r19
     c78:	b8 01       	movw	r22, r16
     c7a:	8e 5f       	subi	r24, 0xFE	; 254
     c7c:	97 4f       	sbci	r25, 0xF7	; 247
     c7e:	0e 94 65 00 	call	0xca	; 0xca <vListInsertEnd>
     c82:	e0 91 26 08 	lds	r30, 0x0826	; 0x800826 <pxCurrentTCB>
     c86:	f0 91 27 08 	lds	r31, 0x0827	; 0x800827 <pxCurrentTCB+0x1>
     c8a:	9e 89       	ldd	r25, Y+22	; 0x16
     c8c:	86 89       	ldd	r24, Z+22	; 0x16
     c8e:	98 17       	cp	r25, r24
     c90:	10 f0       	brcs	.+4      	; 0xc96 <vTaskResume+0x90>
     c92:	0e 94 bf 01 	call	0x37e	; 0x37e <vPortYield>
     c96:	0f 90       	pop	r0
     c98:	0f be       	out	0x3f, r0	; 63
     c9a:	df 91       	pop	r29
     c9c:	cf 91       	pop	r28
     c9e:	1f 91       	pop	r17
     ca0:	0f 91       	pop	r16
     ca2:	08 95       	ret

00000ca4 <vTaskStartScheduler>:
     ca4:	ef 92       	push	r14
     ca6:	ff 92       	push	r15
     ca8:	0f 93       	push	r16
     caa:	0f 2e       	mov	r0, r31
     cac:	f3 ec       	ldi	r31, 0xC3	; 195
     cae:	ef 2e       	mov	r14, r31
     cb0:	f7 e0       	ldi	r31, 0x07	; 7
     cb2:	ff 2e       	mov	r15, r31
     cb4:	f0 2d       	mov	r31, r0
     cb6:	00 e0       	ldi	r16, 0x00	; 0
     cb8:	20 e0       	ldi	r18, 0x00	; 0
     cba:	30 e0       	ldi	r19, 0x00	; 0
     cbc:	45 e5       	ldi	r20, 0x55	; 85
     cbe:	50 e0       	ldi	r21, 0x00	; 0
     cc0:	60 e0       	ldi	r22, 0x00	; 0
     cc2:	71 e0       	ldi	r23, 0x01	; 1
     cc4:	80 ed       	ldi	r24, 0xD0	; 208
     cc6:	97 e0       	ldi	r25, 0x07	; 7
     cc8:	0e 94 f6 04 	call	0x9ec	; 0x9ec <xTaskCreate>
     ccc:	81 30       	cpi	r24, 0x01	; 1
     cce:	81 f4       	brne	.+32     	; 0xcf0 <vTaskStartScheduler+0x4c>
     cd0:	f8 94       	cli
     cd2:	8f ef       	ldi	r24, 0xFF	; 255
     cd4:	9f ef       	ldi	r25, 0xFF	; 255
     cd6:	90 93 c6 07 	sts	0x07C6, r25	; 0x8007c6 <xNextTaskUnblockTime+0x1>
     cda:	80 93 c5 07 	sts	0x07C5, r24	; 0x8007c5 <xNextTaskUnblockTime>
     cde:	81 e0       	ldi	r24, 0x01	; 1
     ce0:	80 93 cb 07 	sts	0x07CB, r24	; 0x8007cb <xSchedulerRunning>
     ce4:	10 92 ce 07 	sts	0x07CE, r1	; 0x8007ce <xTickCount+0x1>
     ce8:	10 92 cd 07 	sts	0x07CD, r1	; 0x8007cd <xTickCount>
     cec:	0e 94 7f 01 	call	0x2fe	; 0x2fe <xPortStartScheduler>
     cf0:	0f 91       	pop	r16
     cf2:	ff 90       	pop	r15
     cf4:	ef 90       	pop	r14
     cf6:	08 95       	ret

00000cf8 <vTaskSuspendAll>:
     cf8:	80 91 c2 07 	lds	r24, 0x07C2	; 0x8007c2 <uxSchedulerSuspended>
     cfc:	8f 5f       	subi	r24, 0xFF	; 255
     cfe:	80 93 c2 07 	sts	0x07C2, r24	; 0x8007c2 <uxSchedulerSuspended>
     d02:	08 95       	ret

00000d04 <xTaskIncrementTick>:
     d04:	cf 92       	push	r12
     d06:	df 92       	push	r13
     d08:	ef 92       	push	r14
     d0a:	ff 92       	push	r15
     d0c:	0f 93       	push	r16
     d0e:	1f 93       	push	r17
     d10:	cf 93       	push	r28
     d12:	df 93       	push	r29
     d14:	80 91 c2 07 	lds	r24, 0x07C2	; 0x8007c2 <uxSchedulerSuspended>
     d18:	81 11       	cpse	r24, r1
     d1a:	99 c0       	rjmp	.+306    	; 0xe4e <xTaskIncrementTick+0x14a>
     d1c:	e0 90 cd 07 	lds	r14, 0x07CD	; 0x8007cd <xTickCount>
     d20:	f0 90 ce 07 	lds	r15, 0x07CE	; 0x8007ce <xTickCount+0x1>
     d24:	8f ef       	ldi	r24, 0xFF	; 255
     d26:	e8 1a       	sub	r14, r24
     d28:	f8 0a       	sbc	r15, r24
     d2a:	f0 92 ce 07 	sts	0x07CE, r15	; 0x8007ce <xTickCount+0x1>
     d2e:	e0 92 cd 07 	sts	0x07CD, r14	; 0x8007cd <xTickCount>
     d32:	e1 14       	cp	r14, r1
     d34:	f1 04       	cpc	r15, r1
     d36:	b9 f4       	brne	.+46     	; 0xd66 <xTaskIncrementTick+0x62>
     d38:	80 91 ee 07 	lds	r24, 0x07EE	; 0x8007ee <pxDelayedTaskList>
     d3c:	90 91 ef 07 	lds	r25, 0x07EF	; 0x8007ef <pxDelayedTaskList+0x1>
     d40:	20 91 ec 07 	lds	r18, 0x07EC	; 0x8007ec <pxOverflowDelayedTaskList>
     d44:	30 91 ed 07 	lds	r19, 0x07ED	; 0x8007ed <pxOverflowDelayedTaskList+0x1>
     d48:	30 93 ef 07 	sts	0x07EF, r19	; 0x8007ef <pxDelayedTaskList+0x1>
     d4c:	20 93 ee 07 	sts	0x07EE, r18	; 0x8007ee <pxDelayedTaskList>
     d50:	90 93 ed 07 	sts	0x07ED, r25	; 0x8007ed <pxOverflowDelayedTaskList+0x1>
     d54:	80 93 ec 07 	sts	0x07EC, r24	; 0x8007ec <pxOverflowDelayedTaskList>
     d58:	80 91 c8 07 	lds	r24, 0x07C8	; 0x8007c8 <xNumOfOverflows>
     d5c:	8f 5f       	subi	r24, 0xFF	; 255
     d5e:	80 93 c8 07 	sts	0x07C8, r24	; 0x8007c8 <xNumOfOverflows>
     d62:	0e 94 7f 04 	call	0x8fe	; 0x8fe <prvResetNextTaskUnblockTime>
     d66:	80 91 c5 07 	lds	r24, 0x07C5	; 0x8007c5 <xNextTaskUnblockTime>
     d6a:	90 91 c6 07 	lds	r25, 0x07C6	; 0x8007c6 <xNextTaskUnblockTime+0x1>
     d6e:	e8 16       	cp	r14, r24
     d70:	f9 06       	cpc	r15, r25
     d72:	10 f4       	brcc	.+4      	; 0xd78 <xTaskIncrementTick+0x74>
     d74:	d1 2c       	mov	r13, r1
     d76:	53 c0       	rjmp	.+166    	; 0xe1e <xTaskIncrementTick+0x11a>
     d78:	d1 2c       	mov	r13, r1
     d7a:	cc 24       	eor	r12, r12
     d7c:	c3 94       	inc	r12
     d7e:	e0 91 ee 07 	lds	r30, 0x07EE	; 0x8007ee <pxDelayedTaskList>
     d82:	f0 91 ef 07 	lds	r31, 0x07EF	; 0x8007ef <pxDelayedTaskList+0x1>
     d86:	80 81       	ld	r24, Z
     d88:	81 11       	cpse	r24, r1
     d8a:	07 c0       	rjmp	.+14     	; 0xd9a <xTaskIncrementTick+0x96>
     d8c:	8f ef       	ldi	r24, 0xFF	; 255
     d8e:	9f ef       	ldi	r25, 0xFF	; 255
     d90:	90 93 c6 07 	sts	0x07C6, r25	; 0x8007c6 <xNextTaskUnblockTime+0x1>
     d94:	80 93 c5 07 	sts	0x07C5, r24	; 0x8007c5 <xNextTaskUnblockTime>
     d98:	42 c0       	rjmp	.+132    	; 0xe1e <xTaskIncrementTick+0x11a>
     d9a:	e0 91 ee 07 	lds	r30, 0x07EE	; 0x8007ee <pxDelayedTaskList>
     d9e:	f0 91 ef 07 	lds	r31, 0x07EF	; 0x8007ef <pxDelayedTaskList+0x1>
     da2:	05 80       	ldd	r0, Z+5	; 0x05
     da4:	f6 81       	ldd	r31, Z+6	; 0x06
     da6:	e0 2d       	mov	r30, r0
     da8:	c6 81       	ldd	r28, Z+6	; 0x06
     daa:	d7 81       	ldd	r29, Z+7	; 0x07
     dac:	8a 81       	ldd	r24, Y+2	; 0x02
     dae:	9b 81       	ldd	r25, Y+3	; 0x03
     db0:	e8 16       	cp	r14, r24
     db2:	f9 06       	cpc	r15, r25
     db4:	28 f4       	brcc	.+10     	; 0xdc0 <xTaskIncrementTick+0xbc>
     db6:	90 93 c6 07 	sts	0x07C6, r25	; 0x8007c6 <xNextTaskUnblockTime+0x1>
     dba:	80 93 c5 07 	sts	0x07C5, r24	; 0x8007c5 <xNextTaskUnblockTime>
     dbe:	2f c0       	rjmp	.+94     	; 0xe1e <xTaskIncrementTick+0x11a>
     dc0:	8e 01       	movw	r16, r28
     dc2:	0e 5f       	subi	r16, 0xFE	; 254
     dc4:	1f 4f       	sbci	r17, 0xFF	; 255
     dc6:	c8 01       	movw	r24, r16
     dc8:	0e 94 b7 00 	call	0x16e	; 0x16e <uxListRemove>
     dcc:	8c 89       	ldd	r24, Y+20	; 0x14
     dce:	9d 89       	ldd	r25, Y+21	; 0x15
     dd0:	89 2b       	or	r24, r25
     dd2:	21 f0       	breq	.+8      	; 0xddc <xTaskIncrementTick+0xd8>
     dd4:	ce 01       	movw	r24, r28
     dd6:	0c 96       	adiw	r24, 0x0c	; 12
     dd8:	0e 94 b7 00 	call	0x16e	; 0x16e <uxListRemove>
     ddc:	8e 89       	ldd	r24, Y+22	; 0x16
     dde:	90 91 cc 07 	lds	r25, 0x07CC	; 0x8007cc <uxTopReadyPriority>
     de2:	98 17       	cp	r25, r24
     de4:	10 f4       	brcc	.+4      	; 0xdea <xTaskIncrementTick+0xe6>
     de6:	80 93 cc 07 	sts	0x07CC, r24	; 0x8007cc <uxTopReadyPriority>
     dea:	90 e0       	ldi	r25, 0x00	; 0
     dec:	9c 01       	movw	r18, r24
     dee:	22 0f       	add	r18, r18
     df0:	33 1f       	adc	r19, r19
     df2:	22 0f       	add	r18, r18
     df4:	33 1f       	adc	r19, r19
     df6:	22 0f       	add	r18, r18
     df8:	33 1f       	adc	r19, r19
     dfa:	82 0f       	add	r24, r18
     dfc:	93 1f       	adc	r25, r19
     dfe:	b8 01       	movw	r22, r16
     e00:	8e 5f       	subi	r24, 0xFE	; 254
     e02:	97 4f       	sbci	r25, 0xF7	; 247
     e04:	0e 94 65 00 	call	0xca	; 0xca <vListInsertEnd>
     e08:	e0 91 26 08 	lds	r30, 0x0826	; 0x800826 <pxCurrentTCB>
     e0c:	f0 91 27 08 	lds	r31, 0x0827	; 0x800827 <pxCurrentTCB+0x1>
     e10:	9e 89       	ldd	r25, Y+22	; 0x16
     e12:	86 89       	ldd	r24, Z+22	; 0x16
     e14:	98 17       	cp	r25, r24
     e16:	08 f4       	brcc	.+2      	; 0xe1a <xTaskIncrementTick+0x116>
     e18:	b2 cf       	rjmp	.-156    	; 0xd7e <xTaskIncrementTick+0x7a>
     e1a:	dc 2c       	mov	r13, r12
     e1c:	b0 cf       	rjmp	.-160    	; 0xd7e <xTaskIncrementTick+0x7a>
     e1e:	e0 91 26 08 	lds	r30, 0x0826	; 0x800826 <pxCurrentTCB>
     e22:	f0 91 27 08 	lds	r31, 0x0827	; 0x800827 <pxCurrentTCB+0x1>
     e26:	86 89       	ldd	r24, Z+22	; 0x16
     e28:	90 e0       	ldi	r25, 0x00	; 0
     e2a:	fc 01       	movw	r30, r24
     e2c:	ee 0f       	add	r30, r30
     e2e:	ff 1f       	adc	r31, r31
     e30:	ee 0f       	add	r30, r30
     e32:	ff 1f       	adc	r31, r31
     e34:	ee 0f       	add	r30, r30
     e36:	ff 1f       	adc	r31, r31
     e38:	8e 0f       	add	r24, r30
     e3a:	9f 1f       	adc	r25, r31
     e3c:	fc 01       	movw	r30, r24
     e3e:	ee 5f       	subi	r30, 0xFE	; 254
     e40:	f7 4f       	sbci	r31, 0xF7	; 247
     e42:	80 81       	ld	r24, Z
     e44:	82 30       	cpi	r24, 0x02	; 2
     e46:	48 f0       	brcs	.+18     	; 0xe5a <xTaskIncrementTick+0x156>
     e48:	dd 24       	eor	r13, r13
     e4a:	d3 94       	inc	r13
     e4c:	06 c0       	rjmp	.+12     	; 0xe5a <xTaskIncrementTick+0x156>
     e4e:	80 91 ca 07 	lds	r24, 0x07CA	; 0x8007ca <uxPendedTicks>
     e52:	8f 5f       	subi	r24, 0xFF	; 255
     e54:	80 93 ca 07 	sts	0x07CA, r24	; 0x8007ca <uxPendedTicks>
     e58:	d1 2c       	mov	r13, r1
     e5a:	80 91 c9 07 	lds	r24, 0x07C9	; 0x8007c9 <xYieldPending>
     e5e:	88 23       	and	r24, r24
     e60:	11 f0       	breq	.+4      	; 0xe66 <xTaskIncrementTick+0x162>
     e62:	dd 24       	eor	r13, r13
     e64:	d3 94       	inc	r13
     e66:	8d 2d       	mov	r24, r13
     e68:	df 91       	pop	r29
     e6a:	cf 91       	pop	r28
     e6c:	1f 91       	pop	r17
     e6e:	0f 91       	pop	r16
     e70:	ff 90       	pop	r15
     e72:	ef 90       	pop	r14
     e74:	df 90       	pop	r13
     e76:	cf 90       	pop	r12
     e78:	08 95       	ret

00000e7a <xTaskResumeAll>:
     e7a:	df 92       	push	r13
     e7c:	ef 92       	push	r14
     e7e:	ff 92       	push	r15
     e80:	0f 93       	push	r16
     e82:	1f 93       	push	r17
     e84:	cf 93       	push	r28
     e86:	df 93       	push	r29
     e88:	0f b6       	in	r0, 0x3f	; 63
     e8a:	f8 94       	cli
     e8c:	0f 92       	push	r0
     e8e:	80 91 c2 07 	lds	r24, 0x07C2	; 0x8007c2 <uxSchedulerSuspended>
     e92:	81 50       	subi	r24, 0x01	; 1
     e94:	80 93 c2 07 	sts	0x07C2, r24	; 0x8007c2 <uxSchedulerSuspended>
     e98:	80 91 c2 07 	lds	r24, 0x07C2	; 0x8007c2 <uxSchedulerSuspended>
     e9c:	81 11       	cpse	r24, r1
     e9e:	5f c0       	rjmp	.+190    	; 0xf5e <xTaskResumeAll+0xe4>
     ea0:	80 91 cf 07 	lds	r24, 0x07CF	; 0x8007cf <uxCurrentNumberOfTasks>
     ea4:	81 11       	cpse	r24, r1
     ea6:	33 c0       	rjmp	.+102    	; 0xf0e <xTaskResumeAll+0x94>
     ea8:	5d c0       	rjmp	.+186    	; 0xf64 <xTaskResumeAll+0xea>
     eaa:	d7 01       	movw	r26, r14
     eac:	15 96       	adiw	r26, 0x05	; 5
     eae:	ed 91       	ld	r30, X+
     eb0:	fc 91       	ld	r31, X
     eb2:	16 97       	sbiw	r26, 0x06	; 6
     eb4:	c6 81       	ldd	r28, Z+6	; 0x06
     eb6:	d7 81       	ldd	r29, Z+7	; 0x07
     eb8:	ce 01       	movw	r24, r28
     eba:	0c 96       	adiw	r24, 0x0c	; 12
     ebc:	0e 94 b7 00 	call	0x16e	; 0x16e <uxListRemove>
     ec0:	8e 01       	movw	r16, r28
     ec2:	0e 5f       	subi	r16, 0xFE	; 254
     ec4:	1f 4f       	sbci	r17, 0xFF	; 255
     ec6:	c8 01       	movw	r24, r16
     ec8:	0e 94 b7 00 	call	0x16e	; 0x16e <uxListRemove>
     ecc:	8e 89       	ldd	r24, Y+22	; 0x16
     ece:	90 91 cc 07 	lds	r25, 0x07CC	; 0x8007cc <uxTopReadyPriority>
     ed2:	98 17       	cp	r25, r24
     ed4:	10 f4       	brcc	.+4      	; 0xeda <xTaskResumeAll+0x60>
     ed6:	80 93 cc 07 	sts	0x07CC, r24	; 0x8007cc <uxTopReadyPriority>
     eda:	90 e0       	ldi	r25, 0x00	; 0
     edc:	9c 01       	movw	r18, r24
     ede:	22 0f       	add	r18, r18
     ee0:	33 1f       	adc	r19, r19
     ee2:	22 0f       	add	r18, r18
     ee4:	33 1f       	adc	r19, r19
     ee6:	22 0f       	add	r18, r18
     ee8:	33 1f       	adc	r19, r19
     eea:	82 0f       	add	r24, r18
     eec:	93 1f       	adc	r25, r19
     eee:	b8 01       	movw	r22, r16
     ef0:	8e 5f       	subi	r24, 0xFE	; 254
     ef2:	97 4f       	sbci	r25, 0xF7	; 247
     ef4:	0e 94 65 00 	call	0xca	; 0xca <vListInsertEnd>
     ef8:	e0 91 26 08 	lds	r30, 0x0826	; 0x800826 <pxCurrentTCB>
     efc:	f0 91 27 08 	lds	r31, 0x0827	; 0x800827 <pxCurrentTCB+0x1>
     f00:	9e 89       	ldd	r25, Y+22	; 0x16
     f02:	86 89       	ldd	r24, Z+22	; 0x16
     f04:	98 17       	cp	r25, r24
     f06:	68 f0       	brcs	.+26     	; 0xf22 <xTaskResumeAll+0xa8>
     f08:	d0 92 c9 07 	sts	0x07C9, r13	; 0x8007c9 <xYieldPending>
     f0c:	0a c0       	rjmp	.+20     	; 0xf22 <xTaskResumeAll+0xa8>
     f0e:	c0 e0       	ldi	r28, 0x00	; 0
     f10:	d0 e0       	ldi	r29, 0x00	; 0
     f12:	0f 2e       	mov	r0, r31
     f14:	f3 ee       	ldi	r31, 0xE3	; 227
     f16:	ef 2e       	mov	r14, r31
     f18:	f7 e0       	ldi	r31, 0x07	; 7
     f1a:	ff 2e       	mov	r15, r31
     f1c:	f0 2d       	mov	r31, r0
     f1e:	dd 24       	eor	r13, r13
     f20:	d3 94       	inc	r13
     f22:	f7 01       	movw	r30, r14
     f24:	80 81       	ld	r24, Z
     f26:	81 11       	cpse	r24, r1
     f28:	c0 cf       	rjmp	.-128    	; 0xeaa <xTaskResumeAll+0x30>
     f2a:	cd 2b       	or	r28, r29
     f2c:	11 f0       	breq	.+4      	; 0xf32 <xTaskResumeAll+0xb8>
     f2e:	0e 94 7f 04 	call	0x8fe	; 0x8fe <prvResetNextTaskUnblockTime>
     f32:	c0 91 ca 07 	lds	r28, 0x07CA	; 0x8007ca <uxPendedTicks>
     f36:	cc 23       	and	r28, r28
     f38:	51 f0       	breq	.+20     	; 0xf4e <xTaskResumeAll+0xd4>
     f3a:	d1 e0       	ldi	r29, 0x01	; 1
     f3c:	0e 94 82 06 	call	0xd04	; 0xd04 <xTaskIncrementTick>
     f40:	81 11       	cpse	r24, r1
     f42:	d0 93 c9 07 	sts	0x07C9, r29	; 0x8007c9 <xYieldPending>
     f46:	c1 50       	subi	r28, 0x01	; 1
     f48:	c9 f7       	brne	.-14     	; 0xf3c <xTaskResumeAll+0xc2>
     f4a:	10 92 ca 07 	sts	0x07CA, r1	; 0x8007ca <uxPendedTicks>
     f4e:	80 91 c9 07 	lds	r24, 0x07C9	; 0x8007c9 <xYieldPending>
     f52:	88 23       	and	r24, r24
     f54:	31 f0       	breq	.+12     	; 0xf62 <xTaskResumeAll+0xe8>
     f56:	0e 94 bf 01 	call	0x37e	; 0x37e <vPortYield>
     f5a:	81 e0       	ldi	r24, 0x01	; 1
     f5c:	03 c0       	rjmp	.+6      	; 0xf64 <xTaskResumeAll+0xea>
     f5e:	80 e0       	ldi	r24, 0x00	; 0
     f60:	01 c0       	rjmp	.+2      	; 0xf64 <xTaskResumeAll+0xea>
     f62:	80 e0       	ldi	r24, 0x00	; 0
     f64:	0f 90       	pop	r0
     f66:	0f be       	out	0x3f, r0	; 63
     f68:	df 91       	pop	r29
     f6a:	cf 91       	pop	r28
     f6c:	1f 91       	pop	r17
     f6e:	0f 91       	pop	r16
     f70:	ff 90       	pop	r15
     f72:	ef 90       	pop	r14
     f74:	df 90       	pop	r13
     f76:	08 95       	ret

00000f78 <vTaskDelay>:
     f78:	cf 93       	push	r28
     f7a:	df 93       	push	r29
     f7c:	ec 01       	movw	r28, r24
     f7e:	89 2b       	or	r24, r25
     f80:	51 f0       	breq	.+20     	; 0xf96 <vTaskDelay+0x1e>
     f82:	0e 94 7c 06 	call	0xcf8	; 0xcf8 <vTaskSuspendAll>
     f86:	60 e0       	ldi	r22, 0x00	; 0
     f88:	ce 01       	movw	r24, r28
     f8a:	0e 94 9e 04 	call	0x93c	; 0x93c <prvAddCurrentTaskToDelayedList>
     f8e:	0e 94 3d 07 	call	0xe7a	; 0xe7a <xTaskResumeAll>
     f92:	81 11       	cpse	r24, r1
     f94:	02 c0       	rjmp	.+4      	; 0xf9a <vTaskDelay+0x22>
     f96:	0e 94 bf 01 	call	0x37e	; 0x37e <vPortYield>
     f9a:	df 91       	pop	r29
     f9c:	cf 91       	pop	r28
     f9e:	08 95       	ret

00000fa0 <prvIdleTask>:
     fa0:	0a ed       	ldi	r16, 0xDA	; 218
     fa2:	17 e0       	ldi	r17, 0x07	; 7
     fa4:	0f 2e       	mov	r0, r31
     fa6:	f2 e0       	ldi	r31, 0x02	; 2
     fa8:	ef 2e       	mov	r14, r31
     faa:	f8 e0       	ldi	r31, 0x08	; 8
     fac:	ff 2e       	mov	r15, r31
     fae:	f0 2d       	mov	r31, r0
     fb0:	29 c0       	rjmp	.+82     	; 0x1004 <prvIdleTask+0x64>
     fb2:	0e 94 7c 06 	call	0xcf8	; 0xcf8 <vTaskSuspendAll>
     fb6:	d8 01       	movw	r26, r16
     fb8:	cc 91       	ld	r28, X
     fba:	0e 94 3d 07 	call	0xe7a	; 0xe7a <xTaskResumeAll>
     fbe:	cc 23       	and	r28, r28
     fc0:	09 f1       	breq	.+66     	; 0x1004 <prvIdleTask+0x64>
     fc2:	0f b6       	in	r0, 0x3f	; 63
     fc4:	f8 94       	cli
     fc6:	0f 92       	push	r0
     fc8:	d8 01       	movw	r26, r16
     fca:	15 96       	adiw	r26, 0x05	; 5
     fcc:	ed 91       	ld	r30, X+
     fce:	fc 91       	ld	r31, X
     fd0:	16 97       	sbiw	r26, 0x06	; 6
     fd2:	c6 81       	ldd	r28, Z+6	; 0x06
     fd4:	d7 81       	ldd	r29, Z+7	; 0x07
     fd6:	ce 01       	movw	r24, r28
     fd8:	02 96       	adiw	r24, 0x02	; 2
     fda:	0e 94 b7 00 	call	0x16e	; 0x16e <uxListRemove>
     fde:	80 91 cf 07 	lds	r24, 0x07CF	; 0x8007cf <uxCurrentNumberOfTasks>
     fe2:	81 50       	subi	r24, 0x01	; 1
     fe4:	80 93 cf 07 	sts	0x07CF, r24	; 0x8007cf <uxCurrentNumberOfTasks>
     fe8:	80 91 d9 07 	lds	r24, 0x07D9	; 0x8007d9 <uxDeletedTasksWaitingCleanUp>
     fec:	81 50       	subi	r24, 0x01	; 1
     fee:	80 93 d9 07 	sts	0x07D9, r24	; 0x8007d9 <uxDeletedTasksWaitingCleanUp>
     ff2:	0f 90       	pop	r0
     ff4:	0f be       	out	0x3f, r0	; 63
     ff6:	8f 89       	ldd	r24, Y+23	; 0x17
     ff8:	98 8d       	ldd	r25, Y+24	; 0x18
     ffa:	0e 94 12 01 	call	0x224	; 0x224 <vPortFree>
     ffe:	ce 01       	movw	r24, r28
    1000:	0e 94 12 01 	call	0x224	; 0x224 <vPortFree>
    1004:	80 91 d9 07 	lds	r24, 0x07D9	; 0x8007d9 <uxDeletedTasksWaitingCleanUp>
    1008:	81 11       	cpse	r24, r1
    100a:	d3 cf       	rjmp	.-90     	; 0xfb2 <prvIdleTask+0x12>
    100c:	f7 01       	movw	r30, r14
    100e:	80 81       	ld	r24, Z
    1010:	82 30       	cpi	r24, 0x02	; 2
    1012:	10 f0       	brcs	.+4      	; 0x1018 <prvIdleTask+0x78>
    1014:	0e 94 bf 01 	call	0x37e	; 0x37e <vPortYield>
    1018:	0e 94 75 0b 	call	0x16ea	; 0x16ea <vApplicationIdleHook>
    101c:	f3 cf       	rjmp	.-26     	; 0x1004 <prvIdleTask+0x64>

0000101e <vTaskSwitchContext>:
    101e:	80 91 c2 07 	lds	r24, 0x07C2	; 0x8007c2 <uxSchedulerSuspended>
    1022:	88 23       	and	r24, r24
    1024:	21 f0       	breq	.+8      	; 0x102e <vTaskSwitchContext+0x10>
    1026:	81 e0       	ldi	r24, 0x01	; 1
    1028:	80 93 c9 07 	sts	0x07C9, r24	; 0x8007c9 <xYieldPending>
    102c:	08 95       	ret
    102e:	10 92 c9 07 	sts	0x07C9, r1	; 0x8007c9 <xYieldPending>
    1032:	20 91 cc 07 	lds	r18, 0x07CC	; 0x8007cc <uxTopReadyPriority>
    1036:	82 2f       	mov	r24, r18
    1038:	90 e0       	ldi	r25, 0x00	; 0
    103a:	fc 01       	movw	r30, r24
    103c:	ee 0f       	add	r30, r30
    103e:	ff 1f       	adc	r31, r31
    1040:	ee 0f       	add	r30, r30
    1042:	ff 1f       	adc	r31, r31
    1044:	ee 0f       	add	r30, r30
    1046:	ff 1f       	adc	r31, r31
    1048:	e8 0f       	add	r30, r24
    104a:	f9 1f       	adc	r31, r25
    104c:	ee 5f       	subi	r30, 0xFE	; 254
    104e:	f7 4f       	sbci	r31, 0xF7	; 247
    1050:	30 81       	ld	r19, Z
    1052:	31 11       	cpse	r19, r1
    1054:	11 c0       	rjmp	.+34     	; 0x1078 <vTaskSwitchContext+0x5a>
    1056:	21 50       	subi	r18, 0x01	; 1
    1058:	82 2f       	mov	r24, r18
    105a:	90 e0       	ldi	r25, 0x00	; 0
    105c:	fc 01       	movw	r30, r24
    105e:	ee 0f       	add	r30, r30
    1060:	ff 1f       	adc	r31, r31
    1062:	ee 0f       	add	r30, r30
    1064:	ff 1f       	adc	r31, r31
    1066:	ee 0f       	add	r30, r30
    1068:	ff 1f       	adc	r31, r31
    106a:	e8 0f       	add	r30, r24
    106c:	f9 1f       	adc	r31, r25
    106e:	ee 5f       	subi	r30, 0xFE	; 254
    1070:	f7 4f       	sbci	r31, 0xF7	; 247
    1072:	30 81       	ld	r19, Z
    1074:	33 23       	and	r19, r19
    1076:	79 f3       	breq	.-34     	; 0x1056 <vTaskSwitchContext+0x38>
    1078:	ac 01       	movw	r20, r24
    107a:	44 0f       	add	r20, r20
    107c:	55 1f       	adc	r21, r21
    107e:	44 0f       	add	r20, r20
    1080:	55 1f       	adc	r21, r21
    1082:	44 0f       	add	r20, r20
    1084:	55 1f       	adc	r21, r21
    1086:	48 0f       	add	r20, r24
    1088:	59 1f       	adc	r21, r25
    108a:	da 01       	movw	r26, r20
    108c:	ae 5f       	subi	r26, 0xFE	; 254
    108e:	b7 4f       	sbci	r27, 0xF7	; 247
    1090:	11 96       	adiw	r26, 0x01	; 1
    1092:	ed 91       	ld	r30, X+
    1094:	fc 91       	ld	r31, X
    1096:	12 97       	sbiw	r26, 0x02	; 2
    1098:	02 80       	ldd	r0, Z+2	; 0x02
    109a:	f3 81       	ldd	r31, Z+3	; 0x03
    109c:	e0 2d       	mov	r30, r0
    109e:	12 96       	adiw	r26, 0x02	; 2
    10a0:	fc 93       	st	X, r31
    10a2:	ee 93       	st	-X, r30
    10a4:	11 97       	sbiw	r26, 0x01	; 1
    10a6:	4b 5f       	subi	r20, 0xFB	; 251
    10a8:	57 4f       	sbci	r21, 0xF7	; 247
    10aa:	e4 17       	cp	r30, r20
    10ac:	f5 07       	cpc	r31, r21
    10ae:	29 f4       	brne	.+10     	; 0x10ba <vTaskSwitchContext+0x9c>
    10b0:	42 81       	ldd	r20, Z+2	; 0x02
    10b2:	53 81       	ldd	r21, Z+3	; 0x03
    10b4:	fd 01       	movw	r30, r26
    10b6:	52 83       	std	Z+2, r21	; 0x02
    10b8:	41 83       	std	Z+1, r20	; 0x01
    10ba:	fc 01       	movw	r30, r24
    10bc:	ee 0f       	add	r30, r30
    10be:	ff 1f       	adc	r31, r31
    10c0:	ee 0f       	add	r30, r30
    10c2:	ff 1f       	adc	r31, r31
    10c4:	ee 0f       	add	r30, r30
    10c6:	ff 1f       	adc	r31, r31
    10c8:	8e 0f       	add	r24, r30
    10ca:	9f 1f       	adc	r25, r31
    10cc:	fc 01       	movw	r30, r24
    10ce:	ee 5f       	subi	r30, 0xFE	; 254
    10d0:	f7 4f       	sbci	r31, 0xF7	; 247
    10d2:	01 80       	ldd	r0, Z+1	; 0x01
    10d4:	f2 81       	ldd	r31, Z+2	; 0x02
    10d6:	e0 2d       	mov	r30, r0
    10d8:	86 81       	ldd	r24, Z+6	; 0x06
    10da:	97 81       	ldd	r25, Z+7	; 0x07
    10dc:	90 93 27 08 	sts	0x0827, r25	; 0x800827 <pxCurrentTCB+0x1>
    10e0:	80 93 26 08 	sts	0x0826, r24	; 0x800826 <pxCurrentTCB>
    10e4:	20 93 cc 07 	sts	0x07CC, r18	; 0x8007cc <uxTopReadyPriority>
    10e8:	08 95       	ret

000010ea <vTaskSuspend>:
    10ea:	0f 93       	push	r16
    10ec:	1f 93       	push	r17
    10ee:	cf 93       	push	r28
    10f0:	df 93       	push	r29
    10f2:	ec 01       	movw	r28, r24
    10f4:	0f b6       	in	r0, 0x3f	; 63
    10f6:	f8 94       	cli
    10f8:	0f 92       	push	r0
    10fa:	89 2b       	or	r24, r25
    10fc:	21 f4       	brne	.+8      	; 0x1106 <vTaskSuspend+0x1c>
    10fe:	c0 91 26 08 	lds	r28, 0x0826	; 0x800826 <pxCurrentTCB>
    1102:	d0 91 27 08 	lds	r29, 0x0827	; 0x800827 <pxCurrentTCB+0x1>
    1106:	8e 01       	movw	r16, r28
    1108:	0e 5f       	subi	r16, 0xFE	; 254
    110a:	1f 4f       	sbci	r17, 0xFF	; 255
    110c:	c8 01       	movw	r24, r16
    110e:	0e 94 b7 00 	call	0x16e	; 0x16e <uxListRemove>
    1112:	8c 89       	ldd	r24, Y+20	; 0x14
    1114:	9d 89       	ldd	r25, Y+21	; 0x15
    1116:	89 2b       	or	r24, r25
    1118:	21 f0       	breq	.+8      	; 0x1122 <vTaskSuspend+0x38>
    111a:	ce 01       	movw	r24, r28
    111c:	0c 96       	adiw	r24, 0x0c	; 12
    111e:	0e 94 b7 00 	call	0x16e	; 0x16e <uxListRemove>
    1122:	b8 01       	movw	r22, r16
    1124:	80 ed       	ldi	r24, 0xD0	; 208
    1126:	97 e0       	ldi	r25, 0x07	; 7
    1128:	0e 94 65 00 	call	0xca	; 0xca <vListInsertEnd>
    112c:	0f 90       	pop	r0
    112e:	0f be       	out	0x3f, r0	; 63
    1130:	80 91 cb 07 	lds	r24, 0x07CB	; 0x8007cb <xSchedulerRunning>
    1134:	88 23       	and	r24, r24
    1136:	39 f0       	breq	.+14     	; 0x1146 <vTaskSuspend+0x5c>
    1138:	0f b6       	in	r0, 0x3f	; 63
    113a:	f8 94       	cli
    113c:	0f 92       	push	r0
    113e:	0e 94 7f 04 	call	0x8fe	; 0x8fe <prvResetNextTaskUnblockTime>
    1142:	0f 90       	pop	r0
    1144:	0f be       	out	0x3f, r0	; 63
    1146:	80 91 26 08 	lds	r24, 0x0826	; 0x800826 <pxCurrentTCB>
    114a:	90 91 27 08 	lds	r25, 0x0827	; 0x800827 <pxCurrentTCB+0x1>
    114e:	c8 17       	cp	r28, r24
    1150:	d9 07       	cpc	r29, r25
    1152:	a1 f4       	brne	.+40     	; 0x117c <vTaskSuspend+0x92>
    1154:	80 91 cb 07 	lds	r24, 0x07CB	; 0x8007cb <xSchedulerRunning>
    1158:	88 23       	and	r24, r24
    115a:	19 f0       	breq	.+6      	; 0x1162 <vTaskSuspend+0x78>
    115c:	0e 94 bf 01 	call	0x37e	; 0x37e <vPortYield>
    1160:	0d c0       	rjmp	.+26     	; 0x117c <vTaskSuspend+0x92>
    1162:	80 91 cf 07 	lds	r24, 0x07CF	; 0x8007cf <uxCurrentNumberOfTasks>
    1166:	90 91 d0 07 	lds	r25, 0x07D0	; 0x8007d0 <xSuspendedTaskList>
    116a:	98 13       	cpse	r25, r24
    116c:	05 c0       	rjmp	.+10     	; 0x1178 <vTaskSuspend+0x8e>
    116e:	10 92 27 08 	sts	0x0827, r1	; 0x800827 <pxCurrentTCB+0x1>
    1172:	10 92 26 08 	sts	0x0826, r1	; 0x800826 <pxCurrentTCB>
    1176:	02 c0       	rjmp	.+4      	; 0x117c <vTaskSuspend+0x92>
    1178:	0e 94 0f 08 	call	0x101e	; 0x101e <vTaskSwitchContext>
    117c:	df 91       	pop	r29
    117e:	cf 91       	pop	r28
    1180:	1f 91       	pop	r17
    1182:	0f 91       	pop	r16
    1184:	08 95       	ret

00001186 <vTaskPlaceOnEventList>:
    1186:	cf 93       	push	r28
    1188:	df 93       	push	r29
    118a:	eb 01       	movw	r28, r22
    118c:	60 91 26 08 	lds	r22, 0x0826	; 0x800826 <pxCurrentTCB>
    1190:	70 91 27 08 	lds	r23, 0x0827	; 0x800827 <pxCurrentTCB+0x1>
    1194:	64 5f       	subi	r22, 0xF4	; 244
    1196:	7f 4f       	sbci	r23, 0xFF	; 255
    1198:	0e 94 86 00 	call	0x10c	; 0x10c <vListInsert>
    119c:	61 e0       	ldi	r22, 0x01	; 1
    119e:	ce 01       	movw	r24, r28
    11a0:	0e 94 9e 04 	call	0x93c	; 0x93c <prvAddCurrentTaskToDelayedList>
    11a4:	df 91       	pop	r29
    11a6:	cf 91       	pop	r28
    11a8:	08 95       	ret

000011aa <xTaskRemoveFromEventList>:
    11aa:	0f 93       	push	r16
    11ac:	1f 93       	push	r17
    11ae:	cf 93       	push	r28
    11b0:	df 93       	push	r29
    11b2:	dc 01       	movw	r26, r24
    11b4:	15 96       	adiw	r26, 0x05	; 5
    11b6:	ed 91       	ld	r30, X+
    11b8:	fc 91       	ld	r31, X
    11ba:	16 97       	sbiw	r26, 0x06	; 6
    11bc:	c6 81       	ldd	r28, Z+6	; 0x06
    11be:	d7 81       	ldd	r29, Z+7	; 0x07
    11c0:	8e 01       	movw	r16, r28
    11c2:	04 5f       	subi	r16, 0xF4	; 244
    11c4:	1f 4f       	sbci	r17, 0xFF	; 255
    11c6:	c8 01       	movw	r24, r16
    11c8:	0e 94 b7 00 	call	0x16e	; 0x16e <uxListRemove>
    11cc:	80 91 c2 07 	lds	r24, 0x07C2	; 0x8007c2 <uxSchedulerSuspended>
    11d0:	81 11       	cpse	r24, r1
    11d2:	1c c0       	rjmp	.+56     	; 0x120c <xTaskRemoveFromEventList+0x62>
    11d4:	0a 50       	subi	r16, 0x0A	; 10
    11d6:	11 09       	sbc	r17, r1
    11d8:	c8 01       	movw	r24, r16
    11da:	0e 94 b7 00 	call	0x16e	; 0x16e <uxListRemove>
    11de:	8e 89       	ldd	r24, Y+22	; 0x16
    11e0:	90 91 cc 07 	lds	r25, 0x07CC	; 0x8007cc <uxTopReadyPriority>
    11e4:	98 17       	cp	r25, r24
    11e6:	10 f4       	brcc	.+4      	; 0x11ec <xTaskRemoveFromEventList+0x42>
    11e8:	80 93 cc 07 	sts	0x07CC, r24	; 0x8007cc <uxTopReadyPriority>
    11ec:	90 e0       	ldi	r25, 0x00	; 0
    11ee:	9c 01       	movw	r18, r24
    11f0:	22 0f       	add	r18, r18
    11f2:	33 1f       	adc	r19, r19
    11f4:	22 0f       	add	r18, r18
    11f6:	33 1f       	adc	r19, r19
    11f8:	22 0f       	add	r18, r18
    11fa:	33 1f       	adc	r19, r19
    11fc:	82 0f       	add	r24, r18
    11fe:	93 1f       	adc	r25, r19
    1200:	b8 01       	movw	r22, r16
    1202:	8e 5f       	subi	r24, 0xFE	; 254
    1204:	97 4f       	sbci	r25, 0xF7	; 247
    1206:	0e 94 65 00 	call	0xca	; 0xca <vListInsertEnd>
    120a:	05 c0       	rjmp	.+10     	; 0x1216 <xTaskRemoveFromEventList+0x6c>
    120c:	b8 01       	movw	r22, r16
    120e:	83 ee       	ldi	r24, 0xE3	; 227
    1210:	97 e0       	ldi	r25, 0x07	; 7
    1212:	0e 94 65 00 	call	0xca	; 0xca <vListInsertEnd>
    1216:	e0 91 26 08 	lds	r30, 0x0826	; 0x800826 <pxCurrentTCB>
    121a:	f0 91 27 08 	lds	r31, 0x0827	; 0x800827 <pxCurrentTCB+0x1>
    121e:	9e 89       	ldd	r25, Y+22	; 0x16
    1220:	86 89       	ldd	r24, Z+22	; 0x16
    1222:	89 17       	cp	r24, r25
    1224:	20 f4       	brcc	.+8      	; 0x122e <xTaskRemoveFromEventList+0x84>
    1226:	81 e0       	ldi	r24, 0x01	; 1
    1228:	80 93 c9 07 	sts	0x07C9, r24	; 0x8007c9 <xYieldPending>
    122c:	01 c0       	rjmp	.+2      	; 0x1230 <xTaskRemoveFromEventList+0x86>
    122e:	80 e0       	ldi	r24, 0x00	; 0
    1230:	df 91       	pop	r29
    1232:	cf 91       	pop	r28
    1234:	1f 91       	pop	r17
    1236:	0f 91       	pop	r16
    1238:	08 95       	ret

0000123a <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    123a:	20 91 c8 07 	lds	r18, 0x07C8	; 0x8007c8 <xNumOfOverflows>
    123e:	fc 01       	movw	r30, r24
    1240:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1242:	20 91 cd 07 	lds	r18, 0x07CD	; 0x8007cd <xTickCount>
    1246:	30 91 ce 07 	lds	r19, 0x07CE	; 0x8007ce <xTickCount+0x1>
    124a:	32 83       	std	Z+2, r19	; 0x02
    124c:	21 83       	std	Z+1, r18	; 0x01
    124e:	08 95       	ret

00001250 <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1250:	0f b6       	in	r0, 0x3f	; 63
    1252:	f8 94       	cli
    1254:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    1256:	40 91 cd 07 	lds	r20, 0x07CD	; 0x8007cd <xTickCount>
    125a:	50 91 ce 07 	lds	r21, 0x07CE	; 0x8007ce <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    125e:	db 01       	movw	r26, r22
    1260:	2d 91       	ld	r18, X+
    1262:	3c 91       	ld	r19, X
    1264:	2f 3f       	cpi	r18, 0xFF	; 255
    1266:	bf ef       	ldi	r27, 0xFF	; 255
    1268:	3b 07       	cpc	r19, r27
    126a:	19 f1       	breq	.+70     	; 0x12b2 <xTaskCheckForTimeOut+0x62>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    126c:	e0 91 c8 07 	lds	r30, 0x07C8	; 0x8007c8 <xNumOfOverflows>
    1270:	dc 01       	movw	r26, r24
    1272:	fc 91       	ld	r31, X
    1274:	fe 17       	cp	r31, r30
    1276:	39 f0       	breq	.+14     	; 0x1286 <xTaskCheckForTimeOut+0x36>
    1278:	11 96       	adiw	r26, 0x01	; 1
    127a:	ed 91       	ld	r30, X+
    127c:	fc 91       	ld	r31, X
    127e:	12 97       	sbiw	r26, 0x02	; 2
    1280:	4e 17       	cp	r20, r30
    1282:	5f 07       	cpc	r21, r31
    1284:	c0 f4       	brcc	.+48     	; 0x12b6 <xTaskCheckForTimeOut+0x66>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    1286:	dc 01       	movw	r26, r24
    1288:	11 96       	adiw	r26, 0x01	; 1
    128a:	ed 91       	ld	r30, X+
    128c:	fc 91       	ld	r31, X
    128e:	12 97       	sbiw	r26, 0x02	; 2
    1290:	da 01       	movw	r26, r20
    1292:	ae 1b       	sub	r26, r30
    1294:	bf 0b       	sbc	r27, r31
    1296:	a2 17       	cp	r26, r18
    1298:	b3 07       	cpc	r27, r19
    129a:	78 f4       	brcc	.+30     	; 0x12ba <xTaskCheckForTimeOut+0x6a>
    129c:	db 01       	movw	r26, r22
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    129e:	e4 1b       	sub	r30, r20
    12a0:	f5 0b       	sbc	r31, r21
    12a2:	2e 0f       	add	r18, r30
    12a4:	3f 1f       	adc	r19, r31
    12a6:	2d 93       	st	X+, r18
    12a8:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    12aa:	0e 94 1d 09 	call	0x123a	; 0x123a <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    12ae:	80 e0       	ldi	r24, 0x00	; 0
    12b0:	05 c0       	rjmp	.+10     	; 0x12bc <xTaskCheckForTimeOut+0x6c>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    12b2:	80 e0       	ldi	r24, 0x00	; 0
    12b4:	03 c0       	rjmp	.+6      	; 0x12bc <xTaskCheckForTimeOut+0x6c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    12b6:	81 e0       	ldi	r24, 0x01	; 1
    12b8:	01 c0       	rjmp	.+2      	; 0x12bc <xTaskCheckForTimeOut+0x6c>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    12ba:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    12bc:	0f 90       	pop	r0
    12be:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    12c0:	08 95       	ret

000012c2 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    12c2:	81 e0       	ldi	r24, 0x01	; 1
    12c4:	80 93 c9 07 	sts	0x07C9, r24	; 0x8007c9 <xYieldPending>
    12c8:	08 95       	ret

000012ca <alarmOFF>:
}

void alarmOFF(void* parameter) {
	for (;;){
		//la task viene creata ma va subito sospesa in attesa di chiamata. non servono semafori perch non ci sono risorse condivise.
		vTaskSuspend(NULL); //Quando impostato a Null sospende se stessa.
    12ca:	80 e0       	ldi	r24, 0x00	; 0
    12cc:	90 e0       	ldi	r25, 0x00	; 0
    12ce:	0e 94 75 08 	call	0x10ea	; 0x10ea <vTaskSuspend>
		alarmState = 0;
    12d2:	10 92 2d 08 	sts	0x082D, r1	; 0x80082d <alarmState+0x1>
    12d6:	10 92 2c 08 	sts	0x082C, r1	; 0x80082c <alarmState>
		vTaskSuspend(buzzerTaskHandle);
    12da:	80 91 30 08 	lds	r24, 0x0830	; 0x800830 <buzzerTaskHandle>
    12de:	90 91 31 08 	lds	r25, 0x0831	; 0x800831 <buzzerTaskHandle+0x1>
    12e2:	0e 94 75 08 	call	0x10ea	; 0x10ea <vTaskSuspend>
		vTaskSuspend(fanTaskHandle);
    12e6:	80 91 2e 08 	lds	r24, 0x082E	; 0x80082e <fanTaskHandle>
    12ea:	90 91 2f 08 	lds	r25, 0x082F	; 0x80082f <fanTaskHandle+0x1>
    12ee:	0e 94 75 08 	call	0x10ea	; 0x10ea <vTaskSuspend>
    12f2:	eb cf       	rjmp	.-42     	; 0x12ca <alarmOFF>

000012f4 <stopBlinkLED>:
		//PORTB |= (1 << PB5);						
	}
}
void stopBlinkLED(void* parameter) {
	for (;;) {	
		vTaskSuspend(NULL); //SUSPEND ITSELF
    12f4:	80 e0       	ldi	r24, 0x00	; 0
    12f6:	90 e0       	ldi	r25, 0x00	; 0
    12f8:	0e 94 75 08 	call	0x10ea	; 0x10ea <vTaskSuspend>
		PORTD &= ~(1 << 3);	
    12fc:	5b 98       	cbi	0x0b, 3	; 11
		PORTB &= ~(1 << PB5);	
    12fe:	2d 98       	cbi	0x05, 5	; 5
    1300:	f9 cf       	rjmp	.-14     	; 0x12f4 <stopBlinkLED>

00001302 <alarmON>:

void alarmON(void* parameter) {
	for (;;){
		//la task viene creata ma va subito sospesa in attesa di chiamata. non servono semafori perch non ci sono risorse condivise.
		vTaskSuspend(NULL); //Quando impostato a Null sospende se stessa.	
		alarmState = 1;
    1302:	c1 e0       	ldi	r28, 0x01	; 1
    1304:	d0 e0       	ldi	r29, 0x00	; 0
int stateFan = 0;

void alarmON(void* parameter) {
	for (;;){
		//la task viene creata ma va subito sospesa in attesa di chiamata. non servono semafori perch non ci sono risorse condivise.
		vTaskSuspend(NULL); //Quando impostato a Null sospende se stessa.	
    1306:	80 e0       	ldi	r24, 0x00	; 0
    1308:	90 e0       	ldi	r25, 0x00	; 0
    130a:	0e 94 75 08 	call	0x10ea	; 0x10ea <vTaskSuspend>
		alarmState = 1;
    130e:	d0 93 2d 08 	sts	0x082D, r29	; 0x80082d <alarmState+0x1>
    1312:	c0 93 2c 08 	sts	0x082C, r28	; 0x80082c <alarmState>
		vTaskResume(buzzerTaskHandle);
    1316:	80 91 30 08 	lds	r24, 0x0830	; 0x800830 <buzzerTaskHandle>
    131a:	90 91 31 08 	lds	r25, 0x0831	; 0x800831 <buzzerTaskHandle+0x1>
    131e:	0e 94 03 06 	call	0xc06	; 0xc06 <vTaskResume>
		vTaskResume(fanTaskHandle);
    1322:	80 91 2e 08 	lds	r24, 0x082E	; 0x80082e <fanTaskHandle>
    1326:	90 91 2f 08 	lds	r25, 0x082F	; 0x80082f <fanTaskHandle+0x1>
    132a:	0e 94 03 06 	call	0xc06	; 0xc06 <vTaskResume>
    132e:	eb cf       	rjmp	.-42     	; 0x1306 <alarmON+0x4>

00001330 <buzzerTask>:

void buzzerTask(void* parameter) {
	for (;;){
		
		//Se il buzzer non  impostato dall'esterno o il sistema non  in stato di allarme, il buzzer deve essere spento.
		if (stateBuzzer == 0){
    1330:	80 91 2a 08 	lds	r24, 0x082A	; 0x80082a <stateBuzzer>
    1334:	90 91 2b 08 	lds	r25, 0x082B	; 0x80082b <stateBuzzer+0x1>
    1338:	89 2b       	or	r24, r25
    133a:	29 f4       	brne	.+10     	; 0x1346 <buzzerTask+0x16>
			vTaskSuspend(NULL); 
    133c:	80 e0       	ldi	r24, 0x00	; 0
    133e:	90 e0       	ldi	r25, 0x00	; 0
    1340:	0e 94 75 08 	call	0x10ea	; 0x10ea <vTaskSuspend>
    1344:	f5 cf       	rjmp	.-22     	; 0x1330 <buzzerTask>
		}
		else { //Esegui la PWM
		
		PORTD |= (1 << 3);
    1346:	5b 9a       	sbi	0x0b, 3	; 11
		vTaskDelay(1); //da fare con i timer;
    1348:	81 e0       	ldi	r24, 0x01	; 1
    134a:	90 e0       	ldi	r25, 0x00	; 0
    134c:	0e 94 bc 07 	call	0xf78	; 0xf78 <vTaskDelay>
		PORTD &= (~(1<<3));
    1350:	5b 98       	cbi	0x0b, 3	; 11
		vTaskDelay(1);
    1352:	81 e0       	ldi	r24, 0x01	; 1
    1354:	90 e0       	ldi	r25, 0x00	; 0
    1356:	0e 94 bc 07 	call	0xf78	; 0xf78 <vTaskDelay>
    135a:	ea cf       	rjmp	.-44     	; 0x1330 <buzzerTask>

0000135c <fanTask>:

void fanTask(void* parameter) {
	for (;;){
		
		//Se il buzzer non  impostato dall'esterno o il sistema non  in stato di allarme, il buzzer deve essere spento.
		if (stateFan == 0){
    135c:	80 91 28 08 	lds	r24, 0x0828	; 0x800828 <stateFan>
    1360:	90 91 29 08 	lds	r25, 0x0829	; 0x800829 <stateFan+0x1>
    1364:	89 2b       	or	r24, r25
    1366:	29 f4       	brne	.+10     	; 0x1372 <fanTask+0x16>
			vTaskSuspend(NULL);
    1368:	80 e0       	ldi	r24, 0x00	; 0
    136a:	90 e0       	ldi	r25, 0x00	; 0
    136c:	0e 94 75 08 	call	0x10ea	; 0x10ea <vTaskSuspend>
    1370:	f5 cf       	rjmp	.-22     	; 0x135c <fanTask>
		}
		else { //Esegui la PWM
			
			PORTD |= (1 << 5); //ENABLE
    1372:	5d 9a       	sbi	0x0b, 5	; 11
    1374:	c5 e0       	ldi	r28, 0x05	; 5
    1376:	d0 e0       	ldi	r29, 0x00	; 0
			
			for (int i = 0; i<5; i++) {
				PORTD |= (1 << 3);
    1378:	5b 9a       	sbi	0x0b, 3	; 11
				PORTD &= (~(1<<4));
    137a:	5c 98       	cbi	0x0b, 4	; 11
				vTaskDelay(pdMS_TO_TICKS(750));
    137c:	8d e1       	ldi	r24, 0x1D	; 29
    137e:	90 e0       	ldi	r25, 0x00	; 0
    1380:	0e 94 bc 07 	call	0xf78	; 0xf78 <vTaskDelay>
				
				PORTD &= (~(1<<3));
    1384:	5b 98       	cbi	0x0b, 3	; 11
				PORTD |= (1 << 4);
    1386:	5c 9a       	sbi	0x0b, 4	; 11
				vTaskDelay(pdMS_TO_TICKS(750));
    1388:	8d e1       	ldi	r24, 0x1D	; 29
    138a:	90 e0       	ldi	r25, 0x00	; 0
    138c:	0e 94 bc 07 	call	0xf78	; 0xf78 <vTaskDelay>
    1390:	21 97       	sbiw	r28, 0x01	; 1
		}
		else { //Esegui la PWM
			
			PORTD |= (1 << 5); //ENABLE
			
			for (int i = 0; i<5; i++) {
    1392:	91 f7       	brne	.-28     	; 0x1378 <fanTask+0x1c>
				
				PORTD &= (~(1<<3));
				PORTD |= (1 << 4);
				vTaskDelay(pdMS_TO_TICKS(750));
			}
			PORTD &= (~(1<<5));
    1394:	5d 98       	cbi	0x0b, 5	; 11
			vTaskDelay (pdMS_TO_TICKS(3000));
    1396:	82 e3       	ldi	r24, 0x32	; 50
    1398:	90 e0       	ldi	r25, 0x00	; 0
    139a:	0e 94 bc 07 	call	0xf78	; 0xf78 <vTaskDelay>
    139e:	de cf       	rjmp	.-68     	; 0x135c <fanTask>

000013a0 <blinkLED>:

// EXAMPLE BLINKER TASK
void blinkLED(void* parameter) {	
	for (;;){	
	 //la task viene creata ma va subito sospesa in attesa di chiamata. non servono semafori perch non ci sono risorse condivise.
		vTaskSuspend(NULL); //Quando impostato a Null sospende se stessa.
    13a0:	80 e0       	ldi	r24, 0x00	; 0
    13a2:	90 e0       	ldi	r25, 0x00	; 0
    13a4:	0e 94 75 08 	call	0x10ea	; 0x10ea <vTaskSuspend>
		PORTD |= (1 << 3);
    13a8:	5b 9a       	sbi	0x0b, 3	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    13aa:	8d e3       	ldi	r24, 0x3D	; 61
    13ac:	99 e4       	ldi	r25, 0x49	; 73
    13ae:	01 97       	sbiw	r24, 0x01	; 1
    13b0:	f1 f7       	brne	.-4      	; 0x13ae <blinkLED+0xe>
    13b2:	00 c0       	rjmp	.+0      	; 0x13b4 <blinkLED+0x14>
    13b4:	00 00       	nop
		_delay_ms(75);
		PORTD &= (~(1<<3));
    13b6:	5b 98       	cbi	0x0b, 3	; 11
    13b8:	89 e6       	ldi	r24, 0x69	; 105
    13ba:	98 e1       	ldi	r25, 0x18	; 24
    13bc:	01 97       	sbiw	r24, 0x01	; 1
    13be:	f1 f7       	brne	.-4      	; 0x13bc <blinkLED+0x1c>
    13c0:	00 c0       	rjmp	.+0      	; 0x13c2 <blinkLED+0x22>
    13c2:	00 00       	nop
    13c4:	ed cf       	rjmp	.-38     	; 0x13a0 <blinkLED>

000013c6 <__vector_18>:
		
	}
}
*/

ISR (USART_RX_vect) {
    13c6:	1f 92       	push	r1
    13c8:	0f 92       	push	r0
    13ca:	0f b6       	in	r0, 0x3f	; 63
    13cc:	0f 92       	push	r0
    13ce:	11 24       	eor	r1, r1
    13d0:	2f 93       	push	r18
    13d2:	3f 93       	push	r19
    13d4:	4f 93       	push	r20
    13d6:	5f 93       	push	r21
    13d8:	6f 93       	push	r22
    13da:	7f 93       	push	r23
    13dc:	8f 93       	push	r24
    13de:	9f 93       	push	r25
    13e0:	af 93       	push	r26
    13e2:	bf 93       	push	r27
    13e4:	ef 93       	push	r30
    13e6:	ff 93       	push	r31
    13e8:	cf 93       	push	r28
    13ea:	df 93       	push	r29
    13ec:	00 d0       	rcall	.+0      	; 0x13ee <__vector_18+0x28>
    13ee:	cd b7       	in	r28, 0x3d	; 61
    13f0:	de b7       	in	r29, 0x3e	; 62
	
	signed char cChar;
	
	cChar = UDR0;
    13f2:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
    13f6:	89 83       	std	Y+1, r24	; 0x01
	
	//UART_sendString("Interrupt");
		
	//Due righe che servono sempre per lo YIELD delle task di FREERTOS
	BaseType_t xHigherPriorityTaskWoken;
	xHigherPriorityTaskWoken = pdFALSE;
    13f8:	1a 82       	std	Y+2, r1	; 0x02
	
	//La coda serve per scambiare messaggi tra le task. 
	//Penso che per altre task si possa utilizzare anche il suspend ed il resume. 
	xQueueSendFromISR( xIntegerQueue, &cChar, &xHigherPriorityTaskWoken );
    13fa:	20 e0       	ldi	r18, 0x00	; 0
    13fc:	ae 01       	movw	r20, r28
    13fe:	4e 5f       	subi	r20, 0xFE	; 254
    1400:	5f 4f       	sbci	r21, 0xFF	; 255
    1402:	be 01       	movw	r22, r28
    1404:	6f 5f       	subi	r22, 0xFF	; 255
    1406:	7f 4f       	sbci	r23, 0xFF	; 255
    1408:	80 91 3c 08 	lds	r24, 0x083C	; 0x80083c <xIntegerQueue>
    140c:	90 91 3d 08 	lds	r25, 0x083D	; 0x80083d <xIntegerQueue+0x1>
    1410:	0e 94 90 03 	call	0x720	; 0x720 <xQueueGenericSendFromISR>
	
	//xSemaphoreGiveFromISR( xBinarySemaphore, &xHigherPriorityTaskWoken );
	
	
	//Serve sempre per lo yield. Sulla documentazione  scritto come un'altra funzione, ma per atmega328p  questa. 
	if( xHigherPriorityTaskWoken != pdFALSE ) {
    1414:	8a 81       	ldd	r24, Y+2	; 0x02
    1416:	81 11       	cpse	r24, r1
		taskYIELD();
    1418:	0e 94 bf 01 	call	0x37e	; 0x37e <vPortYield>
	}
	
		
}
    141c:	0f 90       	pop	r0
    141e:	0f 90       	pop	r0
    1420:	df 91       	pop	r29
    1422:	cf 91       	pop	r28
    1424:	ff 91       	pop	r31
    1426:	ef 91       	pop	r30
    1428:	bf 91       	pop	r27
    142a:	af 91       	pop	r26
    142c:	9f 91       	pop	r25
    142e:	8f 91       	pop	r24
    1430:	7f 91       	pop	r23
    1432:	6f 91       	pop	r22
    1434:	5f 91       	pop	r21
    1436:	4f 91       	pop	r20
    1438:	3f 91       	pop	r19
    143a:	2f 91       	pop	r18
    143c:	0f 90       	pop	r0
    143e:	0f be       	out	0x3f, r0	; 63
    1440:	0f 90       	pop	r0
    1442:	1f 90       	pop	r1
    1444:	18 95       	reti

00001446 <UART_init>:
}

void UART_init()
{
	// Imposta la velocit di trasmissione
	UBRR0H = (BAUD_PRESCALER >> 8);
    1446:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
	UBRR0L = BAUD_PRESCALER;
    144a:	87 e6       	ldi	r24, 0x67	; 103
    144c:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
	
	// Abilita la trasmissione e la ricezione
	UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
    1450:	88 e9       	ldi	r24, 0x98	; 152
    1452:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
	
	// Imposta il formato dei dati: 8 bit di dati, 1 bit di stop
	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);
    1456:	86 e0       	ldi	r24, 0x06	; 6
    1458:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__DATA_REGION_ORIGIN__+0x62>
    145c:	08 95       	ret

0000145e <UART_sendChar>:
}

void UART_sendChar(char data)
{
	// Attendi che il buffer di trasmissione sia vuoto
	while (!(UCSR0A & (1 << UDRE0)));
    145e:	e0 ec       	ldi	r30, 0xC0	; 192
    1460:	f0 e0       	ldi	r31, 0x00	; 0
    1462:	90 81       	ld	r25, Z
    1464:	95 ff       	sbrs	r25, 5
    1466:	fd cf       	rjmp	.-6      	; 0x1462 <UART_sendChar+0x4>
	
	// Carica il dato nel buffer di trasmissione
	UDR0 = data;
    1468:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
    146c:	08 95       	ret

0000146e <UART_sendString>:
	// Imposta il formato dei dati: 8 bit di dati, 1 bit di stop
	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);
}

void UART_sendString(const char* data)
{
    146e:	cf 93       	push	r28
    1470:	df 93       	push	r29
    1472:	ec 01       	movw	r28, r24
	// Invia carattere per carattere fino a quando non si raggiunge il terminatore null
	while (*data != '\0')
    1474:	88 81       	ld	r24, Y
    1476:	88 23       	and	r24, r24
    1478:	39 f0       	breq	.+14     	; 0x1488 <UART_sendString+0x1a>
    147a:	21 96       	adiw	r28, 0x01	; 1
	{
		UART_sendChar(*data);
    147c:	90 e0       	ldi	r25, 0x00	; 0
    147e:	0e 94 2f 0a 	call	0x145e	; 0x145e <UART_sendChar>
}

void UART_sendString(const char* data)
{
	// Invia carattere per carattere fino a quando non si raggiunge il terminatore null
	while (*data != '\0')
    1482:	89 91       	ld	r24, Y+
    1484:	81 11       	cpse	r24, r1
    1486:	fa cf       	rjmp	.-12     	; 0x147c <UART_sendString+0xe>
	{
		UART_sendChar(*data);
		data++;
	}
}
    1488:	df 91       	pop	r29
    148a:	cf 91       	pop	r28
    148c:	08 95       	ret

0000148e <serialInterruptTask>:
		
}



void serialInterruptTask (void *parameters) {
    148e:	cf 93       	push	r28
    1490:	df 93       	push	r29
    1492:	00 d0       	rcall	.+0      	; 0x1494 <serialInterruptTask+0x6>
    1494:	cd b7       	in	r28, 0x3d	; 61
    1496:	de b7       	in	r29, 0x3e	; 62
			stateBuzzer = 0;
			stateFan = 0;
			break;
			case 2:
			UART_sendString("STATE: Buzzer ON\n");
			stateBuzzer = 1;
    1498:	ee 24       	eor	r14, r14
    149a:	e3 94       	inc	r14
    149c:	f1 2c       	mov	r15, r1
		
	char *pcString; //where the queue receive the msg.
	
	for( ;; ) {
		/* Block on the queue to wait for data to arrive. */
		xQueueReceive( xIntegerQueue, &pcString, portMAX_DELAY );
    149e:	20 e0       	ldi	r18, 0x00	; 0
    14a0:	4f ef       	ldi	r20, 0xFF	; 255
    14a2:	5f ef       	ldi	r21, 0xFF	; 255
    14a4:	be 01       	movw	r22, r28
    14a6:	6f 5f       	subi	r22, 0xFF	; 255
    14a8:	7f 4f       	sbci	r23, 0xFF	; 255
    14aa:	80 91 3c 08 	lds	r24, 0x083C	; 0x80083c <xIntegerQueue>
    14ae:	90 91 3d 08 	lds	r25, 0x083D	; 0x80083d <xIntegerQueue+0x1>
    14b2:	0e 94 ca 03 	call	0x794	; 0x794 <xQueueGenericReceive>
    14b6:	09 81       	ldd	r16, Y+1	; 0x01
    14b8:	1a 81       	ldd	r17, Y+2	; 0x02
    14ba:	00 53       	subi	r16, 0x30	; 48
    14bc:	11 09       	sbc	r17, r1
    14be:	11 27       	eor	r17, r17
		
		uint8_t commandReceived  = pcString - 0x30; //Gives the number from exadecimal to Ascii
		
		switch (commandReceived) {
    14c0:	02 30       	cpi	r16, 0x02	; 2
    14c2:	11 05       	cpc	r17, r1
    14c4:	c1 f1       	breq	.+112    	; 0x1536 <serialInterruptTask+0xa8>
    14c6:	3c f4       	brge	.+14     	; 0x14d6 <serialInterruptTask+0x48>
    14c8:	01 15       	cp	r16, r1
    14ca:	11 05       	cpc	r17, r1
    14cc:	71 f0       	breq	.+28     	; 0x14ea <serialInterruptTask+0x5c>
    14ce:	01 30       	cpi	r16, 0x01	; 1
    14d0:	11 05       	cpc	r17, r1
    14d2:	21 f1       	breq	.+72     	; 0x151c <serialInterruptTask+0x8e>
    14d4:	6c c0       	rjmp	.+216    	; 0x15ae <serialInterruptTask+0x120>
    14d6:	04 30       	cpi	r16, 0x04	; 4
    14d8:	11 05       	cpc	r17, r1
    14da:	09 f4       	brne	.+2      	; 0x14de <serialInterruptTask+0x50>
    14dc:	4a c0       	rjmp	.+148    	; 0x1572 <serialInterruptTask+0xe4>
    14de:	d4 f1       	brlt	.+116    	; 0x1554 <serialInterruptTask+0xc6>
    14e0:	05 30       	cpi	r16, 0x05	; 5
    14e2:	11 05       	cpc	r17, r1
    14e4:	09 f4       	brne	.+2      	; 0x14e8 <serialInterruptTask+0x5a>
    14e6:	54 c0       	rjmp	.+168    	; 0x1590 <serialInterruptTask+0x102>
    14e8:	62 c0       	rjmp	.+196    	; 0x15ae <serialInterruptTask+0x120>
			case 0:
			UART_sendString("STATE: Alarm ON\n");
    14ea:	85 e0       	ldi	r24, 0x05	; 5
    14ec:	91 e0       	ldi	r25, 0x01	; 1
    14ee:	0e 94 37 0a 	call	0x146e	; 0x146e <UART_sendString>
			stateBuzzer = 1;
    14f2:	f0 92 2b 08 	sts	0x082B, r15	; 0x80082b <stateBuzzer+0x1>
    14f6:	e0 92 2a 08 	sts	0x082A, r14	; 0x80082a <stateBuzzer>
			stateFan = 1;
    14fa:	f0 92 29 08 	sts	0x0829, r15	; 0x800829 <stateFan+0x1>
    14fe:	e0 92 28 08 	sts	0x0828, r14	; 0x800828 <stateFan>
			vTaskResume(buzzerTaskHandle);
    1502:	80 91 30 08 	lds	r24, 0x0830	; 0x800830 <buzzerTaskHandle>
    1506:	90 91 31 08 	lds	r25, 0x0831	; 0x800831 <buzzerTaskHandle+0x1>
    150a:	0e 94 03 06 	call	0xc06	; 0xc06 <vTaskResume>
			vTaskResume(fanTaskHandle);
    150e:	80 91 2e 08 	lds	r24, 0x082E	; 0x80082e <fanTaskHandle>
    1512:	90 91 2f 08 	lds	r25, 0x082F	; 0x80082f <fanTaskHandle+0x1>
    1516:	0e 94 03 06 	call	0xc06	; 0xc06 <vTaskResume>
			break;//causa l'uscita immediata dallo switch
    151a:	c1 cf       	rjmp	.-126    	; 0x149e <serialInterruptTask+0x10>
			case 1:
			UART_sendString("STATE: Alarm OFF\n");
    151c:	86 e1       	ldi	r24, 0x16	; 22
    151e:	91 e0       	ldi	r25, 0x01	; 1
    1520:	0e 94 37 0a 	call	0x146e	; 0x146e <UART_sendString>
			stateBuzzer = 0;
    1524:	10 92 2b 08 	sts	0x082B, r1	; 0x80082b <stateBuzzer+0x1>
    1528:	10 92 2a 08 	sts	0x082A, r1	; 0x80082a <stateBuzzer>
			stateFan = 0;
    152c:	10 92 29 08 	sts	0x0829, r1	; 0x800829 <stateFan+0x1>
    1530:	10 92 28 08 	sts	0x0828, r1	; 0x800828 <stateFan>
			break;
    1534:	b4 cf       	rjmp	.-152    	; 0x149e <serialInterruptTask+0x10>
			case 2:
			UART_sendString("STATE: Buzzer ON\n");
    1536:	88 e2       	ldi	r24, 0x28	; 40
    1538:	91 e0       	ldi	r25, 0x01	; 1
    153a:	0e 94 37 0a 	call	0x146e	; 0x146e <UART_sendString>
			stateBuzzer = 1;
    153e:	f0 92 2b 08 	sts	0x082B, r15	; 0x80082b <stateBuzzer+0x1>
    1542:	e0 92 2a 08 	sts	0x082A, r14	; 0x80082a <stateBuzzer>
			vTaskResume(buzzerTaskHandle);
    1546:	80 91 30 08 	lds	r24, 0x0830	; 0x800830 <buzzerTaskHandle>
    154a:	90 91 31 08 	lds	r25, 0x0831	; 0x800831 <buzzerTaskHandle+0x1>
    154e:	0e 94 03 06 	call	0xc06	; 0xc06 <vTaskResume>
			break;
    1552:	a5 cf       	rjmp	.-182    	; 0x149e <serialInterruptTask+0x10>
			case 3:
			UART_sendString("STATE: Buzzer OFF\n");
    1554:	8a e3       	ldi	r24, 0x3A	; 58
    1556:	91 e0       	ldi	r25, 0x01	; 1
    1558:	0e 94 37 0a 	call	0x146e	; 0x146e <UART_sendString>
			stateBuzzer = 0;
    155c:	10 92 2b 08 	sts	0x082B, r1	; 0x80082b <stateBuzzer+0x1>
    1560:	10 92 2a 08 	sts	0x082A, r1	; 0x80082a <stateBuzzer>
			vTaskSuspend(buzzerTaskHandle);
    1564:	80 91 30 08 	lds	r24, 0x0830	; 0x800830 <buzzerTaskHandle>
    1568:	90 91 31 08 	lds	r25, 0x0831	; 0x800831 <buzzerTaskHandle+0x1>
    156c:	0e 94 75 08 	call	0x10ea	; 0x10ea <vTaskSuspend>
			break;
    1570:	96 cf       	rjmp	.-212    	; 0x149e <serialInterruptTask+0x10>
			case 4:
			UART_sendString("STATE: Fan ON\n");
    1572:	8d e4       	ldi	r24, 0x4D	; 77
    1574:	91 e0       	ldi	r25, 0x01	; 1
    1576:	0e 94 37 0a 	call	0x146e	; 0x146e <UART_sendString>
			stateFan = 1;
    157a:	f0 92 29 08 	sts	0x0829, r15	; 0x800829 <stateFan+0x1>
    157e:	e0 92 28 08 	sts	0x0828, r14	; 0x800828 <stateFan>
			vTaskResume(fanTaskHandle);
    1582:	80 91 2e 08 	lds	r24, 0x082E	; 0x80082e <fanTaskHandle>
    1586:	90 91 2f 08 	lds	r25, 0x082F	; 0x80082f <fanTaskHandle+0x1>
    158a:	0e 94 03 06 	call	0xc06	; 0xc06 <vTaskResume>
			break;
    158e:	87 cf       	rjmp	.-242    	; 0x149e <serialInterruptTask+0x10>
			case 5:
			UART_sendString("STATE: Fan OFF\n");
    1590:	8c e5       	ldi	r24, 0x5C	; 92
    1592:	91 e0       	ldi	r25, 0x01	; 1
    1594:	0e 94 37 0a 	call	0x146e	; 0x146e <UART_sendString>
			stateFan = 0;
    1598:	10 92 29 08 	sts	0x0829, r1	; 0x800829 <stateFan+0x1>
    159c:	10 92 28 08 	sts	0x0828, r1	; 0x800828 <stateFan>
			vTaskSuspend(fanTaskHandle);
    15a0:	80 91 2e 08 	lds	r24, 0x082E	; 0x80082e <fanTaskHandle>
    15a4:	90 91 2f 08 	lds	r25, 0x082F	; 0x80082f <fanTaskHandle+0x1>
    15a8:	0e 94 75 08 	call	0x10ea	; 0x10ea <vTaskSuspend>
			break;
    15ac:	78 cf       	rjmp	.-272    	; 0x149e <serialInterruptTask+0x10>
			default:
			UART_sendString("Wrong command. \n");
    15ae:	8c e6       	ldi	r24, 0x6C	; 108
    15b0:	91 e0       	ldi	r25, 0x01	; 1
    15b2:	0e 94 37 0a 	call	0x146e	; 0x146e <UART_sendString>
			UART_sendString ("String: \n");
    15b6:	8d e7       	ldi	r24, 0x7D	; 125
    15b8:	91 e0       	ldi	r25, 0x01	; 1
    15ba:	0e 94 37 0a 	call	0x146e	; 0x146e <UART_sendString>
			UART_sendString(commandReceived);
    15be:	c8 01       	movw	r24, r16
    15c0:	0e 94 37 0a 	call	0x146e	; 0x146e <UART_sendString>
			UART_sendString ("\n Char: \n");
    15c4:	87 e8       	ldi	r24, 0x87	; 135
    15c6:	91 e0       	ldi	r25, 0x01	; 1
    15c8:	0e 94 37 0a 	call	0x146e	; 0x146e <UART_sendString>
			UART_sendChar(commandReceived);
    15cc:	c8 01       	movw	r24, r16
    15ce:	0e 94 2f 0a 	call	0x145e	; 0x145e <UART_sendChar>
			UART_sendString ("\n");
    15d2:	8b e7       	ldi	r24, 0x7B	; 123
    15d4:	91 e0       	ldi	r25, 0x01	; 1
    15d6:	0e 94 37 0a 	call	0x146e	; 0x146e <UART_sendString>
			break;
    15da:	61 cf       	rjmp	.-318    	; 0x149e <serialInterruptTask+0x10>

000015dc <main>:

// MAIN PROGRAM
int main(void)
{
	
	UART_init();
    15dc:	0e 94 23 0a 	call	0x1446	; 0x1446 <UART_init>
	
	DDRD = 0xFF;
    15e0:	8f ef       	ldi	r24, 0xFF	; 255
    15e2:	8a b9       	out	0x0a, r24	; 10
	
	DDRB |= (1 << PB5);
    15e4:	25 9a       	sbi	0x04, 5	; 4
	UART_sendString("Main. \n");
    15e6:	81 e9       	ldi	r24, 0x91	; 145
    15e8:	91 e0       	ldi	r25, 0x01	; 1
    15ea:	0e 94 37 0a 	call	0x146e	; 0x146e <UART_sendString>
	
	xIntegerQueue = xQueueCreate( 10, sizeof( char * ) );
    15ee:	40 e0       	ldi	r20, 0x00	; 0
    15f0:	62 e0       	ldi	r22, 0x02	; 2
    15f2:	8a e0       	ldi	r24, 0x0A	; 10
    15f4:	0e 94 63 03 	call	0x6c6	; 0x6c6 <xQueueGenericCreate>
    15f8:	90 93 3d 08 	sts	0x083D, r25	; 0x80083d <xIntegerQueue+0x1>
    15fc:	80 93 3c 08 	sts	0x083C, r24	; 0x80083c <xIntegerQueue>
	
	
		
	// CREATE BLINKER TASK
	xTaskCreate(blinkLED, "blink", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, &blinkLedHandle);
    1600:	0f 2e       	mov	r0, r31
    1602:	fa e3       	ldi	r31, 0x3A	; 58
    1604:	ef 2e       	mov	r14, r31
    1606:	f8 e0       	ldi	r31, 0x08	; 8
    1608:	ff 2e       	mov	r15, r31
    160a:	f0 2d       	mov	r31, r0
    160c:	00 e0       	ldi	r16, 0x00	; 0
    160e:	20 e0       	ldi	r18, 0x00	; 0
    1610:	30 e0       	ldi	r19, 0x00	; 0
    1612:	45 e5       	ldi	r20, 0x55	; 85
    1614:	50 e0       	ldi	r21, 0x00	; 0
    1616:	69 e9       	ldi	r22, 0x99	; 153
    1618:	71 e0       	ldi	r23, 0x01	; 1
    161a:	80 ed       	ldi	r24, 0xD0	; 208
    161c:	99 e0       	ldi	r25, 0x09	; 9
    161e:	0e 94 f6 04 	call	0x9ec	; 0x9ec <xTaskCreate>
	xTaskCreate(stopBlinkLED, "stopBlink", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, &stopBlinkLedHandle);
    1622:	0f 2e       	mov	r0, r31
    1624:	f8 e3       	ldi	r31, 0x38	; 56
    1626:	ef 2e       	mov	r14, r31
    1628:	f8 e0       	ldi	r31, 0x08	; 8
    162a:	ff 2e       	mov	r15, r31
    162c:	f0 2d       	mov	r31, r0
    162e:	20 e0       	ldi	r18, 0x00	; 0
    1630:	30 e0       	ldi	r19, 0x00	; 0
    1632:	45 e5       	ldi	r20, 0x55	; 85
    1634:	50 e0       	ldi	r21, 0x00	; 0
    1636:	6f e9       	ldi	r22, 0x9F	; 159
    1638:	71 e0       	ldi	r23, 0x01	; 1
    163a:	8a e7       	ldi	r24, 0x7A	; 122
    163c:	99 e0       	ldi	r25, 0x09	; 9
    163e:	0e 94 f6 04 	call	0x9ec	; 0x9ec <xTaskCreate>
	
	xTaskCreate(alarmON, "alarmON", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, &alarmONTaskHandle); 
    1642:	0f 2e       	mov	r0, r31
    1644:	f4 e3       	ldi	r31, 0x34	; 52
    1646:	ef 2e       	mov	r14, r31
    1648:	f8 e0       	ldi	r31, 0x08	; 8
    164a:	ff 2e       	mov	r15, r31
    164c:	f0 2d       	mov	r31, r0
    164e:	20 e0       	ldi	r18, 0x00	; 0
    1650:	30 e0       	ldi	r19, 0x00	; 0
    1652:	45 e5       	ldi	r20, 0x55	; 85
    1654:	50 e0       	ldi	r21, 0x00	; 0
    1656:	69 ea       	ldi	r22, 0xA9	; 169
    1658:	71 e0       	ldi	r23, 0x01	; 1
    165a:	81 e8       	ldi	r24, 0x81	; 129
    165c:	99 e0       	ldi	r25, 0x09	; 9
    165e:	0e 94 f6 04 	call	0x9ec	; 0x9ec <xTaskCreate>
	xTaskCreate(alarmOFF, "alarmOFF", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, &alarmOFFTaskHandle); 
    1662:	0f 2e       	mov	r0, r31
    1664:	f2 e3       	ldi	r31, 0x32	; 50
    1666:	ef 2e       	mov	r14, r31
    1668:	f8 e0       	ldi	r31, 0x08	; 8
    166a:	ff 2e       	mov	r15, r31
    166c:	f0 2d       	mov	r31, r0
    166e:	20 e0       	ldi	r18, 0x00	; 0
    1670:	30 e0       	ldi	r19, 0x00	; 0
    1672:	45 e5       	ldi	r20, 0x55	; 85
    1674:	50 e0       	ldi	r21, 0x00	; 0
    1676:	61 eb       	ldi	r22, 0xB1	; 177
    1678:	71 e0       	ldi	r23, 0x01	; 1
    167a:	85 e6       	ldi	r24, 0x65	; 101
    167c:	99 e0       	ldi	r25, 0x09	; 9
    167e:	0e 94 f6 04 	call	0x9ec	; 0x9ec <xTaskCreate>
	
	xTaskCreate(buzzerTask, "buzzerTask", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, &buzzerTaskHandle); 
    1682:	0f 2e       	mov	r0, r31
    1684:	f0 e3       	ldi	r31, 0x30	; 48
    1686:	ef 2e       	mov	r14, r31
    1688:	f8 e0       	ldi	r31, 0x08	; 8
    168a:	ff 2e       	mov	r15, r31
    168c:	f0 2d       	mov	r31, r0
    168e:	20 e0       	ldi	r18, 0x00	; 0
    1690:	30 e0       	ldi	r19, 0x00	; 0
    1692:	45 e5       	ldi	r20, 0x55	; 85
    1694:	50 e0       	ldi	r21, 0x00	; 0
    1696:	6a eb       	ldi	r22, 0xBA	; 186
    1698:	71 e0       	ldi	r23, 0x01	; 1
    169a:	88 e9       	ldi	r24, 0x98	; 152
    169c:	99 e0       	ldi	r25, 0x09	; 9
    169e:	0e 94 f6 04 	call	0x9ec	; 0x9ec <xTaskCreate>
	xTaskCreate(fanTask, "fanTask", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, &fanTaskHandle);	
    16a2:	0f 2e       	mov	r0, r31
    16a4:	fe e2       	ldi	r31, 0x2E	; 46
    16a6:	ef 2e       	mov	r14, r31
    16a8:	f8 e0       	ldi	r31, 0x08	; 8
    16aa:	ff 2e       	mov	r15, r31
    16ac:	f0 2d       	mov	r31, r0
    16ae:	20 e0       	ldi	r18, 0x00	; 0
    16b0:	30 e0       	ldi	r19, 0x00	; 0
    16b2:	45 e5       	ldi	r20, 0x55	; 85
    16b4:	50 e0       	ldi	r21, 0x00	; 0
    16b6:	65 ec       	ldi	r22, 0xC5	; 197
    16b8:	71 e0       	ldi	r23, 0x01	; 1
    16ba:	8e ea       	ldi	r24, 0xAE	; 174
    16bc:	99 e0       	ldi	r25, 0x09	; 9
    16be:	0e 94 f6 04 	call	0x9ec	; 0x9ec <xTaskCreate>
	
	
	//xTaskCreate(myTask2, "myTask2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, &myTask2Handle);
		
	xTaskCreate(serialInterruptTask, "serialInterruptTask", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, &serialInterruptTaskHandle);
    16c2:	0f 2e       	mov	r0, r31
    16c4:	f6 e3       	ldi	r31, 0x36	; 54
    16c6:	ef 2e       	mov	r14, r31
    16c8:	f8 e0       	ldi	r31, 0x08	; 8
    16ca:	ff 2e       	mov	r15, r31
    16cc:	f0 2d       	mov	r31, r0
    16ce:	20 e0       	ldi	r18, 0x00	; 0
    16d0:	30 e0       	ldi	r19, 0x00	; 0
    16d2:	45 e5       	ldi	r20, 0x55	; 85
    16d4:	50 e0       	ldi	r21, 0x00	; 0
    16d6:	6d ec       	ldi	r22, 0xCD	; 205
    16d8:	71 e0       	ldi	r23, 0x01	; 1
    16da:	87 e4       	ldi	r24, 0x47	; 71
    16dc:	9a e0       	ldi	r25, 0x0A	; 10
    16de:	0e 94 f6 04 	call	0x9ec	; 0x9ec <xTaskCreate>

	sei();
    16e2:	78 94       	sei
	
	// START SCHELUDER
	vTaskStartScheduler();
    16e4:	0e 94 52 06 	call	0xca4	; 0xca4 <vTaskStartScheduler>
    16e8:	ff cf       	rjmp	.-2      	; 0x16e8 <main+0x10c>

000016ea <vApplicationIdleHook>:

}

// IDLE TASK
void vApplicationIdleHook(void)
{
    16ea:	08 95       	ret

000016ec <memcpy>:
    16ec:	fb 01       	movw	r30, r22
    16ee:	dc 01       	movw	r26, r24
    16f0:	02 c0       	rjmp	.+4      	; 0x16f6 <memcpy+0xa>
    16f2:	01 90       	ld	r0, Z+
    16f4:	0d 92       	st	X+, r0
    16f6:	41 50       	subi	r20, 0x01	; 1
    16f8:	50 40       	sbci	r21, 0x00	; 0
    16fa:	d8 f7       	brcc	.-10     	; 0x16f2 <memcpy+0x6>
    16fc:	08 95       	ret

000016fe <_exit>:
    16fe:	f8 94       	cli

00001700 <__stop_program>:
    1700:	ff cf       	rjmp	.-2      	; 0x1700 <__stop_program>
