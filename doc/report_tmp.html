<!DOCTYPE html>
<html>
<head>
<title>report.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="iot-security-project-prereport----omit-in-toc">IoT Security Project (pre)Report <!-- omit in toc --></h1>
<ul>
<li><a href="#intro">Intro</a></li>
<li><a href="#project-scope">Project Scope</a></li>
<li><a href="#architecture">Architecture</a></li>
<li><a href="#southbound">Southbound</a>
<ul>
<li><a href="#arduino-uno">Arduino UNO</a>
<ul>
<li><a href="#sensors-and-adc"><strong>Sensors</strong> and <strong>ADC</strong></a></li>
<li><a href="#uart">UART</a></li>
</ul>
</li>
<li><a href="#esp8266">ESP8266</a></li>
</ul>
</li>
<li><a href="#cloud">Cloud</a>
<ul>
<li><a href="#ssh-key">SSH Key</a></li>
<li><a href="#ubuntu-ufw">Ubuntu UFW</a></li>
<li><a href="#mqtt-broker---mosquitto">MQTT Broker - Mosquitto</a>
<ul>
<li><a href="#lets-encrypt-certificate">Let's Encrypt certificate</a></li>
<li><a href="#mosquitto-configuration">Mosquitto configuration</a></li>
</ul>
</li>
<li><a href="#database">Database</a></li>
<li><a href="#node-red">Node-RED</a></li>
<li><a href="#data-flow">Data flow</a></li>
<li><a href="#node-red---encrypt-and-store">Node-RED - <em>Encrypt and Store</em></a></li>
<li><a href="#node-red---query-and-decrypt">Node-RED - <em>Query and Decrypt</em></a></li>
</ul>
</li>
<li><a href="#northbound">Northbound</a>
<ul>
<li><a href="#android-app">Android App</a>
<ul>
<li><a href="#mqtthandlerdart">MqttHandler.dart</a></li>
<li><a href="#front-end">Front End</a></li>
</ul>
</li>
<li><a href="#nodered-dashboard">NodeRED Dashboard</a>
<ul>
<li><a href="#back-end">Back-end</a></li>
<li><a href="#front-end-1">Front-end</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="intro">Intro</h2>
<p>The IoT Security Project Report provides an overview and analysis of the security aspects implemented in an IoT project. As the Internet of Things (IoT) continues to expand, ensuring the security and privacy of connected devices and their data becomes increasingly important.</p>
<p>This report delves into the various components of the IoT system, categorized into three main sections: Northbound, Cloud, Southbound, Transport Protocol. Each section represents a distinct aspect of the project and plays a crucial role in the overall security architecture. In addition to the man categories there are other that are no less important like Transport Layer - MQTT, Database. Both are included in the cloud section, but it is important to mention them thanks to their role in the project.</p>
<p>The Southbound category represents the source of the data, which is the physical device in this case. This section explores the specifications, hardware components, and security features implemented in the physical device to ensure protection against physical tampering or unauthorized access.</p>
<p>The Cloud section focuses on the cloud infrastructure. Inside the cloud infrastructure are located also the the MQTT broker, used to facilitate communication between the devices and the cloud, and the database, used to store data. The protocols, security measures, and authentication mechanisms employed to establish a secure and reliable connection are discussed.</p>
<p>The Northbound category encompasses the applications that read and interact with the data collected by the IoT system, such as the Android App and NodeRED dashboard. The security measures implemented in these applications for secure user authentication, data visualization, and control over connected devices are analyzed.</p>
<p>Throughout this report, best practices, challenges faced, and lessons learned in securing an IoT system are highlighted within these three macro categories. By examining the security measures within each category, valuable insights and recommendations for enhancing the overall security posture of IoT projects are provided.</p>
<p>The IoT Security Project Report delves into the details of the Northbound applications, the Cloud, Southbound physical device, uncovering the security measures implemented to protect against potential threats.</p>
<h2 id="project-scope">Project Scope</h2>
<p>The project has been designed to address the safety needs of a chemical laboratory where chemical gas releases and fires may occur. Its main purpose is to ensure a safe working environment for the laboratory personnel, prevent potential incidents, and minimize the negative effects resulting from such situations.</p>
<p>The key features of the project include timely detection of chemical gas releases and fires, immediate alerting of the personnel, and implementation of mitigation measures to minimize the harmful effects. The specific objectives of the project are outlined below:</p>
<ol>
<li>
<p>Detection of chemical gas releases: The implemented system allows for the real-time identification and monitoring of any leaks or releases of chemical gases within the laboratory. Using specially designed sensors, the system can detect the presence of hazardous substances in the air and generate an immediate alert to the laboratory personnel.</p>
</li>
<li>
<p>Fire detection: The project also encompasses early fire detection. Smoke, heat, and flame sensors are strategically placed in the laboratory to promptly detect signals of potential fires. These sensors trigger an alarm and send an immediate notification to the personnel so they can take necessary evacuation and extinguishing actions.</p>
</li>
<li>
<p>Alerting and notifications: When a chemical gas release or fire is detected, the system activates an audible and visual alarm within the laboratory to immediately alert the personnel present. Simultaneously, automatic notifications are sent to the safety officers and designated personnel through mobile devices or an internal communication system.</p>
</li>
<li>
<p>Mitigation measures: In addition to timely alerts, the project includes the implementation of mitigation measures to minimize the negative effects of chemical gas releases and fires. These measures may involve activating ventilation systems, automatically closing gas valves, isolating specific areas, and deploying specialized teams to handle the emergency.</p>
</li>
</ol>
<p>By implementing this project, the chemical laboratory will significantly enhance the safety of its operations. The timely detection of chemical gas releases and fires, coupled with appropriate alerting and mitigation measures, will help protect the personnel, prevent material damages, and preserve the surrounding environment.</p>
<p>The project aims to provide the laboratory with a solid safety foundation, enabling the personnel to carry out their activities in a controlled and protected environment, in accordance with the best industrial safety practices.</p>
<h2 id="architecture">Architecture</h2>
<p>The architecture comprises three essential components, as mentioned befor: the <strong>Southbound</strong>, <strong>Cloud</strong>, and <strong>Northbound</strong>.</p>
<p>The Southbound component encompasses the physical device responsible for sensing environmental data, such as temperature and air quality, as well as managing alarms triggered by threshold exceedances. It also includes actuating mechanisms, including a buzzer for alerting users to potential dangers and a fan for enhancing air circulation.</p>
<p>The Cloud component focuses on the cloud infrastructure, incorporating an MQTT broker (Mosquitto) for reliable device communication, a database (MySQL) for secure data storage, and Node-RED for efficient data flow management.</p>
<p>Lastly, the Northbound component consists of user-facing applications, namely the Android App and Node-RED Dashboard, providing intuitive interfaces for data visualization and interaction. By integrating these three components, the architecture ensures a secure, efficient, and user-friendly IoT system capable of safeguarding data privacy, detecting anomalies, and facilitating informed decision-making.</p>
<p align="center">
  <img src="file:///c:/Repositories/IotProjectUnical/doc/images/system_architecture.png" alt="System architecture">
</p>
<p>The overall system architecture is illustrated in the  image. This image provides a visual representation of how the different components interact and highlights the protocol used within the system.</p>
<h2 id="southbound">Southbound</h2>
<p>This section provides an overview of the part of the project where data are generated.
The generation of the data that flow in the architecture are sensed from the external and are in the form of Temperature (°) and Quality of Air.
The data are sensed using the physical device discussed below.
The devices used for the project are two:</p>
<ul>
<li>Arduino UNO: used for sesnsing the data;</li>
<li>ESP8266: used for network interfacing.</li>
</ul>
<p align="center">
  <img src="file:///c:/Repositories/IotProjectUnical/doc/images/southbound_architecture.png" alt="Southbound architecture">
</p>
<h3 id="arduino-uno">Arduino UNO</h3>
<p>The <strong>Arduino Uno</strong> acts as a pivotal board housing the ATMega328P microprocessor, providing the necessary computational power for the project. Within the Arduino Uno, several components are employed to facilitate the system's functionality.</p>
<h4 id="sensors-and-adc"><strong>Sensors</strong> and <strong>ADC</strong></h4>
<p>For the sensing phase, two distinct analogic sensors are utilized: the MQ135 and the TMP36.</p>
<p align="center">
  <img src="file:///c:/Repositories/IotProjectUnical/doc/images/tmp36.jpg" alt="TMP36 Temperature sensor." width="300">
  <img src="file:///c:/Repositories/IotProjectUnical/doc/images/mq135.jpg" alt="MQ135 Air Quality Sensor." width="200">
</p>
<p>The MQ135 sensor is employed to monitor the quality of the surrounding air, enabling the system to detect any potential air pollution or harmful gases. On the other hand, the TMP36 sensor is responsible for measuring the ambient temperature, providing valuable data for temperature monitoring purposes. These sensors are directly connected to the Arduino Uno, leveraging its analog-to-digital converter (ADC) capabilities to convert the analog sensor readings into digital values that can be processed by the microprocessor.</p>
<p>By leveraging the Arduino Uno's versatile capabilities and integrating the MQ135 and TMP36 sensors, the system can accurately sense and monitor both the air quality and temperature. This information serves as crucial input for subsequent stages of the project, such as generating alerts in case of threshold exceedance or initiating the actuating phase for appropriate actions. The Arduino Uno acts as a reliable and robust foundation, enabling seamless integration between the physical sensing components and the overall IoT system architecture.</p>
<p>The chosen approach involves manipulating the internal registers of the ATmega328P microprocessor to ensure a robust, secure, optimized, and direct code implementation. This method provides precise control over the microprocessor's functionalities, allowing for customization according to the project's specific requirements.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adc_setup_temp</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{
  DDRC&amp;=~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>); <span class="hljs-comment">//DDRC pin 0 as input for ADC</span>
  ADCSRA = <span class="hljs-number">0x87</span>; <span class="hljs-comment">//make ADC enagle and select ck/128</span>
  ADMUX = <span class="hljs-number">0b11000000</span>; <span class="hljs-comment">//Vref Internal</span>

}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adc_setup_air</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{
  DDRC&amp;=~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>); <span class="hljs-comment">//DDRC pin 1 as input for ADC</span>
  ADCSRA = <span class="hljs-number">0x87</span>; <span class="hljs-comment">//make ADC enagle and select ck/128</span>
  ADMUX = <span class="hljs-number">0b01000001</span>; <span class="hljs-comment">//Vref AVCC pin</span>

}
</div></code></pre>
<p>In this code snippet, has been used direct the register manipulation to configure the ADC registers for analog-to-digital conversion. By setting the appropriate bits in the ADMUX and ADCSRA registers, they select the ADC input and enable it with a specific prescaler value.</p>
<p>After the configuration, an ADC conversion is initiated by setting the ADSC bit, and the code waits for the conversion to complete. Once the conversion is finished, the raw ADC value is retrieved converted into voltage using the known voltage reference.</p>
<p>This approach of manipulating the microprocessor's internal registers provides precise control over its functionalities, resulting in an optimized and tailored code implementation for the project.</p>
<h4 id="uart">UART</h4>
<p>In order to enable message transmission from the sensors to the cloud, the project utilizes the MQTT protocol. However, a crucial requirement for this implementation is establishing an internet connection. This is achieved by utilizing an ESP8266 module, which comes equipped with built-in Wi-Fi connectivity, to connect to an accessible hotspot. To facilitate data transfer from the Arduino to the ESP8266, the project leverages the UART (Universal Asynchronous Receiver-Transmitter) serial communication. By connecting the RX (receive) and TX (transmit) pins of both the Arduino and the ESP8266, a seamless data flow between the two devices is established.</p>
<p>First of all the UART is initialized:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UART_init</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">// Setup Trasmission rate</span>
    UBRR0H = (BAUD_PRESCALER &gt;&gt; <span class="hljs-number">8</span>);
    UBRR0L = BAUD_PRESCALER;

    <span class="hljs-comment">// Enable both in and out trasmission</span>
    UCSR0B = (<span class="hljs-number">1</span> &lt;&lt; RXEN0) | (<span class="hljs-number">1</span> &lt;&lt; TXEN0);

    <span class="hljs-comment">// Setup data format: 8 data bit, 1 stop</span>
    UCSR0C = (<span class="hljs-number">1</span> &lt;&lt; UCSZ01) | (<span class="hljs-number">1</span> &lt;&lt; UCSZ00);
}

</div></code></pre>
<p>Then 2 different function permits the data trasmission:</p>
<pre class="hljs"><code><div>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UART_sendString</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* data)</span>
</span>{
    <span class="hljs-comment">// Send each character until the null terminator</span>
    <span class="hljs-keyword">while</span> (*data != <span class="hljs-string">'\0'</span>)
    {
        UART_sendChar(*data);
        data++;
    }
}

</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UART_sendChar</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span>
</span>{
    <span class="hljs-comment">// Wait until the trasmission buffer is empty</span>
    <span class="hljs-keyword">while</span> (!(UCSR0A &amp; (<span class="hljs-number">1</span> &lt;&lt; UDRE0)));

    <span class="hljs-comment">// Upload the data in the trasmission buffer</span>
    UDR0 = data;
}

</div></code></pre>
<p><code>UART_sendChar</code> wait until the trasmission buffer is empty and then upload the data in the USART Data Register 0. When the data are written on the UDR, it will be trasnferred by the UART peripheral through the serial transimt pin.</p>
<h3 id="esp8266">ESP8266</h3>
<p>The ESP8266 receives from the UART the data from the Arduino UNO and sends it using the Trasport Layer Security (TLS). The connection to the cloud is established using the MQTT (Message Queuing Telemetry Transport) protocol enriched with the TLS (Transport Layer Security) security protocol. This combination ensures a secure and protected connection between the ESP8266 device and the cloud. By using the generated certificates and stored in the device flash memory, the ESP8266 device can establish a secure connection with the cloud. These certificates allow for the verification of the device and server identities in the TLS handshake process, thereby preventing potential man-in-the-middle attacks.</p>
<h2 id="cloud">Cloud</h2>
<p>The cloud section focuses on the cloud infrastructure and services employed in the IoT Security project. It includes various components critical to the IoT Security project, including the MQTT broker, database, and the utilization of Node-RED for data flow management.</p>
<p>The cloud is managed using a Digital Ocean droplet that serves as the central point of the project.</p>
<h4 id="ssh-key">SSH Key</h4>
<p>The communication for the configuration of the server is accomplished by using SSH key. Another form of security thanks to disabling of the password login of the SSH.</p>
<h4 id="ubuntu-ufw">Ubuntu UFW</h4>
<p>In the ubuntu droplet is also used the <em>Uncomplicated Firewall</em> aka UFW. To ensure that unwanted connection are unallowed.</p>
<h3 id="mqtt-broker---mosquitto">MQTT Broker - Mosquitto</h3>
<p>The MQTT broker plays a pivotal role in facilitating communication between the IoT devices and the cloud services. It acts as a central hub, receiving messages from the devices and distributing them to the relevant cloud services. The MQTT broker's implementation includes robust security measures to ensure the confidentiality, integrity, and availability of the transmitted data. This involves the use of secure authentication protocols, access controls, and encryption techniques to protect against unauthorized access and data breaches.</p>
<p>The chosen MQTT broker for the project is Mosquitto. The communication between the different subscribers is secured using TLS (Transport Layer Security). Additionally, username and password authentication is implemented to ensure authorized access to the MQTT broker.</p>
<p>To manage the TLS protocol, Certbot is utilized, and the project obtains certificates through &quot;Let's Encrypt&quot;. The obtained certificates are associated with the domain &quot;iotprojectunical.me&quot;, which is acquired from the namecheap website.</p>
<p>By leveraging TLS, username and password authentication, and obtaining certificates from Let's Encrypt, the project establishes a secure and encrypted communication channel between the MQTT broker and the subscribers. This setup ensures the confidentiality, integrity, and authenticity of the transmitted data within the IoT Security project.</p>
<p>Three foundamental user are created for authentication of Mosquitto Broker:</p>
<ul>
<li><em>mqttesp</em>: used by the esp to enstablish an MQTT connection with the broker;</li>
<li><em>mqttnodered</em>: used by the Node-RED flow;</li>
<li><em>mqttandroid</em>: used by the Android App;</li>
</ul>
<h4 id="lets-encrypt-certificate">Let's Encrypt certificate</h4>
<p>To acquire the SSL certificates to enable the TLS MQTT connection is used a nonprofit Cerficate Authority called <em>Let's Encrypt</em>.
For accomplish the certificate is used a tool called <em>Certbot</em>.</p>
<p>The SSL cerficate need a real existing domain and the one used in this project is acquired from the <em>Namecheap</em> web hosting agency.</p>
<h4 id="mosquitto-configuration">Mosquitto configuration</h4>
<p>To enable the Mosquitto TLS communication it is needed to create new configuration file in the mosquitto <em>conf.d</em>.</p>
<p>The file contain the following information:</p>
<pre class="hljs"><code><div>allow_anonymous <span class="hljs-literal">false</span>
password_file /etc/mosquitto/passwd
listener 1883 localhost
listener 8883
certfile /etc/letsencrypt/live/iotprojectunical.me/cert.pem
cafile /etc/letsencrypt/live/iotprojectunical.me/chain.pem
keyfile /etc/letsencrypt/live/iotprojectunical.me/privkey.pem
</div></code></pre>
<p>First of all disallow the anonymous publish and subscribe.
Then enable the password file where the password are saved in a sha256 encryption.
Setup then the cerficate obtained by the Certbot on the namecheap domain: <em>iotprojectunical.me</em></p>
<h3 id="database">Database</h3>
<p>In the database section, we discuss the database management system utilized in the IoT Security project.</p>
<p>The database utilized in the project is MySQL. However, for the encryption of the database, a deliberate decision was made not to employ Transparent Data Encryption (TDE). Instead, a manual approach to data encryption was deemed more suitable for educational purposes. Consequently, the data is manually encrypted using the DES (Data Encryption Standard) algorithm before being inserted into the database.</p>
<p>By employing manual encryption, the project gains greater control over the encryption process and can apply specific encryption techniques tailored to its requirements. This approach allows for the secure storage of sensitive data within the database.</p>
<p>When retrieving the data from the database, it can be decrypted, enabling various functions and operations to be performed on the decrypted data. This provides the necessary flexibility for data analysis, manipulation, and processing while maintaining the security of the sensitive information.</p>
<p>The decision to opt for manual data encryption with DES rather then of TDE demonstrates a purposeful choice made within the project for educational purposes. It offers insights into the manual encryption process and provides an opportunity to gain a deeper understanding of data encryption techniques and their implementation within a secure environment.</p>
<p>The table where the data are stored are created by using the following code:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> readings (
  device <span class="hljs-built_in">varchar</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,
  datetime <span class="hljs-built_in">TIMESTAMP</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,
  sensor <span class="hljs-built_in">varchar</span> (<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,
  <span class="hljs-keyword">value</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">44</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,
  PRIMARY <span class="hljs-keyword">KEY</span> (device, datetime, sensor)
) <span class="hljs-keyword">ENGINE</span> = <span class="hljs-keyword">InnoDB</span>

</div></code></pre>
<p>So a <em>redings</em> table is created to store both temperature and air quality readings.
It has a different column describing the various information of the stored data:</p>
<ul>
<li><strong>device</strong> value to show from wich device the reading comes; in this project is used just one device;</li>
<li><strong>Timestamp</strong> value;</li>
<li><strong>sensor</strong> value that store if it is a Temperature or Air Quality reading;</li>
<li><strong>value</strong> part that store the encrypted form of the Float calculated by the Arduino sensors.</li>
</ul>
<p>The Primary Key is setup by a triple of device, datetime and sensor.</p>
<h3 id="node-red">Node-RED</h3>
<p>Regarding Node-RED, it is also hosted in the cloud. It is protected by username and password authentication, and access to it is secured using the HTTPS protocol through the implementation of the Nginx web server.</p>
<p>Node-RED plays a crucial role in managing the flow of data within the project. Data is received by Node-RED through MQTT, ensuring secure communication with TLS encryption. From there, the data is directed towards two main destinations. Firstly, it flows towards the dashboard, which provides a visual representation of the data for monitoring and analysis. Secondly, the data is routed towards the encryption phase, where it is encrypted before being securely stored in the database.</p>
<p>By employing username and password authentication and implementing HTTPS through Nginx, Node-RED ensures secure access and communication. The integration with MQTT, along with TLS encryption, guarantees the confidentiality and integrity of the data as it traverses through the system. The combined functionalities of Node-RED, MQTT with TLS, and the secure storage of data in the database contribute to the overall security of the IoT Security project.</p>
<p>The Node-RED app is protected by an authentication system.</p>
<p align="center">
  <img src="file:///c:/Repositories/IotProjectUnical/doc/images/node-red_auth.png" alt="node-RED Auth" width="600">
</p>
<p>First of all is inject in the system the AES key created in the Cloud using the <em>OpenSSL Tool</em>.</p>
<p align="center">
  <img src="file:///c:/Repositories/IotProjectUnical/doc/images/node-RED_inject_key.png" alt="node-RED Inject Key">
</p>
<p>Then the Node-RED MQTT node subscribe to all the topic of the Mosquitto Broker, using the wildcard &quot;#&quot;.
Data that flow to the Mosquitto broker flow into 2 different subflow, one for the Dashboard and the other one for the <em><strong>Encription and Store</strong></em> phase.</p>
<p>The third phase of the Node-RED flow start from the user input on the Dashboard and follow 2 flow. One to setup some command on the Arduino Board and one for the <em><strong>Query and Decript</strong></em> phase.</p>
<h3 id="data-flow">Data flow</h3>
<p>Before goin in the deep for the Node-RED different phase let's talk about the system <strong>Data Flow</strong>.
The data flow from Arduino to the Database are in JSON format.
This is an example of <em>readings</em>.</p>
<pre class="hljs"><code><div>{<span class="hljs-attr">"sensor"</span>:<span class="hljs-string">"temperature"</span>,<span class="hljs-attr">"value"</span>: <span class="hljs-number">26.33</span>}<span class="hljs-string">"
</span></div></code></pre>
<p>The JSON is composed by a map of keyvalue of size 2. The first key/value indicates the sensor used for the reading (e.g. Temperature, Air);
the second key/value couple indicates the value of the reading.</p>
<p>Those data has to flow in Node-RED, has to be encrypted and then stored in the MySQL database.</p>
<blockquote>
<p>The encription could have been done in two different way in this system: <strong>TDE Method</strong> and <strong>Manual method</strong>.
The TDE method (Transparent data encryption) executes encryption and decryption within the database engine itself. This method doesn’t require code modification of the database or application and is easier for admins to manage. However is not the best eligible in a didactic enviroment. The manual method is the best fit for understanding how encryption works and to study also the AES encryption method.</p>
</blockquote>
<p>For this project, it is chosen to encrypt only the value part of the JSON data. The encryption is made by using the AES algorithm given by a Node-RED node.</p>
<blockquote>
<h4 id="aes"><strong>AES</strong></h4>
<p>AES (Advanced Encryption Standard) is a widely used encryption algorithm that ensures the security and confidentiality of data. It operates on blocks of data and employs a symmetric key, meaning the same key is used for both encryption and decryption.</p>
<p>In AES encryption, the data is divided into fixed-size blocks and processed through multiple rounds of transformation, including substitution, permutation, and mixing operations. These operations, performed on both the data and the encryption key, make AES highly secure and resistant to cryptographic attacks.</p>
<p>AES supports three key sizes: 128 bits, 192 bits, and 256 bits. The larger the key size, the stronger the encryption. The chosen key size determines the number of rounds applied during the encryption process.</p>
<p>To encrypt data using AES, the plaintext is first divided into blocks and padded if necessary. Then, the encryption key is applied to each block, resulting in a ciphertext. Decryption involves applying the same key to the ciphertext, reversing the encryption process, and obtaining the original plaintext.</p>
<p>AES encryption provides robust protection for sensitive information, making it suitable for a wide range of applications, including secure communication, data storage, and cryptographic protocols. Its widespread adoption and recognition as a standard encryption algorithm highlight its effectiveness in ensuring data confidentiality and integrity.</p>
</blockquote>
<p>The data pass through the Node-RED flow and is redirected both into the Dashboard as clear data and in the Encrytpion node.
After the Encryption the data is stored in the MySQL database.</p>
<p>From the Dashboard, an user can ask to the Database some datatime based query (see in the Dashboard paragraph). The query is applied to the database and the encrypted data is given as output. The data is then decrypted and is shown in the Dashboard.</p>
<h3 id="node-red---encrypt-and-store">Node-RED - <em>Encrypt and Store</em></h3>
<p>The first Node-RED subflow analyzed is the <em>Encrypt and Store</em>.</p>
<p><img src="file:///c:/Repositories/IotProjectUnical/doc/images/Node-RED_encrypt_and_store.png" alt="Node-RED Encrypt and Store module"></p>
<p>The input messages are in the JSON form. The infos that the system need from the message in input are:</p>
<ul>
<li><em>Device</em>: which device is sending information; it can be retrieved from the MQTT topic;</li>
<li><em>Sensor</em>: which device sensor is reading; it can be retrieved from the JSON in input;</li>
<li><em>Value</em>: which value has the reading; it can be retrieved from the JSON in input;</li>
</ul>
<p>Every message that flow in this subflow has to pass in the Encryption node.
The Encryption node take the <em>msg.key</em> and the <em>msg.payload</em> and makes the AES encryption.</p>
<p>After the encryption the message has to be purged from the key (or it will be shown in clear) and to be sent in the <em>function node</em> that build the query for the Database.
An example of query is shown belove:</p>
<pre class="hljs"><code><div>
<span class="hljs-keyword">USE</span> sensors;
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> Readings(device, datetime, sensor, <span class="hljs-keyword">value</span>) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'D001'</span>, <span class="hljs-keyword">NOW</span>(), <span class="hljs-string">'air'</span>, <span class="hljs-string">'120'</span>);`

</div></code></pre>
<p>The query has to be set in the <em>msg.topic</em> and has to flow in the <em>MySQL</em> node.</p>
<h3 id="node-red---query-and-decrypt">Node-RED - <em>Query and Decrypt</em></h3>
<p>The second Node-RED sublflow analyzed is the <em>Query and Decrypt</em>.</p>
<p><img src="file:///c:/Repositories/IotProjectUnical/doc/images/Node-RED_query_and_decrypt.png" alt="Node-RED Query and Decrypt module"></p>
<p>The input this time is from the user dashboard, analyzed below.</p>
<p>After the user input the data are converted in good format to be joined in a Query for the database.
This an example query for the database:</p>
<pre class="hljs"><code><div>
<span class="hljs-keyword">USE</span> sensors;
<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Readings <span class="hljs-keyword">WHERE</span> device=<span class="hljs-string">'D001'</span>
  <span class="hljs-keyword">AND</span> sensor=<span class="hljs-string">'temperature'</span>
  <span class="hljs-keyword">AND</span> datetime&gt;=<span class="hljs-string">'2023-06-26'</span>
  <span class="hljs-keyword">AND</span> datetime&lt;<span class="hljs-string">'2023-06-27'</span>;

</div></code></pre>
<p>After the DB interrogation the output is decrypted and from them are generated two different output: a <strong>table</strong> with all value founded from the query and a <strong>graph</strong> with the curves that the sensing made in the datatime range.</p>
<h2 id="northbound">Northbound</h2>
<p>The Northbound section of this report focuses on the applications that transparently utilize the data generated by the physical devices for visualization and interaction. This section encompasses two key components: the Android App and the Node-RED Dashboard.</p>
<h3 id="android-app">Android App</h3>
<p>The Android App serves as a user-friendly interface, allowing users to access and interact with the IoT system. It seamlessly integrates with the data generated by the physical devices, providing real-time updates, control options, and visualizations. The Android App employs robust security measures, including secure user authentication and encrypted communication, to ensure the confidentiality and integrity of the data exchanged between the app and the IoT system.</p>
<p>The Android App is built using the framework <strong>Flutter</strong>.</p>
<p>Using the library <em>mqtt_client</em> written in Dart programming language, is it possible to connect every smarthphone to the Iot Project Unical project.</p>
<p>The app is composed by 4 module:</p>
<ul>
<li><em><strong>CmdValueHandler.dart</strong></em>: utils module to manage the command value sent by the android app to the system;</li>
<li><em><strong>SensorValueHandler.dart</strong></em>: utils module to manage the sensing value sent by the system to the android app;</li>
<li><em><strong>main.dart</strong></em>: main class that manage the app frontend;</li>
<li><em><strong>MqttHandler.dart</strong></em>: that manage the MQTT through TLS connection.</li>
</ul>
<h4 id="mqtthandlerdart">MqttHandler.dart</h4>
<p>The most important part of the Mqtt handler is the connection one.</p>
<pre class="hljs"><code><div>client = MqttServerClient.withPort(
        <span class="hljs-string">'iotprojectunical.me'</span>, <span class="hljs-string">'telefono_di_gixs1'</span>, <span class="hljs-number">8883</span>);
    client.logging(<span class="hljs-keyword">on</span>: <span class="hljs-keyword">true</span>);
    client.onConnected = onConnected;
    client.onDisconnected = onDisconnected;
    client.onUnsubscribed = onUnsubscribed;
    client.onSubscribed = onSubscribed;
    client.onSubscribeFail = onSubscribeFail;
    client.pongCallback = pong;
    client.keepAlivePeriod = <span class="hljs-number">60</span>;
    client.logging(<span class="hljs-keyword">on</span>: <span class="hljs-keyword">true</span>);
    client.secure = <span class="hljs-keyword">true</span>;
</div></code></pre>
<p>Using the flag <em>client.secure</em> the flutter app knows that have to use the default <em>Secure Context</em>.</p>
<p>The other code written is about the handling of topic and JSon message exchanged.</p>
<h4 id="front-end">Front End</h4>
<p align="center">
  <img src="file:///c:/Repositories/IotProjectUnical/doc/images/android_app.jpg" alt="Android App Front End" width="300">
</p>
<p>The app shows in two text field the last values of <em>Air quality</em> and <em>Temperature</em>.</p>
<p>The buttons are disposed to achieve the system actuation.
The one on the left close the alarm generated when the values overcome the thresholds.</p>
<p>The one on the right change the vent state. If the vent is on, put it off and viceversa.</p>
<p>That is done by sending through mqtt the command messages.</p>
<h3 id="nodered-dashboard">NodeRED Dashboard</h3>
<p>The Node-RED Dashboard complements the Android App by providing an additional platform for data visualization and interaction. It offers a customizable and intuitive interface that allows users to monitor and control the IoT system's data flow in real-time. The Node-RED Dashboard incorporates security features, such as secure access controls and encrypted communication channels, to safeguard the data as it flows between the IoT system and the dashboard.</p>
<p>The Northbound section highlights the significance of the Android App and the Node-RED Dashboard in enabling users to effectively visualize and interact with the data generated by the physical devices. By ensuring the security and usability of these applications, the IoT system becomes more accessible and user-friendly, empowering users to make informed decisions based on the insights derived from the data.</p>
<h4 id="back-end">Back-end</h4>
<p>The Dashboard back-end is composed of two part.</p>
<p>The one shown in the <a href="#node-red---query-and-decrypt">Query and Decrypt</a>, for the output from the database.
The second one is shown below and it is a realtime dashboard, showing the last value received from the sensor.</p>
<p><img src="file:///c:/Repositories/IotProjectUnical/doc/images/Node-RED_dashboard.png" alt="Node-RED Dashboard backend"></p>
<p>Data already formatted flow into a Non-editable Text Field and is show realtime.
Also a chart of the last hour readings is made realtime.</p>
<h4 id="front-end">Front-end</h4>
<p>To navigate toward the two part of the of the dashboard is build a <em>side navigation menu</em>.</p>
<p><img src="file:///c:/Repositories/IotProjectUnical/doc/images/Navigation_menu.png" alt="Navigation menu"></p>
<p>Here the user can switch from the realtime dashboard and the dashboard showing the output query from database.</p>
<p>The <strong>realtime dashboard</strong> show the last value received from the sensors and give also a graph of the last values received.</p>
<p><img src="file:///c:/Repositories/IotProjectUnical/doc/images/realtime_dashboard.png" alt="Real time dashboard"></p>
<p>The <strong>query database</strong> dashboard part is divided in two part: <em>user input</em> and <em>output</em>.</p>
<p><img src="file:///c:/Repositories/IotProjectUnical/doc/images/Dashboard_from_db.png" alt="Query db dashboard"></p>
<p>The <em>user input</em> give the possibility to insert information to query the database.</p>
<p>The <em>output</em> part give the output of the query as table and as graph.</p>
<h2 id="conclusion">Conclusion</h2>
<p>The IoT Security project has successfully addressed the crucial aspects of securing an IoT system, encompassing physical devices, cloud infrastructure, databases, and data visualization applications. By implementing robust security measures across these components, the project has mitigated potential vulnerabilities and ensured the confidentiality, integrity, and availability of the data.</p>
<p>Throughout the project, a comprehensive approach to security has been taken. Physical devices have been protected against tampering and unauthorized access, while secure protocols such as MQTT with TLS have been employed for communication between devices and the cloud. The cloud infrastructure, including the MQTT broker, database, and Node-RED, has been secured with authentication mechanisms, access controls, and encrypted connections. Moreover, the Android App and Node-RED Dashboard have provided intuitive interfaces for data visualization and user interaction while maintaining the necessary security measures.</p>
<p>By deliberately opting for manual data encryption in the database and employing encryption algorithms like DES, the project has demonstrated a deep understanding of encryption techniques and their application within a secure environment.</p>
<p>The successful implementation of this IoT Security project serves as a testament to the importance of addressing security concerns in IoT systems. The project highlights the significance of secure communication, authentication, access controls, and data encryption in safeguarding the privacy and integrity of IoT data.</p>
<p>As technology advances and the IoT landscape continues to expand, it becomes increasingly critical to prioritize security measures. This project has provided valuable insights and recommendations for enhancing the security posture of similar IoT deployments, serving as a foundation for future research and development in the field of IoT Security.</p>
<p>Overall, the project has achieved its objective of implementing robust security measures to protect the IoT system, enabling users to leverage the power of IoT technology while ensuring the confidentiality and integrity of their data.</p>

</body>
</html>
